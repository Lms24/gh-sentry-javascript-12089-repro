/*! @sentry/aws-serverless 8.2.1 (8fbff594c) | https://github.com/getsentry/sentry-javascript */
var t = require("perf_hooks"),
  n = require("path"),
  e = require("util"),
  r = require("module"),
  o = require("fs"),
  i = require("os"),
  s = require("tty"),
  u = require("url"),
  c = require("process"),
  a = require("child_process"),
  l = require("events"),
  f = require("worker_threads"),
  d = require("inspector"),
  h = require("http"),
  p = require("node:http"),
  S = require("node:https"),
  E = require("stream"),
  m = require("zlib"),
  T = require("net"),
  _ = require("tls"),
  b = require("async_hooks"),
  v = "undefined" != typeof document ? document.currentScript : null;
function y(t) {
  var n = Object.create(null);
  return (
    t &&
      Object.keys(t).forEach(function (e) {
        if ("default" !== e) {
          var r = Object.getOwnPropertyDescriptor(t, e);
          Object.defineProperty(
            n,
            e,
            r.get
              ? r
              : {
                  enumerable: !0,
                  get: function () {
                    return t[e];
                  },
                }
          );
        }
      }),
    (n.default = t),
    Object.freeze(n)
  );
}
function R(t, n) {
  return (
    n.forEach(function (n) {
      n &&
        "string" != typeof n &&
        !Array.isArray(n) &&
        Object.keys(n).forEach(function (e) {
          if ("default" !== e && !(e in t)) {
            var r = Object.getOwnPropertyDescriptor(n, e);
            Object.defineProperty(
              t,
              e,
              r.get
                ? r
                : {
                    enumerable: !0,
                    get: function () {
                      return n[e];
                    },
                  }
            );
          }
        });
    }),
    Object.freeze(t)
  );
}
var A = y(n),
  O = y(e),
  g = y(i),
  N = y(d),
  C = y(h),
  L = y(p),
  I = y(S),
  M = y(T),
  w = y(_);
const Z = Object.prototype.toString;
function P(t) {
  switch (Z.call(t)) {
    case "[object Error]":
    case "[object Exception]":
    case "[object DOMException]":
      return !0;
    default:
      return Y(t, Error);
  }
}
function V(t, n) {
  return Z.call(t) === `[object ${n}]`;
}
function G(t) {
  return V(t, "String");
}
function X(t) {
  return (
    "object" == typeof t &&
    null !== t &&
    "__sentry_template_string__" in t &&
    "__sentry_template_values__" in t
  );
}
function U(t) {
  return V(t, "Object");
}
function W(t) {
  return Boolean(t && t.then && "function" == typeof t.then);
}
function Y(t, n) {
  try {
    return t instanceof n;
  } catch (t) {
    return !1;
  }
}
function H(t) {
  return !("object" != typeof t || null === t || (!t.__isVue && !t.i));
}
function D(t, n = 0) {
  return "string" != typeof t || 0 === n || t.length <= n
    ? t
    : `${t.slice(0, n)}...`;
}
function j(t, n) {
  let e = t;
  const r = e.length;
  if (r <= 150) return e;
  n > r && (n = r);
  let o = Math.max(n - 60, 0);
  o < 5 && (o = 0);
  let i = Math.min(o + 140, r);
  return (
    i > r - 5 && (i = r),
    i === r && (o = Math.max(i - 140, 0)),
    (e = e.slice(o, i)),
    o > 0 && (e = `'{snip} ${e}`),
    i < r && (e += " {snip}"),
    e
  );
}
function x(t, n) {
  if (!Array.isArray(t)) return "";
  const e = [];
  for (let n = 0; n < t.length; n++) {
    const r = t[n];
    try {
      H(r) ? e.push("[VueViewModel]") : e.push(String(r));
    } catch (t) {
      e.push("[value cannot be serialized]");
    }
  }
  return e.join(n);
}
function k(t, n, e = !1) {
  return (
    !!G(t) &&
    (V(n, "RegExp") ? n.test(t) : !!G(n) && (e ? t === n : t.includes(n)))
  );
}
function K(t, n = [], e = !1) {
  return n.some((n) => k(t, n, e));
}
function B(t, n, e = 250, r, o, i, s) {
  if (
    !(i.exception && i.exception.values && s && Y(s.originalException, Error))
  )
    return;
  const u =
    i.exception.values.length > 0
      ? i.exception.values[i.exception.values.length - 1]
      : void 0;
  var c, a;
  u &&
    (i.exception.values =
      ((c = F(t, n, o, s.originalException, r, i.exception.values, u, 0)),
      (a = e),
      c.map((t) => (t.value && (t.value = D(t.value, a)), t))));
}
function F(t, n, e, r, o, i, s, u) {
  if (i.length >= e + 1) return i;
  let c = [...i];
  if (Y(r[o], Error)) {
    J(s, u);
    const i = t(n, r[o]),
      a = c.length;
    z(i, o, a, u), (c = F(t, n, e, r[o], o, [i, ...c], i, a));
  }
  return (
    Array.isArray(r.errors) &&
      r.errors.forEach((r, i) => {
        if (Y(r, Error)) {
          J(s, u);
          const a = t(n, r),
            l = c.length;
          z(a, `errors[${i}]`, l, u), (c = F(t, n, e, r, o, [a, ...c], a, l));
        }
      }),
    c
  );
}
function J(t, n) {
  (t.mechanism = t.mechanism || { type: "generic", handled: !0 }),
    (t.mechanism = {
      ...t.mechanism,
      ...("AggregateError" === t.type && { is_exception_group: !0 }),
      exception_id: n,
    });
}
function z(t, n, e, r) {
  (t.mechanism = t.mechanism || { type: "generic", handled: !0 }),
    (t.mechanism = {
      ...t.mechanism,
      type: "chained",
      source: n,
      exception_id: e,
      parent_id: r,
    });
}
const Q = globalThis;
function $(t, n, e) {
  const r = e || Q,
    o = (r.__SENTRY__ = r.__SENTRY__ || {});
  return o[t] || (o[t] = n());
}
const q = Q,
  tt = 80;
function nt(t, n) {
  const e = t,
    r = [];
  let o, i, s, u, c;
  if (!e || !e.tagName) return "";
  if (q.HTMLElement && e instanceof HTMLElement && e.dataset) {
    if (e.dataset.sentryComponent) return e.dataset.sentryComponent;
    if (e.dataset.sentryElement) return e.dataset.sentryElement;
  }
  r.push(e.tagName.toLowerCase());
  const a =
    n && n.length
      ? n.filter((t) => e.getAttribute(t)).map((t) => [t, e.getAttribute(t)])
      : null;
  if (a && a.length)
    a.forEach((t) => {
      r.push(`[${t[0]}="${t[1]}"]`);
    });
  else if ((e.id && r.push(`#${e.id}`), (o = e.className), o && G(o)))
    for (i = o.split(/\s+/), c = 0; c < i.length; c++) r.push(`.${i[c]}`);
  const l = ["aria-label", "type", "name", "title", "alt"];
  for (c = 0; c < l.length; c++)
    (s = l[c]), (u = e.getAttribute(s)), u && r.push(`[${s}="${u}"]`);
  return r.join("");
}
const et = ["debug", "info", "warn", "error", "log", "assert", "trace"],
  rt = {};
function ot(t) {
  if (!("console" in Q)) return t();
  const n = Q.console,
    e = {},
    r = Object.keys(rt);
  r.forEach((t) => {
    const r = rt[t];
    (e[t] = n[t]), (n[t] = r);
  });
  try {
    return t();
  } finally {
    r.forEach((t) => {
      n[t] = e[t];
    });
  }
}
const it = (function () {
    let t = !1;
    const n = {
      enable: () => {
        t = !0;
      },
      disable: () => {
        t = !1;
      },
      isEnabled: () => t,
    };
    return (
      et.forEach((t) => {
        n[t] = () => {};
      }),
      n
    );
  })(),
  st = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;
function ut(t, n = !1) {
  const {
    host: e,
    path: r,
    pass: o,
    port: i,
    projectId: s,
    protocol: u,
    publicKey: c,
  } = t;
  return `${u}://${c}${n && o ? `:${o}` : ""}@${e}${i ? `:${i}` : ""}/${
    r ? `${r}/` : r
  }${s}`;
}
function ct(t) {
  return {
    protocol: t.protocol,
    publicKey: t.publicKey || "",
    pass: t.pass || "",
    host: t.host,
    port: t.port || "",
    path: t.path || "",
    projectId: t.projectId,
  };
}
function at(t) {
  const n =
    "string" == typeof t
      ? (function (t) {
          const n = st.exec(t);
          if (!n)
            return void ot(() => {
              console.error(`Invalid Sentry Dsn: ${t}`);
            });
          const [e, r, o = "", i, s = "", u] = n.slice(1);
          let c = "",
            a = u;
          const l = a.split("/");
          if (
            (l.length > 1 && ((c = l.slice(0, -1).join("/")), (a = l.pop())), a)
          ) {
            const t = a.match(/^\d+/);
            t && (a = t[0]);
          }
          return ct({
            host: i,
            pass: o,
            path: c,
            projectId: a,
            port: s,
            protocol: e,
            publicKey: r,
          });
        })(t)
      : ct(t);
  if (n) return n;
}
class lt extends Error {
  constructor(t, n = "warn") {
    super(t),
      (this.message = t),
      (this.name = new.target.prototype.constructor.name),
      Object.setPrototypeOf(this, new.target.prototype),
      (this.logLevel = n);
  }
}
function ft(t, n, e) {
  if (!(n in t)) return;
  const r = t[n],
    o = e(r);
  "function" == typeof o &&
    (function (t, n) {
      try {
        const e = n.prototype || {};
        (t.prototype = n.prototype = e), dt(t, "__sentry_original__", n);
      } catch (t) {}
    })(o, r),
    (t[n] = o);
}
function dt(t, n, e) {
  try {
    Object.defineProperty(t, n, { value: e, writable: !0, configurable: !0 });
  } catch (t) {}
}
function ht(t) {
  if (P(t))
    return { message: t.message, name: t.name, stack: t.stack, ...St(t) };
  if (((n = t), "undefined" != typeof Event && Y(n, Event))) {
    const n = {
      type: t.type,
      target: pt(t.target),
      currentTarget: pt(t.currentTarget),
      ...St(t),
    };
    return (
      "undefined" != typeof CustomEvent &&
        Y(t, CustomEvent) &&
        (n.detail = t.detail),
      n
    );
  }
  return t;
  var n;
}
function pt(t) {
  try {
    return (
      (n = t),
      "undefined" != typeof Element && Y(n, Element)
        ? (function (t, n = {}) {
            if (!t) return "<unknown>";
            try {
              let e = t;
              const r = 5,
                o = [];
              let i = 0,
                s = 0;
              const u = " > ",
                c = u.length;
              let a;
              const l = Array.isArray(n) ? n : n.keyAttrs,
                f = (!Array.isArray(n) && n.maxStringLength) || tt;
              for (
                ;
                e &&
                i++ < r &&
                ((a = nt(e, l)),
                !("html" === a || (i > 1 && s + o.length * c + a.length >= f)));

              )
                o.push(a), (s += a.length), (e = e.parentNode);
              return o.reverse().join(u);
            } catch (t) {
              return "<unknown>";
            }
          })(t)
        : Object.prototype.toString.call(t)
    );
  } catch (t) {
    return "<unknown>";
  }
  var n;
}
function St(t) {
  if ("object" == typeof t && null !== t) {
    const n = {};
    for (const e in t)
      Object.prototype.hasOwnProperty.call(t, e) && (n[e] = t[e]);
    return n;
  }
  return {};
}
function Et(t) {
  return mt(t, new Map());
}
function mt(t, n) {
  if (
    (function (t) {
      if (!U(t)) return !1;
      try {
        const n = Object.getPrototypeOf(t).constructor.name;
        return !n || "Object" === n;
      } catch (t) {
        return !0;
      }
    })(t)
  ) {
    const e = n.get(t);
    if (void 0 !== e) return e;
    const r = {};
    n.set(t, r);
    for (const e of Object.keys(t)) void 0 !== t[e] && (r[e] = mt(t[e], n));
    return r;
  }
  if (Array.isArray(t)) {
    const e = n.get(t);
    if (void 0 !== e) return e;
    const r = [];
    return (
      n.set(t, r),
      t.forEach((t) => {
        r.push(mt(t, n));
      }),
      r
    );
  }
  return t;
}
const Tt = 50,
  _t = "?",
  bt = /\(error: (.*)\)/,
  vt = /captureMessage|captureException/;
function yt(...t) {
  const n = t.sort((t, n) => t[0] - n[0]).map((t) => t[1]);
  return (t, e = 0, r = 0) => {
    const o = [],
      i = t.split("\n");
    for (let t = e; t < i.length; t++) {
      const e = i[t];
      if (e.length > 1024) continue;
      const s = bt.test(e) ? e.replace(bt, "$1") : e;
      if (!s.match(/\S*Error: /)) {
        for (const t of n) {
          const n = t(s);
          if (n) {
            o.push(n);
            break;
          }
        }
        if (o.length >= Tt + r) break;
      }
    }
    return (function (t) {
      if (!t.length) return [];
      const n = Array.from(t);
      /sentryWrapped/.test(n[n.length - 1].function || "") && n.pop();
      n.reverse(),
        vt.test(n[n.length - 1].function || "") &&
          (n.pop(), vt.test(n[n.length - 1].function || "") && n.pop());
      return n
        .slice(0, Tt)
        .map((t) => ({
          ...t,
          filename: t.filename || n[n.length - 1].filename,
          function: t.function || _t,
        }));
    })(o.slice(r));
  };
}
function Rt(t) {
  return Array.isArray(t) ? yt(...t) : t;
}
const At = "<anonymous>";
const Ot = {},
  gt = {};
function Nt(t, n) {
  (Ot[t] = Ot[t] || []), Ot[t].push(n);
}
function Ct(t, n) {
  gt[t] || (n(), (gt[t] = !0));
}
function Lt(t, n) {
  const e = t && Ot[t];
  if (e)
    for (const t of e)
      try {
        t(n);
      } catch (t) {}
}
function It(t) {
  const n = "console";
  Nt(n, t), Ct(n, Mt);
}
function Mt() {
  "console" in Q &&
    et.forEach(function (t) {
      t in Q.console &&
        ft(Q.console, t, function (n) {
          return (
            (rt[t] = n),
            function (...n) {
              Lt("console", { args: n, level: t });
              const e = rt[t];
              e && e.apply(Q.console, n);
            }
          );
        });
    });
}
const wt = 1e3;
function Zt() {
  return Date.now() / wt;
}
const Pt = (function () {
  const { performance: t } = Q;
  if (!t || !t.now) return Zt;
  const n = Date.now() - t.now(),
    e = null == t.timeOrigin ? n : t.timeOrigin;
  return () => (e + t.now()) / wt;
})();
(() => {
  const { performance: t } = Q;
  if (!t || !t.now) return;
  const n = 36e5,
    e = t.now(),
    r = Date.now(),
    o = t.timeOrigin ? Math.abs(t.timeOrigin + e - r) : n,
    i = o < n,
    s = t.timing && t.timing.navigationStart,
    u = "number" == typeof s ? Math.abs(s + e - r) : n;
  (i || u < n) && o <= u && t.timeOrigin;
})();
let Vt = null;
function Gt() {
  (Vt = Q.onerror),
    (Q.onerror = function (t, n, e, r, o) {
      return (
        Lt("error", { column: r, error: o, line: e, msg: t, url: n }),
        !(!Vt || Vt.__SENTRY_LOADER__) && Vt.apply(this, arguments)
      );
    }),
    (Q.onerror.__SENTRY_INSTRUMENTED__ = !0);
}
let Xt = null;
function Ut() {
  (Xt = Q.onunhandledrejection),
    (Q.onunhandledrejection = function (t) {
      return (
        Lt("unhandledrejection", t),
        !(Xt && !Xt.__SENTRY_LOADER__) || Xt.apply(this, arguments)
      );
    }),
    (Q.onunhandledrejection.__SENTRY_INSTRUMENTED__ = !0);
}
var Wt =
  "undefined" != typeof globalThis
    ? globalThis
    : "undefined" != typeof window
      ? window
      : "undefined" != typeof global
        ? global
        : "undefined" != typeof self
          ? self
          : {};
function Yt(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default")
    ? t.default
    : t;
}
function Ht(t) {
  if (t.__esModule) return t;
  var n = t.default;
  if ("function" == typeof n) {
    var e = function t() {
      return this instanceof t
        ? Reflect.construct(n, arguments, this.constructor)
        : n.apply(this, arguments);
    };
    e.prototype = n.prototype;
  } else e = {};
  return (
    Object.defineProperty(e, "__esModule", { value: !0 }),
    Object.keys(t).forEach(function (n) {
      var r = Object.getOwnPropertyDescriptor(t, n);
      Object.defineProperty(
        e,
        n,
        r.get
          ? r
          : {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }
      );
    }),
    e
  );
}
function Dt() {
  const t = Q,
    n = t.crypto || t.msCrypto;
  let e = () => 16 * Math.random();
  try {
    if (n && n.randomUUID) return n.randomUUID().replace(/-/g, "");
    n &&
      n.getRandomValues &&
      (e = () => {
        const t = new Uint8Array(1);
        return n.getRandomValues(t), t[0];
      });
  } catch (t) {}
  return ([1e7] + 1e3 + 4e3 + 8e3 + 1e11).replace(/[018]/g, (t) =>
    (t ^ ((15 & e()) >> (t / 4))).toString(16)
  );
}
function jt(t, n) {
  const e = (function (t) {
    return t.exception && t.exception.values ? t.exception.values[0] : void 0;
  })(t);
  if (!e) return;
  const r = e.mechanism;
  if (
    ((e.mechanism = { type: "generic", handled: !0, ...r, ...n }),
    n && "data" in n)
  ) {
    const t = { ...(r && r.data), ...n.data };
    e.mechanism.data = t;
  }
}
const xt =
  /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/;
function kt(t, n, e = 5) {
  if (void 0 === n.lineno) return;
  const r = t.length,
    o = Math.max(Math.min(r - 1, n.lineno - 1), 0);
  (n.pre_context = t.slice(Math.max(0, o - e), o).map((t) => j(t, 0))),
    (n.context_line = j(t[Math.min(r - 1, o)], n.colno || 0)),
    (n.post_context = t
      .slice(Math.min(o + 1, r), o + 1 + e)
      .map((t) => j(t, 0)));
}
function Kt(t) {
  if (t && t.__sentry_captured__) return !0;
  try {
    dt(t, "__sentry_captured__", !0);
  } catch (t) {}
  return !1;
}
function Bt(t) {
  return Array.isArray(t) ? t : [t];
}
function Ft(t, n = 100, e = 1 / 0) {
  try {
    return zt("", t, n, e);
  } catch (t) {
    return { ERROR: `**non-serializable** (${t})` };
  }
}
function Jt(t, n = 3, e = 102400) {
  const r = Ft(t, n);
  return (
    (o = r),
    (function (t) {
      return ~-encodeURI(t).split(/%..|./).length;
    })(JSON.stringify(o)) > e
      ? Jt(t, n - 1, e)
      : r
  );
  var o;
}
function zt(
  t,
  n,
  e = 1 / 0,
  r = 1 / 0,
  o = (function () {
    const t = "function" == typeof WeakSet,
      n = t ? new WeakSet() : [];
    return [
      function (e) {
        if (t) return !!n.has(e) || (n.add(e), !1);
        for (let t = 0; t < n.length; t++) if (n[t] === e) return !0;
        return n.push(e), !1;
      },
      function (e) {
        if (t) n.delete(e);
        else
          for (let t = 0; t < n.length; t++)
            if (n[t] === e) {
              n.splice(t, 1);
              break;
            }
      },
    ];
  })()
) {
  const [i, s] = o;
  if (
    null == n ||
    (["number", "boolean", "string"].includes(typeof n) && !Number.isNaN(n))
  )
    return n;
  const u = (function (t, n) {
    try {
      if ("domain" === t && n && "object" == typeof n && n.u) return "[Domain]";
      if ("domainEmitter" === t) return "[DomainEmitter]";
      if ("undefined" != typeof global && n === global) return "[Global]";
      if ("undefined" != typeof window && n === window) return "[Window]";
      if ("undefined" != typeof document && n === document) return "[Document]";
      if (H(n)) return "[VueViewModel]";
      if (
        U((e = n)) &&
        "nativeEvent" in e &&
        "preventDefault" in e &&
        "stopPropagation" in e
      )
        return "[SyntheticEvent]";
      if ("number" == typeof n && n != n) return "[NaN]";
      if ("function" == typeof n)
        return `[Function: ${(function (t) {
          try {
            return (t && "function" == typeof t && t.name) || At;
          } catch (t) {
            return At;
          }
        })(n)}]`;
      if ("symbol" == typeof n) return `[${String(n)}]`;
      if ("bigint" == typeof n) return `[BigInt: ${String(n)}]`;
      const r = (function (t) {
        const n = Object.getPrototypeOf(t);
        return n ? n.constructor.name : "null prototype";
      })(n);
      return /^HTML(\w*)Element$/.test(r)
        ? `[HTMLElement: ${r}]`
        : `[object ${r}]`;
    } catch (t) {
      return `**non-serializable** (${t})`;
    }
    var e;
  })(t, n);
  if (!u.startsWith("[object ")) return u;
  if (n.__sentry_skip_normalization__) return n;
  const c =
    "number" == typeof n.__sentry_override_normalization_depth__
      ? n.__sentry_override_normalization_depth__
      : e;
  if (0 === c) return u.replace("object ", "");
  if (i(n)) return "[Circular ~]";
  const a = n;
  if (a && "function" == typeof a.toJSON)
    try {
      return zt("", a.toJSON(), c - 1, r, o);
    } catch (t) {}
  const l = Array.isArray(n) ? [] : {};
  let f = 0;
  const d = ht(n);
  for (const t in d) {
    if (!Object.prototype.hasOwnProperty.call(d, t)) continue;
    if (f >= r) {
      l[t] = "[MaxProperties ~]";
      break;
    }
    const n = d[t];
    (l[t] = zt(t, n, c - 1, r, o)), f++;
  }
  return s(n), l;
}
const Qt =
  /^(\S+:\\|\/?)([\s\S]*?)((?:\.{1,2}|[^/\\]+?|)(\.[^./\\]*|))(?:[/\\]*)$/;
function $t(t) {
  const n = t.length > 1024 ? `<truncated>${t.slice(-1024)}` : t,
    e = Qt.exec(n);
  return e ? e.slice(1) : [];
}
function qt(...t) {
  let n = "",
    e = !1;
  for (let r = t.length - 1; r >= -1 && !e; r--) {
    const o = r >= 0 ? t[r] : "/";
    o && ((n = `${o}/${n}`), (e = "/" === o.charAt(0)));
  }
  return (
    (n = (function (t, n) {
      let e = 0;
      for (let n = t.length - 1; n >= 0; n--) {
        const r = t[n];
        "." === r
          ? t.splice(n, 1)
          : ".." === r
            ? (t.splice(n, 1), e++)
            : e && (t.splice(n, 1), e--);
      }
      if (n) for (; e--; e) t.unshift("..");
      return t;
    })(
      n.split("/").filter((t) => !!t),
      !e
    ).join("/")),
    (e ? "/" : "") + n || "."
  );
}
function tn(t) {
  let n = 0;
  for (; n < t.length && "" === t[n]; n++);
  let e = t.length - 1;
  for (; e >= 0 && "" === t[e]; e--);
  return n > e ? [] : t.slice(n, e - n + 1);
}
var nn;
function en(t) {
  return new on((n) => {
    n(t);
  });
}
function rn(t) {
  return new on((n, e) => {
    e(t);
  });
}
!(function (t) {
  t[(t.PENDING = 0)] = "PENDING";
  t[(t.RESOLVED = 1)] = "RESOLVED";
  t[(t.REJECTED = 2)] = "REJECTED";
})(nn || (nn = {}));
class on {
  constructor(t) {
    on.prototype.__init.call(this),
      on.prototype.__init2.call(this),
      on.prototype.__init3.call(this),
      on.prototype.__init4.call(this),
      (this.l = nn.PENDING),
      (this.h = []);
    try {
      t(this.p, this.S);
    } catch (t) {
      this.S(t);
    }
  }
  then(t, n) {
    return new on((e, r) => {
      this.h.push([
        !1,
        (n) => {
          if (t)
            try {
              e(t(n));
            } catch (t) {
              r(t);
            }
          else e(n);
        },
        (t) => {
          if (n)
            try {
              e(n(t));
            } catch (t) {
              r(t);
            }
          else r(t);
        },
      ]),
        this.m();
    });
  }
  catch(t) {
    return this.then((t) => t, t);
  }
  finally(t) {
    return new on((n, e) => {
      let r, o;
      return this.then(
        (n) => {
          (o = !1), (r = n), t && t();
        },
        (n) => {
          (o = !0), (r = n), t && t();
        }
      ).then(() => {
        o ? e(r) : n(r);
      });
    });
  }
  __init() {
    this.p = (t) => {
      this.T(nn.RESOLVED, t);
    };
  }
  __init2() {
    this.S = (t) => {
      this.T(nn.REJECTED, t);
    };
  }
  __init3() {
    this.T = (t, n) => {
      this.l === nn.PENDING &&
        (W(n)
          ? n.then(this.p, this.S)
          : ((this.l = t), (this._ = n), this.m()));
    };
  }
  __init4() {
    this.m = () => {
      if (this.l === nn.PENDING) return;
      const t = this.h.slice();
      (this.h = []),
        t.forEach((t) => {
          t[0] ||
            (this.l === nn.RESOLVED && t[1](this._),
            this.l === nn.REJECTED && t[2](this._),
            (t[0] = !0));
        });
    };
  }
}
function sn(t) {
  const n = [];
  function e(t) {
    return n.splice(n.indexOf(t), 1)[0];
  }
  return {
    $: n,
    add: function (r) {
      if (!(void 0 === t || n.length < t))
        return rn(
          new lt("Not adding Promise because buffer limit was reached.")
        );
      const o = r();
      return (
        -1 === n.indexOf(o) && n.push(o),
        o.then(() => e(o)).then(null, () => e(o).then(null, () => {})),
        o
      );
    },
    drain: function (t) {
      return new on((e, r) => {
        let o = n.length;
        if (!o) return e(!0);
        const i = setTimeout(() => {
          t && t > 0 && e(!1);
        }, t);
        n.forEach((t) => {
          en(t).then(() => {
            --o || (clearTimeout(i), e(!0));
          }, r);
        });
      });
    },
  };
}
function un(t) {
  if (!t) return {};
  const n = t.match(
    /^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/
  );
  if (!n) return {};
  const e = n[6] || "",
    r = n[8] || "";
  return {
    host: n[4],
    path: n[5],
    protocol: n[2],
    search: e,
    hash: r,
    relative: n[5] + e + r,
  };
}
function cn(t) {
  return t.split(/[\?#]/, 1)[0];
}
function an(t) {
  const { protocol: n, host: e, path: r } = t;
  return `${n ? `${n}://` : ""}${
    (e &&
      e
        .replace(/^.*@/, "[filtered]:[filtered]@")
        .replace(/(:80)$/, "")
        .replace(/(:443)$/, "")) ||
    ""
  }${r}`;
}
const ln = { ip: !1, request: !0, transaction: !0, user: !0 },
  fn = ["cookies", "data", "headers", "method", "query_string", "url"],
  dn = ["id", "username", "email"];
function hn(t, n = {}) {
  const e = t.method && t.method.toUpperCase();
  let r = "",
    o = "url";
  n.customRoute || t.route
    ? ((r = n.customRoute || `${t.baseUrl || ""}${t.route && t.route.path}`),
      (o = "route"))
    : (t.originalUrl || t.url) && (r = cn(t.originalUrl || t.url || ""));
  let i = "";
  return (
    n.method && e && (i += e),
    n.method && n.path && (i += " "),
    n.path && r && (i += r),
    [i, o]
  );
}
function pn(t, n) {
  const { include: e = fn } = n || {},
    r = {},
    o = t.headers || {},
    i = t.method,
    s = o.host || t.hostname || t.host || "<no host>",
    u =
      "https" === t.protocol || (t.socket && t.socket.encrypted)
        ? "https"
        : "http",
    c = t.originalUrl || t.url || "",
    a = c.startsWith(u) ? c : `${u}://${s}${c}`;
  return (
    e.forEach((n) => {
      switch (n) {
        case "headers":
          (r.headers = o), e.includes("cookies") || delete r.headers.cookie;
          break;
        case "method":
          r.method = i;
          break;
        case "url":
          r.url = a;
          break;
        case "cookies":
          r.cookies =
            t.cookies ||
            (o.cookie &&
              (function (t) {
                const n = {};
                let e = 0;
                for (; e < t.length; ) {
                  const r = t.indexOf("=", e);
                  if (-1 === r) break;
                  let o = t.indexOf(";", e);
                  if (-1 === o) o = t.length;
                  else if (o < r) {
                    e = t.lastIndexOf(";", r - 1) + 1;
                    continue;
                  }
                  const i = t.slice(e, r).trim();
                  if (void 0 === n[i]) {
                    let e = t.slice(r + 1, o).trim();
                    34 === e.charCodeAt(0) && (e = e.slice(1, -1));
                    try {
                      n[i] = -1 !== e.indexOf("%") ? decodeURIComponent(e) : e;
                    } catch (t) {
                      n[i] = e;
                    }
                  }
                  e = o + 1;
                }
                return n;
              })(o.cookie)) ||
            {};
          break;
        case "query_string":
          r.query_string = (function (t) {
            let n = t.originalUrl || t.url || "";
            if (!n) return;
            n.startsWith("/") && (n = `http://dogs.are.great${n}`);
            try {
              const e = t.query || new URL(n).search.slice(1);
              return e.length ? e : void 0;
            } catch (t) {
              return;
            }
          })(t);
          break;
        case "data":
          if ("GET" === i || "HEAD" === i) break;
          void 0 !== t.body &&
            (r.data = G(t.body) ? t.body : JSON.stringify(Ft(t.body)));
          break;
        default:
          ({}).hasOwnProperty.call(t, n) && (r[n] = t[n]);
      }
    }),
    r
  );
}
function Sn(t, n, e) {
  const r = { ...ln, ...(e && e.include) };
  if (r.request) {
    const e = Array.isArray(r.request) ? pn(n, { include: r.request }) : pn(n);
    t.request = { ...t.request, ...e };
  }
  if (r.user) {
    const e =
      n.user && U(n.user)
        ? (function (t, n) {
            const e = {};
            return (
              (Array.isArray(n) ? n : dn).forEach((n) => {
                t && n in t && (e[n] = t[n]);
              }),
              e
            );
          })(n.user, r.user)
        : {};
    Object.keys(e).length && (t.user = { ...t.user, ...e });
  }
  if (r.ip) {
    const e = n.ip || (n.socket && n.socket.remoteAddress);
    e && (t.user = { ...t.user, ip_address: e });
  }
  return (
    r.transaction &&
      !t.transaction &&
      "transaction" === t.type &&
      (t.transaction = (function (t, n) {
        switch (n) {
          case "path":
            return hn(t, { path: !0 })[0];
          case "handler":
            return (
              (t.route &&
                t.route.stack &&
                t.route.stack[0] &&
                t.route.stack[0].name) ||
              "<anonymous>"
            );
          default:
            return hn(t, {
              path: !0,
              method: !0,
              customRoute: t.R ? t.R : void 0,
            })[0];
        }
      })(n, r.transaction)),
    t
  );
}
const En = ["fatal", "error", "warning", "log", "info", "debug"];
function mn(t) {
  return "warn" === t ? "warning" : En.includes(t) ? t : "log";
}
function Tn(t, n = !1) {
  return (
    !(
      n ||
      (t &&
        !t.startsWith("/") &&
        !t.match(/^[A-Z]:/) &&
        !t.startsWith(".") &&
        !t.match(/^[a-zA-Z]([a-zA-Z0-9.\-+])*:\/\//))
    ) &&
    void 0 !== t &&
    !t.includes("node_modules/")
  );
}
function _n(t) {
  const n = /^\s*[-]{4,}$/,
    e = /at (?:async )?(?:(.+?)\s+\()?(?:(.+):(\d+):(\d+)?|([^)]+))\)?/;
  return (r) => {
    const o = r.match(e);
    if (o) {
      let n, e, r, i, s;
      if (o[1]) {
        r = o[1];
        let t = r.lastIndexOf(".");
        if (("." === r[t - 1] && t--, t > 0)) {
          (n = r.slice(0, t)), (e = r.slice(t + 1));
          const o = n.indexOf(".Module");
          o > 0 && ((r = r.slice(o + 1)), (n = n.slice(0, o)));
        }
        i = void 0;
      }
      e && ((i = n), (s = e)),
        "<anonymous>" === e && ((s = void 0), (r = void 0)),
        void 0 === r && ((s = s || _t), (r = i ? `${i}.${s}` : s));
      let u = o[2] && o[2].startsWith("file://") ? o[2].slice(7) : o[2];
      const c = "native" === o[5];
      return (
        u && u.match(/\/[A-Z]:/) && (u = u.slice(1)),
        u || !o[5] || c || (u = o[5]),
        {
          filename: u,
          module: t ? t(u) : void 0,
          function: r,
          lineno: parseInt(o[3], 10) || void 0,
          colno: parseInt(o[4], 10) || void 0,
          in_app: Tn(u, c),
        }
      );
    }
    if (r.match(n)) return { filename: r };
  };
}
const bn = "sentry-",
  vn = /^sentry-/,
  yn = 8192;
function Rn(t) {
  const n = On(t);
  if (!n) return;
  const e = Object.entries(n).reduce((t, [n, e]) => {
    if (n.match(vn)) {
      t[n.slice(bn.length)] = e;
    }
    return t;
  }, {});
  return Object.keys(e).length > 0 ? e : void 0;
}
function An(t) {
  if (!t) return;
  return (function (t) {
    if (0 === Object.keys(t).length) return;
    return Object.entries(t).reduce((t, [n, e], r) => {
      const o = `${encodeURIComponent(n)}=${encodeURIComponent(e)}`,
        i = 0 === r ? o : `${t},${o}`;
      return i.length > yn ? t : i;
    }, "");
  })(
    Object.entries(t).reduce((t, [n, e]) => (e && (t[`${bn}${n}`] = e), t), {})
  );
}
function On(t) {
  if (t && (G(t) || Array.isArray(t)))
    return Array.isArray(t)
      ? t.reduce((t, n) => {
          const e = gn(n);
          for (const n of Object.keys(e)) t[n] = e[n];
          return t;
        }, {})
      : gn(t);
}
function gn(t) {
  return t
    .split(",")
    .map((t) => t.split("=").map((t) => decodeURIComponent(t.trim())))
    .reduce((t, [n, e]) => ((t[n] = e), t), {});
}
const Nn = new RegExp(
  "^[ \\t]*([0-9a-f]{32})?-?([0-9a-f]{16})?-?([01])?[ \\t]*$"
);
function Cn(t, n) {
  const e = (function (t) {
      if (!t) return;
      const n = t.match(Nn);
      if (!n) return;
      let e;
      return (
        "1" === n[3] ? (e = !0) : "0" === n[3] && (e = !1),
        { traceId: n[1], parentSampled: e, parentSpanId: n[2] }
      );
    })(t),
    r = Rn(n),
    { traceId: o, parentSpanId: i, parentSampled: s } = e || {};
  return e
    ? {
        traceId: o || Dt(),
        parentSpanId: i || Dt().substring(16),
        spanId: Dt().substring(16),
        sampled: s,
        dsc: r || {},
      }
    : { traceId: o || Dt(), spanId: Dt().substring(16) };
}
function Ln(t = Dt(), n = Dt().substring(16), e) {
  let r = "";
  return void 0 !== e && (r = e ? "-1" : "-0"), `${t}-${n}${r}`;
}
function In(t, n = []) {
  return [t, n];
}
function Mn(t, n) {
  const [e, r] = t;
  return [e, [...r, n]];
}
function wn(t, n) {
  const e = t[1];
  for (const t of e) {
    if (n(t, t[0].type)) return !0;
  }
  return !1;
}
function Zn(t) {
  return Q.__SENTRY__ && Q.__SENTRY__.encodePolyfill
    ? Q.__SENTRY__.encodePolyfill(t)
    : new TextEncoder().encode(t);
}
function Pn(t) {
  const [n, e] = t;
  let r = JSON.stringify(n);
  function o(t) {
    "string" == typeof r
      ? (r = "string" == typeof t ? r + t : [Zn(r), t])
      : r.push("string" == typeof t ? Zn(t) : t);
  }
  for (const t of e) {
    const [n, e] = t;
    if (
      (o(`\n${JSON.stringify(n)}\n`),
      "string" == typeof e || e instanceof Uint8Array)
    )
      o(e);
    else {
      let t;
      try {
        t = JSON.stringify(e);
      } catch (n) {
        t = JSON.stringify(Ft(e));
      }
      o(t);
    }
  }
  return "string" == typeof r
    ? r
    : (function (t) {
        const n = t.reduce((t, n) => t + n.length, 0),
          e = new Uint8Array(n);
        let r = 0;
        for (const n of t) e.set(n, r), (r += n.length);
        return e;
      })(r);
}
function Vn(t) {
  return [{ type: "span" }, t];
}
function Gn(t) {
  const n = "string" == typeof t.data ? Zn(t.data) : t.data;
  return [
    Et({
      type: "attachment",
      length: n.length,
      filename: t.filename,
      content_type: t.contentType,
      attachment_type: t.attachmentType,
    }),
    n,
  ];
}
const Xn = {
  session: "session",
  sessions: "session",
  attachment: "attachment",
  transaction: "transaction",
  event: "error",
  client_report: "internal",
  user_report: "default",
  profile: "profile",
  replay_event: "replay",
  replay_recording: "replay",
  check_in: "monitor",
  feedback: "feedback",
  span: "span",
  statsd: "metric_bucket",
};
function Un(t) {
  return Xn[t];
}
function Wn(t) {
  if (!t || !t.sdk) return;
  const { name: n, version: e } = t.sdk;
  return { name: n, version: e };
}
const Yn = 6e4;
function Hn(t, { statusCode: n, headers: e }, r = Date.now()) {
  const o = { ...t },
    i = e && e["x-sentry-rate-limits"],
    s = e && e["retry-after"];
  if (i)
    for (const t of i.trim().split(",")) {
      const [n, e, , , i] = t.split(":", 5),
        s = parseInt(n, 10),
        u = 1e3 * (isNaN(s) ? 60 : s);
      if (e)
        for (const t of e.split(";"))
          ("metric_bucket" === t && i && !i.split(";").includes("custom")) ||
            (o[t] = r + u);
      else o.all = r + u;
    }
  else
    s
      ? (o.all =
          r +
          (function (t, n = Date.now()) {
            const e = parseInt(`${t}`, 10);
            if (!isNaN(e)) return 1e3 * e;
            const r = Date.parse(`${t}`);
            return isNaN(r) ? Yn : r - n;
          })(s, r))
      : 429 === n && (o.all = r + 6e4);
  return o;
}
function Dn(t, n) {
  return t(n.stack || "", 1);
}
function jn(t, n) {
  const e = { type: n.name || n.constructor.name, value: n.message },
    r = Dn(t, n);
  return r.length && (e.stacktrace = { frames: r }), e;
}
function xn(t) {
  if ("name" in t && "string" == typeof t.name) {
    let n = `'${t.name}' captured as exception`;
    return (
      "message" in t &&
        "string" == typeof t.message &&
        (n += ` with message '${t.message}'`),
      n
    );
  }
  if ("message" in t && "string" == typeof t.message) return t.message;
  const n = (function (t, n = 40) {
    const e = Object.keys(ht(t));
    if ((e.sort(), !e.length)) return "[object has no keys]";
    if (e[0].length >= n) return D(e[0], n);
    for (let t = e.length; t > 0; t--) {
      const r = e.slice(0, t).join(", ");
      if (!(r.length > n)) return t === e.length ? r : D(r, n);
    }
    return "";
  })(t);
  if (V(t, "ErrorEvent"))
    return `Event \`ErrorEvent\` captured as exception with message \`${t.message}\``;
  const e = (function (t) {
    try {
      const n = Object.getPrototypeOf(t);
      return n ? n.constructor.name : void 0;
    } catch (t) {}
  })(t);
  return `${
    e && "Object" !== e ? `'${e}'` : "Object"
  } captured as exception with keys: ${n}`;
}
function kn(t, n, e, r) {
  if (P(e)) return [e, void 0];
  if (((n.synthetic = !0), U(e))) {
    const n = { __serialized__: Jt(e, t && t.getOptions().normalizeDepth) },
      o = (function (t) {
        for (const n in t)
          if (Object.prototype.hasOwnProperty.call(t, n)) {
            const e = t[n];
            if (e instanceof Error) return e;
          }
      })(e);
    if (o) return [o, n];
    const i = xn(e),
      s = (r && r.syntheticException) || new Error(i);
    return (s.message = i), [s, n];
  }
  const o = (r && r.syntheticException) || new Error(e);
  return (o.message = `${e}`), [o, void 0];
}
class Kn {
  constructor(t) {
    (this.A = t), (this.N = new Map());
  }
  get size() {
    return this.N.size;
  }
  get(t) {
    const n = this.N.get(t);
    if (void 0 !== n) return this.N.delete(t), this.N.set(t, n), n;
  }
  set(t, n) {
    this.N.size >= this.A && this.N.delete(this.N.keys().next().value),
      this.N.set(t, n);
  }
  remove(t) {
    const n = this.N.get(t);
    return n && this.N.delete(t), n;
  }
  clear() {
    this.N.clear();
  }
  keys() {
    return Array.from(this.N.keys());
  }
  values() {
    const t = [];
    return this.N.forEach((n) => t.push(n)), t;
  }
}
function Bn(t, n) {
  return null != t ? t : n();
}
function Fn(t) {
  let n,
    e = t[0],
    r = 1;
  for (; r < t.length; ) {
    const o = t[r],
      i = t[r + 1];
    if (
      ((r += 2), ("optionalAccess" === o || "optionalCall" === o) && null == e)
    )
      return;
    "access" === o || "optionalAccess" === o
      ? ((n = e), (e = i(e)))
      : ("call" !== o && "optionalCall" !== o) ||
        ((e = i((...t) => e.call(n, ...t))), (n = void 0));
  }
  return e;
}
function Jn(t) {
  const n = Fn(t);
  return null == n || n;
}
var zn = "object" == typeof globalThis ? globalThis : global,
  Qn = "1.8.0",
  $n = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
var qn = (function (t) {
    var n = new Set([t]),
      e = new Set(),
      r = t.match($n);
    if (!r)
      return function () {
        return !1;
      };
    var o = +r[1],
      i = +r[2],
      s = +r[3];
    if (null != r[4])
      return function (n) {
        return n === t;
      };
    function u(t) {
      return e.add(t), !1;
    }
    function c(t) {
      return n.add(t), !0;
    }
    return function (t) {
      if (n.has(t)) return !0;
      if (e.has(t)) return !1;
      var r = t.match($n);
      if (!r) return u(t);
      var a = +r[1],
        l = +r[2],
        f = +r[3];
      return null != r[4] || o !== a
        ? u(t)
        : 0 === o
          ? i === l && s <= f
            ? c(t)
            : u(t)
          : i <= l
            ? c(t)
            : u(t);
    };
  })(Qn),
  te = Qn.split(".")[0],
  ne = Symbol.for("opentelemetry.js.api." + te),
  ee = zn;
function re(t, n, e, r) {
  var o;
  void 0 === r && (r = !1);
  var i = (ee[ne] =
    null !== (o = ee[ne]) && void 0 !== o ? o : { version: Qn });
  if (!r && i[t]) {
    var s = new Error(
      "@opentelemetry/api: Attempted duplicate registration of API: " + t
    );
    return e.error(s.stack || s.message), !1;
  }
  if (i.version !== Qn) {
    s = new Error(
      "@opentelemetry/api: Registration of version v" +
        i.version +
        " for " +
        t +
        " does not match previously registered API v" +
        Qn
    );
    return e.error(s.stack || s.message), !1;
  }
  return (
    (i[t] = n),
    e.debug(
      "@opentelemetry/api: Registered a global for " + t + " v" + Qn + "."
    ),
    !0
  );
}
function oe(t) {
  var n,
    e,
    r = null === (n = ee[ne]) || void 0 === n ? void 0 : n.version;
  if (r && qn(r)) return null === (e = ee[ne]) || void 0 === e ? void 0 : e[t];
}
function ie(t, n) {
  n.debug(
    "@opentelemetry/api: Unregistering a global for " + t + " v" + Qn + "."
  );
  var e = ee[ne];
  e && delete e[t];
}
var se,
  ue = function (t, n) {
    var e = "function" == typeof Symbol && t[Symbol.iterator];
    if (!e) return t;
    var r,
      o,
      i = e.call(t),
      s = [];
    try {
      for (; (void 0 === n || n-- > 0) && !(r = i.next()).done; )
        s.push(r.value);
    } catch (t) {
      o = { error: t };
    } finally {
      try {
        r && !r.done && (e = i.return) && e.call(i);
      } finally {
        if (o) throw o.error;
      }
    }
    return s;
  },
  ce = function (t, n, e) {
    if (e || 2 === arguments.length)
      for (var r, o = 0, i = n.length; o < i; o++)
        (!r && o in n) ||
          (r || (r = Array.prototype.slice.call(n, 0, o)), (r[o] = n[o]));
    return t.concat(r || Array.prototype.slice.call(n));
  },
  ae = (function () {
    function t(t) {
      this.C = t.namespace || "DiagComponentLogger";
    }
    return (
      (t.prototype.debug = function () {
        for (var t = [], n = 0; n < arguments.length; n++) t[n] = arguments[n];
        return le("debug", this.C, t);
      }),
      (t.prototype.error = function () {
        for (var t = [], n = 0; n < arguments.length; n++) t[n] = arguments[n];
        return le("error", this.C, t);
      }),
      (t.prototype.info = function () {
        for (var t = [], n = 0; n < arguments.length; n++) t[n] = arguments[n];
        return le("info", this.C, t);
      }),
      (t.prototype.warn = function () {
        for (var t = [], n = 0; n < arguments.length; n++) t[n] = arguments[n];
        return le("warn", this.C, t);
      }),
      (t.prototype.verbose = function () {
        for (var t = [], n = 0; n < arguments.length; n++) t[n] = arguments[n];
        return le("verbose", this.C, t);
      }),
      t
    );
  })();
function le(t, n, e) {
  var r = oe("diag");
  if (r) return e.unshift(n), r[t].apply(r, ce([], ue(e), !1));
}
!(function (t) {
  (t[(t.NONE = 0)] = "NONE"),
    (t[(t.ERROR = 30)] = "ERROR"),
    (t[(t.WARN = 50)] = "WARN"),
    (t[(t.INFO = 60)] = "INFO"),
    (t[(t.DEBUG = 70)] = "DEBUG"),
    (t[(t.VERBOSE = 80)] = "VERBOSE"),
    (t[(t.ALL = 9999)] = "ALL");
})(se || (se = {}));
var fe = function (t, n) {
    var e = "function" == typeof Symbol && t[Symbol.iterator];
    if (!e) return t;
    var r,
      o,
      i = e.call(t),
      s = [];
    try {
      for (; (void 0 === n || n-- > 0) && !(r = i.next()).done; )
        s.push(r.value);
    } catch (t) {
      o = { error: t };
    } finally {
      try {
        r && !r.done && (e = i.return) && e.call(i);
      } finally {
        if (o) throw o.error;
      }
    }
    return s;
  },
  de = function (t, n, e) {
    if (e || 2 === arguments.length)
      for (var r, o = 0, i = n.length; o < i; o++)
        (!r && o in n) ||
          (r || (r = Array.prototype.slice.call(n, 0, o)), (r[o] = n[o]));
    return t.concat(r || Array.prototype.slice.call(n));
  },
  he = (function () {
    function t() {
      function t(t) {
        return function () {
          for (var n = [], e = 0; e < arguments.length; e++)
            n[e] = arguments[e];
          var r = oe("diag");
          if (r) return r[t].apply(r, de([], fe(n), !1));
        };
      }
      var n = this;
      (n.setLogger = function (t, e) {
        var r, o, i;
        if ((void 0 === e && (e = { logLevel: se.INFO }), t === n)) {
          var s = new Error(
            "Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation"
          );
          return (
            n.error(null !== (r = s.stack) && void 0 !== r ? r : s.message), !1
          );
        }
        "number" == typeof e && (e = { logLevel: e });
        var u = oe("diag"),
          c = (function (t, n) {
            function e(e, r) {
              var o = n[e];
              return "function" == typeof o && t >= r
                ? o.bind(n)
                : function () {};
            }
            return (
              t < se.NONE ? (t = se.NONE) : t > se.ALL && (t = se.ALL),
              (n = n || {}),
              {
                error: e("error", se.ERROR),
                warn: e("warn", se.WARN),
                info: e("info", se.INFO),
                debug: e("debug", se.DEBUG),
                verbose: e("verbose", se.VERBOSE),
              }
            );
          })(null !== (o = e.logLevel) && void 0 !== o ? o : se.INFO, t);
        if (u && !e.suppressOverrideMessage) {
          var a =
            null !== (i = new Error().stack) && void 0 !== i
              ? i
              : "<failed to generate stacktrace>";
          u.warn("Current logger will be overwritten from " + a),
            c.warn(
              "Current logger will overwrite one already registered from " + a
            );
        }
        return re("diag", c, n, !0);
      }),
        (n.disable = function () {
          ie("diag", n);
        }),
        (n.createComponentLogger = function (t) {
          return new ae(t);
        }),
        (n.verbose = t("verbose")),
        (n.debug = t("debug")),
        (n.info = t("info")),
        (n.warn = t("warn")),
        (n.error = t("error"));
    }
    return (
      (t.instance = function () {
        return this.L || (this.L = new t()), this.L;
      }),
      t
    );
  })(),
  pe = function (t, n) {
    var e = "function" == typeof Symbol && t[Symbol.iterator];
    if (!e) return t;
    var r,
      o,
      i = e.call(t),
      s = [];
    try {
      for (; (void 0 === n || n-- > 0) && !(r = i.next()).done; )
        s.push(r.value);
    } catch (t) {
      o = { error: t };
    } finally {
      try {
        r && !r.done && (e = i.return) && e.call(i);
      } finally {
        if (o) throw o.error;
      }
    }
    return s;
  },
  Se = function (t) {
    var n = "function" == typeof Symbol && Symbol.iterator,
      e = n && t[n],
      r = 0;
    if (e) return e.call(t);
    if (t && "number" == typeof t.length)
      return {
        next: function () {
          return (
            t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t }
          );
        },
      };
    throw new TypeError(
      n ? "Object is not iterable." : "Symbol.iterator is not defined."
    );
  },
  Ee = (function () {
    function t(t) {
      this.I = t ? new Map(t) : new Map();
    }
    return (
      (t.prototype.getEntry = function (t) {
        var n = this.I.get(t);
        if (n) return Object.assign({}, n);
      }),
      (t.prototype.getAllEntries = function () {
        return Array.from(this.I.entries()).map(function (t) {
          var n = pe(t, 2);
          return [n[0], n[1]];
        });
      }),
      (t.prototype.setEntry = function (n, e) {
        var r = new t(this.I);
        return r.I.set(n, e), r;
      }),
      (t.prototype.removeEntry = function (n) {
        var e = new t(this.I);
        return e.I.delete(n), e;
      }),
      (t.prototype.removeEntries = function () {
        for (var n, e, r = [], o = 0; o < arguments.length; o++)
          r[o] = arguments[o];
        var i = new t(this.I);
        try {
          for (var s = Se(r), u = s.next(); !u.done; u = s.next()) {
            var c = u.value;
            i.I.delete(c);
          }
        } catch (t) {
          n = { error: t };
        } finally {
          try {
            u && !u.done && (e = s.return) && e.call(s);
          } finally {
            if (n) throw n.error;
          }
        }
        return i;
      }),
      (t.prototype.clear = function () {
        return new t();
      }),
      t
    );
  })(),
  me = Symbol("BaggageEntryMetadata"),
  Te = he.instance();
function _e(t) {
  return void 0 === t && (t = {}), new Ee(new Map(Object.entries(t)));
}
function be(t) {
  return (
    "string" != typeof t &&
      (Te.error(
        "Cannot create baggage metadata from unknown type: " + typeof t
      ),
      (t = "")),
    {
      __TYPE__: me,
      toString: function () {
        return t;
      },
    }
  );
}
function ve(t) {
  return Symbol.for(t);
}
var ye,
  Re,
  Ae = function t(n) {
    var e = this;
    (e.M = n ? new Map(n) : new Map()),
      (e.getValue = function (t) {
        return e.M.get(t);
      }),
      (e.setValue = function (n, r) {
        var o = new t(e.M);
        return o.M.set(n, r), o;
      }),
      (e.deleteValue = function (n) {
        var r = new t(e.M);
        return r.M.delete(n), r;
      });
  },
  Oe = new Ae(),
  ge = [
    { n: "error", c: "error" },
    { n: "warn", c: "warn" },
    { n: "info", c: "info" },
    { n: "debug", c: "debug" },
    { n: "verbose", c: "trace" },
  ],
  Ne = function () {
    function t(t) {
      return function () {
        for (var n = [], e = 0; e < arguments.length; e++) n[e] = arguments[e];
        if (console) {
          var r = console[t];
          if (
            ("function" != typeof r && (r = console.log),
            "function" == typeof r)
          )
            return r.apply(console, n);
        }
      };
    }
    for (var n = 0; n < ge.length; n++) this[ge[n].n] = t(ge[n].c);
  },
  Ce =
    ((ye = function (t, n) {
      return (
        (ye =
          Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array &&
            function (t, n) {
              t.__proto__ = n;
            }) ||
          function (t, n) {
            for (var e in n)
              Object.prototype.hasOwnProperty.call(n, e) && (t[e] = n[e]);
          }),
        ye(t, n)
      );
    }),
    function (t, n) {
      if ("function" != typeof n && null !== n)
        throw new TypeError(
          "Class extends value " + String(n) + " is not a constructor or null"
        );
      function e() {
        this.constructor = t;
      }
      ye(t, n),
        (t.prototype =
          null === n
            ? Object.create(n)
            : ((e.prototype = n.prototype), new e()));
    }),
  Le = (function () {
    function t() {}
    return (
      (t.prototype.createHistogram = function (t, n) {
        return Ye;
      }),
      (t.prototype.createCounter = function (t, n) {
        return We;
      }),
      (t.prototype.createUpDownCounter = function (t, n) {
        return He;
      }),
      (t.prototype.createObservableGauge = function (t, n) {
        return je;
      }),
      (t.prototype.createObservableCounter = function (t, n) {
        return De;
      }),
      (t.prototype.createObservableUpDownCounter = function (t, n) {
        return xe;
      }),
      (t.prototype.addBatchObservableCallback = function (t, n) {}),
      (t.prototype.removeBatchObservableCallback = function (t) {}),
      t
    );
  })(),
  Ie = function () {},
  Me = (function (t) {
    function n() {
      return (null !== t && t.apply(this, arguments)) || this;
    }
    return Ce(n, t), (n.prototype.add = function (t, n) {}), n;
  })(Ie),
  we = (function (t) {
    function n() {
      return (null !== t && t.apply(this, arguments)) || this;
    }
    return Ce(n, t), (n.prototype.add = function (t, n) {}), n;
  })(Ie),
  Ze = (function (t) {
    function n() {
      return (null !== t && t.apply(this, arguments)) || this;
    }
    return Ce(n, t), (n.prototype.record = function (t, n) {}), n;
  })(Ie),
  Pe = (function () {
    function t() {}
    return (
      (t.prototype.addCallback = function (t) {}),
      (t.prototype.removeCallback = function (t) {}),
      t
    );
  })(),
  Ve = (function (t) {
    function n() {
      return (null !== t && t.apply(this, arguments)) || this;
    }
    return Ce(n, t), n;
  })(Pe),
  Ge = (function (t) {
    function n() {
      return (null !== t && t.apply(this, arguments)) || this;
    }
    return Ce(n, t), n;
  })(Pe),
  Xe = (function (t) {
    function n() {
      return (null !== t && t.apply(this, arguments)) || this;
    }
    return Ce(n, t), n;
  })(Pe),
  Ue = new Le(),
  We = new Me(),
  Ye = new Ze(),
  He = new we(),
  De = new Ve(),
  je = new Ge(),
  xe = new Xe();
!(function (t) {
  (t[(t.INT = 0)] = "INT"), (t[(t.DOUBLE = 1)] = "DOUBLE");
})(Re || (Re = {}));
var ke,
  Ke = {
    get: function (t, n) {
      if (null != t) return t[n];
    },
    keys: function (t) {
      return null == t ? [] : Object.keys(t);
    },
  },
  Be = {
    set: function (t, n, e) {
      null != t && (t[n] = e);
    },
  },
  Fe = function (t, n) {
    var e = "function" == typeof Symbol && t[Symbol.iterator];
    if (!e) return t;
    var r,
      o,
      i = e.call(t),
      s = [];
    try {
      for (; (void 0 === n || n-- > 0) && !(r = i.next()).done; )
        s.push(r.value);
    } catch (t) {
      o = { error: t };
    } finally {
      try {
        r && !r.done && (e = i.return) && e.call(i);
      } finally {
        if (o) throw o.error;
      }
    }
    return s;
  },
  Je = function (t, n, e) {
    if (e || 2 === arguments.length)
      for (var r, o = 0, i = n.length; o < i; o++)
        (!r && o in n) ||
          (r || (r = Array.prototype.slice.call(n, 0, o)), (r[o] = n[o]));
    return t.concat(r || Array.prototype.slice.call(n));
  },
  ze = (function () {
    function t() {}
    return (
      (t.prototype.active = function () {
        return Oe;
      }),
      (t.prototype.with = function (t, n, e) {
        for (var r = [], o = 3; o < arguments.length; o++)
          r[o - 3] = arguments[o];
        return n.call.apply(n, Je([e], Fe(r), !1));
      }),
      (t.prototype.bind = function (t, n) {
        return n;
      }),
      (t.prototype.enable = function () {
        return this;
      }),
      (t.prototype.disable = function () {
        return this;
      }),
      t
    );
  })(),
  Qe = function (t, n) {
    var e = "function" == typeof Symbol && t[Symbol.iterator];
    if (!e) return t;
    var r,
      o,
      i = e.call(t),
      s = [];
    try {
      for (; (void 0 === n || n-- > 0) && !(r = i.next()).done; )
        s.push(r.value);
    } catch (t) {
      o = { error: t };
    } finally {
      try {
        r && !r.done && (e = i.return) && e.call(i);
      } finally {
        if (o) throw o.error;
      }
    }
    return s;
  },
  $e = function (t, n, e) {
    if (e || 2 === arguments.length)
      for (var r, o = 0, i = n.length; o < i; o++)
        (!r && o in n) ||
          (r || (r = Array.prototype.slice.call(n, 0, o)), (r[o] = n[o]));
    return t.concat(r || Array.prototype.slice.call(n));
  },
  qe = "context",
  tr = new ze(),
  nr = (function () {
    function t() {}
    return (
      (t.getInstance = function () {
        return this.L || (this.L = new t()), this.L;
      }),
      (t.prototype.setGlobalContextManager = function (t) {
        return re(qe, t, he.instance());
      }),
      (t.prototype.active = function () {
        return this.Z().active();
      }),
      (t.prototype.with = function (t, n, e) {
        for (var r, o = [], i = 3; i < arguments.length; i++)
          o[i - 3] = arguments[i];
        return (r = this.Z()).with.apply(r, $e([t, n, e], Qe(o), !1));
      }),
      (t.prototype.bind = function (t, n) {
        return this.Z().bind(t, n);
      }),
      (t.prototype.Z = function () {
        return oe(qe) || tr;
      }),
      (t.prototype.disable = function () {
        this.Z().disable(), ie(qe, he.instance());
      }),
      t
    );
  })();
!(function (t) {
  (t[(t.NONE = 0)] = "NONE"), (t[(t.SAMPLED = 1)] = "SAMPLED");
})(ke || (ke = {}));
var er = "0000000000000000",
  rr = "00000000000000000000000000000000",
  or = { traceId: rr, spanId: er, traceFlags: ke.NONE },
  ir = (function () {
    function t(t) {
      void 0 === t && (t = or), (this.P = t);
    }
    return (
      (t.prototype.spanContext = function () {
        return this.P;
      }),
      (t.prototype.setAttribute = function (t, n) {
        return this;
      }),
      (t.prototype.setAttributes = function (t) {
        return this;
      }),
      (t.prototype.addEvent = function (t, n) {
        return this;
      }),
      (t.prototype.setStatus = function (t) {
        return this;
      }),
      (t.prototype.updateName = function (t) {
        return this;
      }),
      (t.prototype.end = function (t) {}),
      (t.prototype.isRecording = function () {
        return !1;
      }),
      (t.prototype.recordException = function (t, n) {}),
      t
    );
  })(),
  sr = ve("OpenTelemetry Context Key SPAN");
function ur(t) {
  return t.getValue(sr) || void 0;
}
function cr() {
  return ur(nr.getInstance().active());
}
function ar(t, n) {
  return t.setValue(sr, n);
}
function lr(t) {
  return t.deleteValue(sr);
}
function fr(t, n) {
  return ar(t, new ir(n));
}
function dr(t) {
  var n;
  return null === (n = ur(t)) || void 0 === n ? void 0 : n.spanContext();
}
var hr = /^([0-9a-f]{32})$/i,
  pr = /^[0-9a-f]{16}$/i;
function Sr(t) {
  return hr.test(t) && t !== rr;
}
function Er(t) {
  return pr.test(t) && t !== er;
}
function mr(t) {
  return Sr(t.traceId) && Er(t.spanId);
}
function Tr(t) {
  return new ir(t);
}
var _r = nr.getInstance(),
  br = (function () {
    function t() {}
    return (
      (t.prototype.startSpan = function (t, n, e) {
        if (
          (void 0 === e && (e = _r.active()),
          Boolean(null == n ? void 0 : n.root))
        )
          return new ir();
        var r,
          o = e && dr(e);
        return "object" == typeof (r = o) &&
          "string" == typeof r.spanId &&
          "string" == typeof r.traceId &&
          "number" == typeof r.traceFlags &&
          mr(o)
          ? new ir(o)
          : new ir();
      }),
      (t.prototype.startActiveSpan = function (t, n, e, r) {
        var o, i, s;
        if (!(arguments.length < 2)) {
          2 === arguments.length
            ? (s = n)
            : 3 === arguments.length
              ? ((o = n), (s = e))
              : ((o = n), (i = e), (s = r));
          var u = null != i ? i : _r.active(),
            c = this.startSpan(t, o, u),
            a = ar(u, c);
          return _r.with(a, s, void 0, c);
        }
      }),
      t
    );
  })();
var vr,
  yr,
  Rr,
  Ar = new br(),
  Or = (function () {
    function t(t, n, e, r) {
      (this.V = t), (this.name = n), (this.version = e), (this.options = r);
    }
    return (
      (t.prototype.startSpan = function (t, n, e) {
        return this.G().startSpan(t, n, e);
      }),
      (t.prototype.startActiveSpan = function (t, n, e, r) {
        var o = this.G();
        return Reflect.apply(o.startActiveSpan, o, arguments);
      }),
      (t.prototype.G = function () {
        if (this.X) return this.X;
        var t = this.V.getDelegateTracer(this.name, this.version, this.options);
        return t ? ((this.X = t), this.X) : Ar;
      }),
      t
    );
  })(),
  gr = new ((function () {
    function t() {}
    return (
      (t.prototype.getTracer = function (t, n, e) {
        return new br();
      }),
      t
    );
  })())(),
  Nr = (function () {
    function t() {}
    return (
      (t.prototype.getTracer = function (t, n, e) {
        var r;
        return null !== (r = this.getDelegateTracer(t, n, e)) && void 0 !== r
          ? r
          : new Or(this, t, n, e);
      }),
      (t.prototype.getDelegate = function () {
        var t;
        return null !== (t = this.X) && void 0 !== t ? t : gr;
      }),
      (t.prototype.setDelegate = function (t) {
        this.X = t;
      }),
      (t.prototype.getDelegateTracer = function (t, n, e) {
        var r;
        return null === (r = this.X) || void 0 === r
          ? void 0
          : r.getTracer(t, n, e);
      }),
      t
    );
  })();
!(function (t) {
  (t[(t.NOT_RECORD = 0)] = "NOT_RECORD"),
    (t[(t.RECORD = 1)] = "RECORD"),
    (t[(t.RECORD_AND_SAMPLED = 2)] = "RECORD_AND_SAMPLED");
})(vr || (vr = {})),
  (function (t) {
    (t[(t.INTERNAL = 0)] = "INTERNAL"),
      (t[(t.SERVER = 1)] = "SERVER"),
      (t[(t.CLIENT = 2)] = "CLIENT"),
      (t[(t.PRODUCER = 3)] = "PRODUCER"),
      (t[(t.CONSUMER = 4)] = "CONSUMER");
  })(yr || (yr = {})),
  (function (t) {
    (t[(t.UNSET = 0)] = "UNSET"),
      (t[(t.OK = 1)] = "OK"),
      (t[(t.ERROR = 2)] = "ERROR");
  })(Rr || (Rr = {}));
var Cr = "[_0-9a-z-*/]",
  Lr = new RegExp(
    "^(?:" +
      ("[a-z]" + Cr + "{0,255}") +
      "|" +
      ("[a-z0-9]" + Cr + "{0,240}@[a-z]" + Cr + "{0,13}") +
      ")$"
  ),
  Ir = /^[ -~]{0,255}[!-~]$/,
  Mr = /,|=/;
var wr = (function () {
  function t(t) {
    (this.U = new Map()), t && this.W(t);
  }
  return (
    (t.prototype.set = function (t, n) {
      var e = this.Y();
      return e.U.has(t) && e.U.delete(t), e.U.set(t, n), e;
    }),
    (t.prototype.unset = function (t) {
      var n = this.Y();
      return n.U.delete(t), n;
    }),
    (t.prototype.get = function (t) {
      return this.U.get(t);
    }),
    (t.prototype.serialize = function () {
      var t = this;
      return this.H()
        .reduce(function (n, e) {
          return n.push(e + "=" + t.get(e)), n;
        }, [])
        .join(",");
    }),
    (t.prototype.W = function (t) {
      t.length > 512 ||
        ((this.U = t
          .split(",")
          .reverse()
          .reduce(function (t, n) {
            var e = n.trim(),
              r = e.indexOf("=");
            if (-1 !== r) {
              var o = e.slice(0, r),
                i = e.slice(r + 1, n.length);
              (function (t) {
                return Lr.test(t);
              })(o) &&
                (function (t) {
                  return Ir.test(t) && !Mr.test(t);
                })(i) &&
                t.set(o, i);
            }
            return t;
          }, new Map())),
        this.U.size > 32 &&
          (this.U = new Map(
            Array.from(this.U.entries()).reverse().slice(0, 32)
          )));
    }),
    (t.prototype.H = function () {
      return Array.from(this.U.keys()).reverse();
    }),
    (t.prototype.Y = function () {
      var n = new t();
      return (n.U = new Map(this.U)), n;
    }),
    t
  );
})();
var Zr = nr.getInstance(),
  Pr = he.instance(),
  Vr = new ((function () {
    function t() {}
    return (
      (t.prototype.getMeter = function (t, n, e) {
        return Ue;
      }),
      t
    );
  })())(),
  Gr = "metrics",
  Xr = (function () {
    function t() {}
    return (
      (t.getInstance = function () {
        return this.L || (this.L = new t()), this.L;
      }),
      (t.prototype.setGlobalMeterProvider = function (t) {
        return re(Gr, t, he.instance());
      }),
      (t.prototype.getMeterProvider = function () {
        return oe(Gr) || Vr;
      }),
      (t.prototype.getMeter = function (t, n, e) {
        return this.getMeterProvider().getMeter(t, n, e);
      }),
      (t.prototype.disable = function () {
        ie(Gr, he.instance());
      }),
      t
    );
  })(),
  Ur = Xr.getInstance(),
  Wr = (function () {
    function t() {}
    return (
      (t.prototype.inject = function (t, n) {}),
      (t.prototype.extract = function (t, n) {
        return t;
      }),
      (t.prototype.fields = function () {
        return [];
      }),
      t
    );
  })(),
  Yr = ve("OpenTelemetry Baggage Key");
function Hr(t) {
  return t.getValue(Yr) || void 0;
}
function Dr() {
  return Hr(nr.getInstance().active());
}
function jr(t, n) {
  return t.setValue(Yr, n);
}
function xr(t) {
  return t.deleteValue(Yr);
}
var kr = "propagation",
  Kr = new Wr(),
  Br = (function () {
    function t() {
      (this.createBaggage = _e),
        (this.getBaggage = Hr),
        (this.getActiveBaggage = Dr),
        (this.setBaggage = jr),
        (this.deleteBaggage = xr);
    }
    return (
      (t.getInstance = function () {
        return this.L || (this.L = new t()), this.L;
      }),
      (t.prototype.setGlobalPropagator = function (t) {
        return re(kr, t, he.instance());
      }),
      (t.prototype.inject = function (t, n, e) {
        return void 0 === e && (e = Be), this.D().inject(t, n, e);
      }),
      (t.prototype.extract = function (t, n, e) {
        return void 0 === e && (e = Ke), this.D().extract(t, n, e);
      }),
      (t.prototype.fields = function () {
        return this.D().fields();
      }),
      (t.prototype.disable = function () {
        ie(kr, he.instance());
      }),
      (t.prototype.D = function () {
        return oe(kr) || Kr;
      }),
      t
    );
  })(),
  Fr = Br.getInstance(),
  Jr = "trace",
  zr = (function () {
    function t() {
      (this.K = new Nr()),
        (this.wrapSpanContext = Tr),
        (this.isSpanContextValid = mr),
        (this.deleteSpan = lr),
        (this.getSpan = ur),
        (this.getActiveSpan = cr),
        (this.getSpanContext = dr),
        (this.setSpan = ar),
        (this.setSpanContext = fr);
    }
    return (
      (t.getInstance = function () {
        return this.L || (this.L = new t()), this.L;
      }),
      (t.prototype.setGlobalTracerProvider = function (t) {
        var n = re(Jr, this.K, he.instance());
        return n && this.K.setDelegate(t), n;
      }),
      (t.prototype.getTracerProvider = function () {
        return oe(Jr) || this.K;
      }),
      (t.prototype.getTracer = function (t, n) {
        return this.getTracerProvider().getTracer(t, n);
      }),
      (t.prototype.disable = function () {
        ie(Jr, he.instance()), (this.K = new Nr());
      }),
      t
    );
  })(),
  Qr = zr.getInstance(),
  $r = { context: Zr, diag: Pr, metrics: Ur, propagation: Fr, trace: Qr },
  qr = {},
  to = {},
  no = Ht(
    Object.freeze({
      __proto__: null,
      DiagConsoleLogger: Ne,
      get DiagLogLevel() {
        return se;
      },
      INVALID_SPANID: er,
      INVALID_SPAN_CONTEXT: or,
      INVALID_TRACEID: rr,
      ProxyTracer: Or,
      ProxyTracerProvider: Nr,
      ROOT_CONTEXT: Oe,
      get SamplingDecision() {
        return vr;
      },
      get SpanKind() {
        return yr;
      },
      get SpanStatusCode() {
        return Rr;
      },
      get TraceFlags() {
        return ke;
      },
      get ValueType() {
        return Re;
      },
      baggageEntryMetadataFromString: be,
      context: Zr,
      createContextKey: ve,
      createNoopMeter: function () {
        return Ue;
      },
      createTraceState: function (t) {
        return new wr(t);
      },
      default: $r,
      defaultTextMapGetter: Ke,
      defaultTextMapSetter: Be,
      diag: Pr,
      isSpanContextValid: mr,
      isValidSpanId: Er,
      isValidTraceId: Sr,
      metrics: Ur,
      propagation: Fr,
      trace: Qr,
    })
  ),
  eo = ve("OpenTelemetry SDK Context Key SUPPRESS_TRACING");
function ro(t) {
  return t.setValue(eo, !0);
}
function oo(t) {
  return !0 === t.getValue(eo);
}
var io = "=",
  so = ";",
  uo = ",",
  co = "baggage",
  ao = function (t, n) {
    var e = "function" == typeof Symbol && t[Symbol.iterator];
    if (!e) return t;
    var r,
      o,
      i = e.call(t),
      s = [];
    try {
      for (; (void 0 === n || n-- > 0) && !(r = i.next()).done; )
        s.push(r.value);
    } catch (t) {
      o = { error: t };
    } finally {
      try {
        r && !r.done && (e = i.return) && e.call(i);
      } finally {
        if (o) throw o.error;
      }
    }
    return s;
  };
function lo(t) {
  return t.reduce(function (t, n) {
    var e = "" + t + ("" !== t ? uo : "") + n;
    return e.length > 8192 ? t : e;
  }, "");
}
function fo(t) {
  return t.getAllEntries().map(function (t) {
    var n = ao(t, 2),
      e = n[0],
      r = n[1],
      o = encodeURIComponent(e) + "=" + encodeURIComponent(r.value);
    return void 0 !== r.metadata && (o += so + r.metadata.toString()), o;
  });
}
function ho(t) {
  var n = t.split(so);
  if (!(n.length <= 0)) {
    var e = n.shift();
    if (e) {
      var r = e.indexOf(io);
      if (!(r <= 0)) {
        var o,
          i = decodeURIComponent(e.substring(0, r).trim()),
          s = decodeURIComponent(e.substring(r + 1).trim());
        return (
          n.length > 0 && (o = be(n.join(so))),
          { key: i, value: s, metadata: o }
        );
      }
    }
  }
}
var po = Object.freeze({
    __proto__: null,
    getKeyPairs: fo,
    parseKeyPairsIntoRecord: function (t) {
      return "string" != typeof t || 0 === t.length
        ? {}
        : t
            .split(uo)
            .map(function (t) {
              return ho(t);
            })
            .filter(function (t) {
              return void 0 !== t && t.value.length > 0;
            })
            .reduce(function (t, n) {
              return (t[n.key] = n.value), t;
            }, {});
    },
    parsePairKeyValue: ho,
    serializeKeyPairs: lo,
  }),
  So = (function () {
    function t() {}
    return (
      (t.prototype.inject = function (t, n, e) {
        var r = Fr.getBaggage(t);
        if (r && !oo(t)) {
          var o = lo(
            fo(r)
              .filter(function (t) {
                return t.length <= 4096;
              })
              .slice(0, 180)
          );
          o.length > 0 && e.set(n, co, o);
        }
      }),
      (t.prototype.extract = function (t, n, e) {
        var r = e.get(n, co),
          o = Array.isArray(r) ? r.join(uo) : r;
        if (!o) return t;
        var i = {};
        return 0 === o.length
          ? t
          : (o.split(uo).forEach(function (t) {
              var n = ho(t);
              if (n) {
                var e = { value: n.value };
                n.metadata && (e.metadata = n.metadata), (i[n.key] = e);
              }
            }),
            0 === Object.entries(i).length
              ? t
              : Fr.setBaggage(t, Fr.createBaggage(i)));
      }),
      (t.prototype.fields = function () {
        return [co];
      }),
      t
    );
  })(),
  Eo = (function () {
    function t(t, n) {
      (this.B = n), (this.F = t.now()), (this.J = n.now());
    }
    return (
      (t.prototype.now = function () {
        var t = this.B.now() - this.J;
        return this.F + t;
      }),
      t
    );
  })(),
  mo = function (t) {
    var n = "function" == typeof Symbol && Symbol.iterator,
      e = n && t[n],
      r = 0;
    if (e) return e.call(t);
    if (t && "number" == typeof t.length)
      return {
        next: function () {
          return (
            t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t }
          );
        },
      };
    throw new TypeError(
      n ? "Object is not iterable." : "Symbol.iterator is not defined."
    );
  },
  To = function (t, n) {
    var e = "function" == typeof Symbol && t[Symbol.iterator];
    if (!e) return t;
    var r,
      o,
      i = e.call(t),
      s = [];
    try {
      for (; (void 0 === n || n-- > 0) && !(r = i.next()).done; )
        s.push(r.value);
    } catch (t) {
      o = { error: t };
    } finally {
      try {
        r && !r.done && (e = i.return) && e.call(i);
      } finally {
        if (o) throw o.error;
      }
    }
    return s;
  };
function _o(t) {
  return "string" == typeof t && t.length > 0;
}
function bo(t) {
  return (
    null == t ||
    (Array.isArray(t)
      ? (function (t) {
          var n, e, r;
          try {
            for (var o = mo(t), i = o.next(); !i.done; i = o.next()) {
              var s = i.value;
              if (null != s) {
                if (!r) {
                  if (vo(s)) {
                    r = typeof s;
                    continue;
                  }
                  return !1;
                }
                if (typeof s !== r) return !1;
              }
            }
          } catch (t) {
            n = { error: t };
          } finally {
            try {
              i && !i.done && (e = o.return) && e.call(o);
            } finally {
              if (n) throw n.error;
            }
          }
          return !0;
        })(t)
      : vo(t))
  );
}
function vo(t) {
  switch (typeof t) {
    case "number":
    case "boolean":
    case "string":
      return !0;
  }
  return !1;
}
function yo() {
  return function (t) {
    Pr.error(
      (function (t) {
        return "string" == typeof t
          ? t
          : JSON.stringify(
              (function (t) {
                var n = {},
                  e = t;
                for (; null !== e; )
                  Object.getOwnPropertyNames(e).forEach(function (t) {
                    if (!n[t]) {
                      var r = e[t];
                      r && (n[t] = String(r));
                    }
                  }),
                    (e = Object.getPrototypeOf(e));
                return n;
              })(t)
            );
      })(t)
    );
  };
}
var Ro,
  Ao = yo();
function Oo(t) {
  try {
    Ao(t);
  } catch (t) {}
}
!(function (t) {
  (t.AlwaysOff = "always_off"),
    (t.AlwaysOn = "always_on"),
    (t.ParentBasedAlwaysOff = "parentbased_always_off"),
    (t.ParentBasedAlwaysOn = "parentbased_always_on"),
    (t.ParentBasedTraceIdRatio = "parentbased_traceidratio"),
    (t.TraceIdRatio = "traceidratio");
})(Ro || (Ro = {}));
var go = ",",
  No = ["OTEL_SDK_DISABLED"];
function Co(t) {
  return No.indexOf(t) > -1;
}
var Lo = [
  "OTEL_BSP_EXPORT_TIMEOUT",
  "OTEL_BSP_MAX_EXPORT_BATCH_SIZE",
  "OTEL_BSP_MAX_QUEUE_SIZE",
  "OTEL_BSP_SCHEDULE_DELAY",
  "OTEL_BLRP_EXPORT_TIMEOUT",
  "OTEL_BLRP_MAX_EXPORT_BATCH_SIZE",
  "OTEL_BLRP_MAX_QUEUE_SIZE",
  "OTEL_BLRP_SCHEDULE_DELAY",
  "OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT",
  "OTEL_ATTRIBUTE_COUNT_LIMIT",
  "OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT",
  "OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT",
  "OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT",
  "OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT",
  "OTEL_SPAN_EVENT_COUNT_LIMIT",
  "OTEL_SPAN_LINK_COUNT_LIMIT",
  "OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT",
  "OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT",
  "OTEL_EXPORTER_OTLP_TIMEOUT",
  "OTEL_EXPORTER_OTLP_TRACES_TIMEOUT",
  "OTEL_EXPORTER_OTLP_METRICS_TIMEOUT",
  "OTEL_EXPORTER_OTLP_LOGS_TIMEOUT",
  "OTEL_EXPORTER_JAEGER_AGENT_PORT",
];
function Io(t) {
  return Lo.indexOf(t) > -1;
}
var Mo = ["OTEL_NO_PATCH_MODULES", "OTEL_PROPAGATORS"];
function wo(t) {
  return Mo.indexOf(t) > -1;
}
var Zo = 1 / 0,
  Po = 128,
  Vo = {
    OTEL_SDK_DISABLED: !1,
    CONTAINER_NAME: "",
    ECS_CONTAINER_METADATA_URI_V4: "",
    ECS_CONTAINER_METADATA_URI: "",
    HOSTNAME: "",
    KUBERNETES_SERVICE_HOST: "",
    NAMESPACE: "",
    OTEL_BSP_EXPORT_TIMEOUT: 3e4,
    OTEL_BSP_MAX_EXPORT_BATCH_SIZE: 512,
    OTEL_BSP_MAX_QUEUE_SIZE: 2048,
    OTEL_BSP_SCHEDULE_DELAY: 5e3,
    OTEL_BLRP_EXPORT_TIMEOUT: 3e4,
    OTEL_BLRP_MAX_EXPORT_BATCH_SIZE: 512,
    OTEL_BLRP_MAX_QUEUE_SIZE: 2048,
    OTEL_BLRP_SCHEDULE_DELAY: 5e3,
    OTEL_EXPORTER_JAEGER_AGENT_HOST: "",
    OTEL_EXPORTER_JAEGER_AGENT_PORT: 6832,
    OTEL_EXPORTER_JAEGER_ENDPOINT: "",
    OTEL_EXPORTER_JAEGER_PASSWORD: "",
    OTEL_EXPORTER_JAEGER_USER: "",
    OTEL_EXPORTER_OTLP_ENDPOINT: "",
    OTEL_EXPORTER_OTLP_TRACES_ENDPOINT: "",
    OTEL_EXPORTER_OTLP_METRICS_ENDPOINT: "",
    OTEL_EXPORTER_OTLP_LOGS_ENDPOINT: "",
    OTEL_EXPORTER_OTLP_HEADERS: "",
    OTEL_EXPORTER_OTLP_TRACES_HEADERS: "",
    OTEL_EXPORTER_OTLP_METRICS_HEADERS: "",
    OTEL_EXPORTER_OTLP_LOGS_HEADERS: "",
    OTEL_EXPORTER_OTLP_TIMEOUT: 1e4,
    OTEL_EXPORTER_OTLP_TRACES_TIMEOUT: 1e4,
    OTEL_EXPORTER_OTLP_METRICS_TIMEOUT: 1e4,
    OTEL_EXPORTER_OTLP_LOGS_TIMEOUT: 1e4,
    OTEL_EXPORTER_ZIPKIN_ENDPOINT: "http://localhost:9411/api/v2/spans",
    OTEL_LOG_LEVEL: se.INFO,
    OTEL_NO_PATCH_MODULES: [],
    OTEL_PROPAGATORS: ["tracecontext", "baggage"],
    OTEL_RESOURCE_ATTRIBUTES: "",
    OTEL_SERVICE_NAME: "",
    OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT: Zo,
    OTEL_ATTRIBUTE_COUNT_LIMIT: Po,
    OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT: Zo,
    OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT: Po,
    OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT: Zo,
    OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT: Po,
    OTEL_SPAN_EVENT_COUNT_LIMIT: 128,
    OTEL_SPAN_LINK_COUNT_LIMIT: 128,
    OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT: 128,
    OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT: 128,
    OTEL_TRACES_EXPORTER: "",
    OTEL_TRACES_SAMPLER: Ro.ParentBasedAlwaysOn,
    OTEL_TRACES_SAMPLER_ARG: "",
    OTEL_LOGS_EXPORTER: "",
    OTEL_EXPORTER_OTLP_INSECURE: "",
    OTEL_EXPORTER_OTLP_TRACES_INSECURE: "",
    OTEL_EXPORTER_OTLP_METRICS_INSECURE: "",
    OTEL_EXPORTER_OTLP_LOGS_INSECURE: "",
    OTEL_EXPORTER_OTLP_CERTIFICATE: "",
    OTEL_EXPORTER_OTLP_TRACES_CERTIFICATE: "",
    OTEL_EXPORTER_OTLP_METRICS_CERTIFICATE: "",
    OTEL_EXPORTER_OTLP_LOGS_CERTIFICATE: "",
    OTEL_EXPORTER_OTLP_COMPRESSION: "",
    OTEL_EXPORTER_OTLP_TRACES_COMPRESSION: "",
    OTEL_EXPORTER_OTLP_METRICS_COMPRESSION: "",
    OTEL_EXPORTER_OTLP_LOGS_COMPRESSION: "",
    OTEL_EXPORTER_OTLP_CLIENT_KEY: "",
    OTEL_EXPORTER_OTLP_TRACES_CLIENT_KEY: "",
    OTEL_EXPORTER_OTLP_METRICS_CLIENT_KEY: "",
    OTEL_EXPORTER_OTLP_LOGS_CLIENT_KEY: "",
    OTEL_EXPORTER_OTLP_CLIENT_CERTIFICATE: "",
    OTEL_EXPORTER_OTLP_TRACES_CLIENT_CERTIFICATE: "",
    OTEL_EXPORTER_OTLP_METRICS_CLIENT_CERTIFICATE: "",
    OTEL_EXPORTER_OTLP_LOGS_CLIENT_CERTIFICATE: "",
    OTEL_EXPORTER_OTLP_PROTOCOL: "http/protobuf",
    OTEL_EXPORTER_OTLP_TRACES_PROTOCOL: "http/protobuf",
    OTEL_EXPORTER_OTLP_METRICS_PROTOCOL: "http/protobuf",
    OTEL_EXPORTER_OTLP_LOGS_PROTOCOL: "http/protobuf",
    OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE: "cumulative",
  };
function Go(t, n, e) {
  if (void 0 !== e[t]) {
    var r = String(e[t]);
    n[t] = "true" === r.toLowerCase();
  }
}
function Xo(t, n, e, r, o) {
  if (
    (void 0 === r && (r = -1 / 0), void 0 === o && (o = 1 / 0), void 0 !== e[t])
  ) {
    var i = Number(e[t]);
    isNaN(i) || (n[t] = i < r ? r : i > o ? o : i);
  }
}
function Uo(t, n, e, r) {
  void 0 === r && (r = go);
  var o = e[t];
  "string" == typeof o &&
    (n[t] = o.split(r).map(function (t) {
      return t.trim();
    }));
}
var Wo = {
  ALL: se.ALL,
  VERBOSE: se.VERBOSE,
  DEBUG: se.DEBUG,
  INFO: se.INFO,
  WARN: se.WARN,
  ERROR: se.ERROR,
  NONE: se.NONE,
};
function Yo(t, n, e) {
  var r = e[t];
  if ("string" == typeof r) {
    var o = Wo[r.toUpperCase()];
    null != o && (n[t] = o);
  }
}
function Ho(t) {
  var n = {};
  for (var e in Vo) {
    var r = e;
    if ("OTEL_LOG_LEVEL" === r) Yo(r, n, t);
    else if (Co(r)) Go(r, n, t);
    else if (Io(r)) Xo(r, n, t);
    else if (wo(r)) Uo(r, n, t);
    else {
      var o = t[r];
      null != o && (n[r] = String(o));
    }
  }
  return n;
}
var Do = "object" == typeof globalThis ? globalThis : global;
function jo(t) {
  return t >= 48 && t <= 57 ? t - 48 : t >= 97 && t <= 102 ? t - 87 : t - 55;
}
function xo(t) {
  for (
    var n = new Uint8Array(t.length / 2), e = 0, r = 0;
    r < t.length;
    r += 2
  ) {
    var o = jo(t.charCodeAt(r)),
      i = jo(t.charCodeAt(r + 1));
    n[e++] = (o << 4) | i;
  }
  return n;
}
var ko = function () {
    (this.generateTraceId = Bo(16)), (this.generateSpanId = Bo(8));
  },
  Ko = Buffer.allocUnsafe(16);
function Bo(t) {
  return function () {
    for (var n = 0; n < t / 4; n++)
      Ko.writeUInt32BE((Math.random() * Math.pow(2, 32)) >>> 0, 4 * n);
    for (n = 0; n < t && !(Ko[n] > 0); n++) n === t - 1 && (Ko[t - 1] = 1);
    return Ko.toString("hex", 0, t);
  };
}
var Fo = t.performance,
  Jo = "1.24.1";
function zo(t) {
  for (var n = {}, e = t.length, r = 0; r < e; r++) {
    var o = t[r];
    o && (n[String(o).toUpperCase().replace(/[-.]/g, "_")] = o);
  }
  return n;
}
var Qo,
  $o = "aws.lambda.invoked_arn",
  qo = "db.system",
  ti = "db.connection_string",
  ni = "db.user",
  ei = "db.jdbc.driver_classname",
  ri = "db.name",
  oi = "db.statement",
  ii = "db.operation",
  si = "db.mssql.instance_name",
  ui = "db.cassandra.keyspace",
  ci = "db.cassandra.page_size",
  ai = "db.cassandra.consistency_level",
  li = "db.cassandra.table",
  fi = "db.cassandra.idempotence",
  di = "db.cassandra.speculative_execution_count",
  hi = "db.cassandra.coordinator.id",
  pi = "db.cassandra.coordinator.dc",
  Si = "db.hbase.namespace",
  Ei = "db.redis.database_index",
  mi = "db.mongodb.collection",
  Ti = "db.sql.table",
  _i = "exception.type",
  bi = "exception.message",
  vi = "exception.stacktrace",
  yi = "exception.escaped",
  Ri = "faas.trigger",
  Ai = "faas.execution",
  Oi = "faas.document.collection",
  gi = "faas.document.operation",
  Ni = "faas.document.time",
  Ci = "faas.document.name",
  Li = "faas.time",
  Ii = "faas.cron",
  Mi = "faas.coldstart",
  wi = "faas.invoked_name",
  Zi = "faas.invoked_provider",
  Pi = "faas.invoked_region",
  Vi = "net.transport",
  Gi = "net.peer.ip",
  Xi = "net.peer.port",
  Ui = "net.peer.name",
  Wi = "net.host.ip",
  Yi = "net.host.port",
  Hi = "net.host.name",
  Di = "net.host.connection.type",
  ji = "net.host.connection.subtype",
  xi = "net.host.carrier.name",
  ki = "net.host.carrier.mcc",
  Ki = "net.host.carrier.mnc",
  Bi = "net.host.carrier.icc",
  Fi = "peer.service",
  Ji = "enduser.id",
  zi = "enduser.role",
  Qi = "enduser.scope",
  $i = "thread.id",
  qi = "thread.name",
  ts = "code.function",
  ns = "code.namespace",
  es = "code.filepath",
  rs = "code.lineno",
  os = "http.method",
  is = "http.url",
  ss = "http.target",
  us = "http.host",
  cs = "http.scheme",
  as = "http.status_code",
  ls = "http.flavor",
  fs = "http.user_agent",
  ds = "http.request_content_length",
  hs = "http.request_content_length_uncompressed",
  ps = "http.response_content_length",
  Ss = "http.response_content_length_uncompressed",
  Es = "http.server_name",
  ms = "http.route",
  Ts = "http.client_ip",
  _s = "aws.dynamodb.table_names",
  bs = "aws.dynamodb.consumed_capacity",
  vs = "aws.dynamodb.item_collection_metrics",
  ys = "aws.dynamodb.provisioned_read_capacity",
  Rs = "aws.dynamodb.provisioned_write_capacity",
  As = "aws.dynamodb.consistent_read",
  Os = "aws.dynamodb.projection",
  gs = "aws.dynamodb.limit",
  Ns = "aws.dynamodb.attributes_to_get",
  Cs = "aws.dynamodb.index_name",
  Ls = "aws.dynamodb.select",
  Is = "aws.dynamodb.global_secondary_indexes",
  Ms = "aws.dynamodb.local_secondary_indexes",
  ws = "aws.dynamodb.exclusive_start_table",
  Zs = "aws.dynamodb.table_count",
  Ps = "aws.dynamodb.scan_forward",
  Vs = "aws.dynamodb.segment",
  Gs = "aws.dynamodb.total_segments",
  Xs = "aws.dynamodb.count",
  Us = "aws.dynamodb.scanned_count",
  Ws = "aws.dynamodb.attribute_definitions",
  Ys = "aws.dynamodb.global_secondary_index_updates",
  Hs = "messaging.system",
  Ds = "messaging.destination",
  js = "messaging.destination_kind",
  xs = "messaging.temp_destination",
  ks = "messaging.protocol",
  Ks = "messaging.protocol_version",
  Bs = "messaging.url",
  Fs = "messaging.message_id",
  Js = "messaging.conversation_id",
  zs = "messaging.message_payload_size_bytes",
  Qs = "messaging.message_payload_compressed_size_bytes",
  $s = "messaging.operation",
  qs = "messaging.consumer_id",
  tu = "messaging.rabbitmq.routing_key",
  nu = "messaging.kafka.message_key",
  eu = "messaging.kafka.consumer_group",
  ru = "messaging.kafka.client_id",
  ou = "messaging.kafka.partition",
  iu = "messaging.kafka.tombstone",
  su = "rpc.system",
  uu = "rpc.service",
  cu = "rpc.method",
  au = "rpc.grpc.status_code",
  lu = "rpc.jsonrpc.version",
  fu = "rpc.jsonrpc.request_id",
  du = "rpc.jsonrpc.error_code",
  hu = "rpc.jsonrpc.error_message",
  pu = "message.type",
  Su = "message.id",
  Eu = "message.compressed_size",
  mu = "message.uncompressed_size",
  Tu = $o,
  _u = qo,
  bu = ti,
  vu = ni,
  yu = ei,
  Ru = ri,
  Au = oi,
  Ou = ii,
  gu = si,
  Nu = ui,
  Cu = ci,
  Lu = ai,
  Iu = li,
  Mu = fi,
  wu = di,
  Zu = hi,
  Pu = pi,
  Vu = Si,
  Gu = Ei,
  Xu = mi,
  Uu = Ti,
  Wu = _i,
  Yu = bi,
  Hu = vi,
  Du = yi,
  ju = Ri,
  xu = Ai,
  ku = Oi,
  Ku = gi,
  Bu = Ni,
  Fu = Ci,
  Ju = Li,
  zu = Ii,
  Qu = Mi,
  $u = wi,
  qu = Zi,
  tc = Pi,
  nc = Vi,
  ec = Gi,
  rc = Xi,
  oc = Ui,
  ic = Wi,
  sc = Yi,
  uc = Hi,
  cc = Di,
  ac = ji,
  lc = xi,
  fc = ki,
  dc = Ki,
  hc = Bi,
  pc = Fi,
  Sc = Ji,
  Ec = zi,
  mc = Qi,
  Tc = $i,
  _c = qi,
  bc = ts,
  vc = ns,
  yc = es,
  Rc = rs,
  Ac = os,
  Oc = is,
  gc = ss,
  Nc = us,
  Cc = cs,
  Lc = as,
  Ic = ls,
  Mc = fs,
  wc = ds,
  Zc = hs,
  Pc = ps,
  Vc = Ss,
  Gc = Es,
  Xc = ms,
  Uc = Ts,
  Wc = _s,
  Yc = bs,
  Hc = vs,
  Dc = ys,
  jc = Rs,
  xc = As,
  kc = Os,
  Kc = gs,
  Bc = Ns,
  Fc = Cs,
  Jc = Ls,
  zc = Is,
  Qc = Ms,
  $c = ws,
  qc = Zs,
  ta = Ps,
  na = Vs,
  ea = Gs,
  ra = Xs,
  oa = Us,
  ia = Ws,
  sa = Ys,
  ua = Hs,
  ca = Ds,
  aa = js,
  la = xs,
  fa = ks,
  da = Ks,
  ha = Bs,
  pa = Fs,
  Sa = Js,
  Ea = zs,
  ma = Qs,
  Ta = $s,
  _a = qs,
  ba = tu,
  va = nu,
  ya = eu,
  Ra = ru,
  Aa = ou,
  Oa = iu,
  ga = su,
  Na = uu,
  Ca = cu,
  La = au,
  Ia = lu,
  Ma = fu,
  wa = du,
  Za = hu,
  Pa = pu,
  Va = Su,
  Ga = Eu,
  Xa = mu,
  Ua = zo([
    $o,
    qo,
    ti,
    ni,
    ei,
    ri,
    oi,
    ii,
    si,
    ui,
    ci,
    ai,
    li,
    fi,
    di,
    hi,
    pi,
    Si,
    Ei,
    mi,
    Ti,
    _i,
    bi,
    vi,
    yi,
    Ri,
    Ai,
    Oi,
    gi,
    Ni,
    Ci,
    Li,
    Ii,
    Mi,
    wi,
    Zi,
    Pi,
    Vi,
    Gi,
    Xi,
    Ui,
    Wi,
    Yi,
    Hi,
    Di,
    ji,
    xi,
    ki,
    Ki,
    Bi,
    Fi,
    Ji,
    zi,
    Qi,
    $i,
    qi,
    ts,
    ns,
    es,
    rs,
    os,
    is,
    ss,
    us,
    cs,
    as,
    ls,
    fs,
    ds,
    hs,
    ps,
    Ss,
    Es,
    ms,
    Ts,
    _s,
    bs,
    vs,
    ys,
    Rs,
    As,
    Os,
    gs,
    Ns,
    Cs,
    Ls,
    Is,
    Ms,
    ws,
    Zs,
    Ps,
    Vs,
    Gs,
    Xs,
    Us,
    Ws,
    Ys,
    Hs,
    Ds,
    js,
    xs,
    ks,
    Ks,
    Bs,
    Fs,
    Js,
    zs,
    Qs,
    $s,
    qs,
    tu,
    nu,
    eu,
    ru,
    ou,
    iu,
    su,
    uu,
    cu,
    au,
    lu,
    fu,
    du,
    hu,
    pu,
    Su,
    Eu,
    mu,
  ]),
  Wa = "other_sql",
  Ya = "mssql",
  Ha = "mysql",
  Da = "oracle",
  ja = "postgresql",
  xa = "redshift",
  ka = "hive",
  Ka = "cloudscape",
  Ba = "hsqldb",
  Fa = "progress",
  Ja = "maxdb",
  za = "hanadb",
  Qa = "ingres",
  $a = "firstsql",
  qa = "cache",
  tl = "adabas",
  nl = "firebird",
  el = "derby",
  rl = "filemaker",
  ol = "informix",
  il = "instantdb",
  sl = "interbase",
  ul = "mariadb",
  cl = "netezza",
  al = "pervasive",
  ll = "pointbase",
  fl = "sqlite",
  dl = "sybase",
  hl = "teradata",
  pl = "vertica",
  Sl = "coldfusion",
  El = "cassandra",
  ml = "hbase",
  Tl = "mongodb",
  _l = "redis",
  bl = "couchbase",
  vl = "couchdb",
  yl = "cosmosdb",
  Rl = "dynamodb",
  Al = "neo4j",
  Ol = "geode",
  gl = "elasticsearch",
  Nl = "memcached",
  Cl = "cockroachdb",
  Ll = Wa,
  Il = Ya,
  Ml = Ha,
  wl = Da,
  Zl = ja,
  Pl = xa,
  Vl = ka,
  Gl = Ka,
  Xl = Ba,
  Ul = Fa,
  Wl = Ja,
  Yl = za,
  Hl = Qa,
  Dl = $a,
  jl = qa,
  xl = tl,
  kl = nl,
  Kl = el,
  Bl = rl,
  Fl = ol,
  Jl = il,
  zl = sl,
  Ql = ul,
  $l = cl,
  ql = al,
  tf = ll,
  nf = fl,
  ef = dl,
  rf = hl,
  of = pl,
  sf = Sl,
  uf = El,
  cf = ml,
  af = Tl,
  lf = _l,
  ff = bl,
  df = vl,
  hf = yl,
  pf = Rl,
  Sf = Al,
  Ef = Ol,
  mf = gl,
  Tf = Nl,
  _f = Cl,
  bf = zo([
    Wa,
    Ya,
    Ha,
    Da,
    "db2",
    ja,
    xa,
    ka,
    Ka,
    Ba,
    Fa,
    Ja,
    za,
    Qa,
    $a,
    "edb",
    qa,
    tl,
    nl,
    el,
    rl,
    ol,
    il,
    sl,
    ul,
    cl,
    al,
    ll,
    fl,
    dl,
    hl,
    pl,
    "h2",
    Sl,
    El,
    ml,
    Tl,
    _l,
    bl,
    vl,
    yl,
    Rl,
    Al,
    Ol,
    gl,
    Nl,
    Cl,
  ]),
  vf = "each_quorum",
  yf = "quorum",
  Rf = "local_quorum",
  Af = "three",
  Of = "local_one",
  gf = "serial",
  Nf = "local_serial",
  Cf = vf,
  Lf = yf,
  If = Rf,
  Mf = Af,
  wf = Of,
  Zf = gf,
  Pf = Nf,
  Vf = zo(["all", vf, yf, Rf, "one", "two", Af, Of, "any", gf, Nf]),
  Gf = "datasource",
  Xf = "http",
  Uf = "pubsub",
  Wf = "timer",
  Yf = "other",
  Hf = Gf,
  Df = Xf,
  jf = Uf,
  xf = Wf,
  kf = Yf,
  Kf = zo([Gf, Xf, Uf, Wf, Yf]),
  Bf = "insert",
  Ff = "edit",
  Jf = "delete",
  zf = Bf,
  Qf = Ff,
  $f = Jf,
  qf = zo([Bf, Ff, Jf]),
  td = "alibaba_cloud",
  nd = "azure",
  ed = td,
  rd = nd,
  od = zo([td, "aws", nd, "gcp"]),
  id = "ip_tcp",
  sd = "ip_udp",
  ud = "unix",
  cd = "pipe",
  ad = "inproc",
  ld = "other",
  fd = id,
  dd = sd,
  hd = ud,
  pd = cd,
  Sd = ad,
  Ed = ld,
  md = zo([id, sd, "ip", ud, cd, ad, ld]),
  Td = "wifi",
  _d = "wired",
  bd = "cell",
  vd = "unavailable",
  yd = "unknown",
  Rd = Td,
  Ad = _d,
  Od = bd,
  gd = vd,
  Nd = yd,
  Cd = zo([Td, _d, bd, vd, yd]),
  Ld = "gprs",
  Id = "edge",
  Md = "umts",
  wd = "cdma",
  Zd = "evdo_0",
  Pd = "evdo_a",
  Vd = "cdma2000_1xrtt",
  Gd = "hsdpa",
  Xd = "hsupa",
  Ud = "hspa",
  Wd = "iden",
  Yd = "evdo_b",
  Hd = "ehrpd",
  Dd = "hspap",
  jd = "td_scdma",
  xd = "iwlan",
  kd = "nrnsa",
  Kd = "lte_ca",
  Bd = Ld,
  Fd = Id,
  Jd = Md,
  zd = wd,
  Qd = Zd,
  $d = Pd,
  qd = Vd,
  th = Gd,
  nh = Xd,
  eh = Ud,
  rh = Wd,
  oh = Yd,
  ih = Hd,
  sh = Dd,
  uh = jd,
  ch = xd,
  ah = kd,
  lh = Kd,
  fh = zo([
    Ld,
    Id,
    Md,
    wd,
    Zd,
    Pd,
    Vd,
    Gd,
    Xd,
    Ud,
    Wd,
    Yd,
    "lte",
    Hd,
    Dd,
    "gsm",
    jd,
    xd,
    "nr",
    kd,
    Kd,
  ]),
  dh = "SPDY",
  hh = "QUIC",
  ph = dh,
  Sh = hh,
  Eh = {
    HTTP_1_0: "1.0",
    HTTP_1_1: "1.1",
    HTTP_2_0: "2.0",
    SPDY: dh,
    QUIC: hh,
  },
  mh = "queue",
  Th = "topic",
  _h = mh,
  bh = Th,
  vh = zo([mh, Th]),
  yh = "receive",
  Rh = "process",
  Ah = yh,
  Oh = Rh,
  gh = zo([yh, Rh]),
  Nh = {
    OK: 0,
    CANCELLED: 1,
    UNKNOWN: 2,
    INVALID_ARGUMENT: 3,
    DEADLINE_EXCEEDED: 4,
    NOT_FOUND: 5,
    ALREADY_EXISTS: 6,
    PERMISSION_DENIED: 7,
    RESOURCE_EXHAUSTED: 8,
    FAILED_PRECONDITION: 9,
    ABORTED: 10,
    OUT_OF_RANGE: 11,
    UNIMPLEMENTED: 12,
    INTERNAL: 13,
    UNAVAILABLE: 14,
    DATA_LOSS: 15,
    UNAUTHENTICATED: 16,
  },
  Ch = "SENT",
  Lh = "RECEIVED",
  Ih = Ch,
  Mh = Lh,
  wh = zo([Ch, Lh]),
  Zh = "cloud.provider",
  Ph = "cloud.account.id",
  Vh = "cloud.region",
  Gh = "cloud.availability_zone",
  Xh = "cloud.platform",
  Uh = "aws.ecs.container.arn",
  Wh = "aws.ecs.cluster.arn",
  Yh = "aws.ecs.launchtype",
  Hh = "aws.ecs.task.arn",
  Dh = "aws.ecs.task.family",
  jh = "aws.ecs.task.revision",
  xh = "aws.eks.cluster.arn",
  kh = "aws.log.group.names",
  Kh = "aws.log.group.arns",
  Bh = "aws.log.stream.names",
  Fh = "aws.log.stream.arns",
  Jh = "container.name",
  zh = "container.id",
  Qh = "container.runtime",
  $h = "container.image.name",
  qh = "container.image.tag",
  tp = "deployment.environment",
  np = "device.id",
  ep = "device.model.identifier",
  rp = "device.model.name",
  op = "faas.name",
  ip = "faas.id",
  sp = "faas.version",
  up = "faas.instance",
  cp = "faas.max_memory",
  ap = "host.id",
  lp = "host.name",
  fp = "host.type",
  dp = "host.arch",
  hp = "host.image.name",
  pp = "host.image.id",
  Sp = "host.image.version",
  Ep = "k8s.cluster.name",
  mp = "k8s.node.name",
  Tp = "k8s.node.uid",
  _p = "k8s.namespace.name",
  bp = "k8s.pod.uid",
  vp = "k8s.pod.name",
  yp = "k8s.container.name",
  Rp = "k8s.replicaset.uid",
  Ap = "k8s.replicaset.name",
  Op = "k8s.deployment.uid",
  gp = "k8s.deployment.name",
  Np = "k8s.statefulset.uid",
  Cp = "k8s.statefulset.name",
  Lp = "k8s.daemonset.uid",
  Ip = "k8s.daemonset.name",
  Mp = "k8s.job.uid",
  wp = "k8s.job.name",
  Zp = "k8s.cronjob.uid",
  Pp = "k8s.cronjob.name",
  Vp = "os.type",
  Gp = "os.description",
  Xp = "os.name",
  Up = "os.version",
  Wp = "process.pid",
  Yp = "process.executable.name",
  Hp = "process.executable.path",
  Dp = "process.command",
  jp = "process.command_line",
  xp = "process.command_args",
  kp = "process.owner",
  Kp = "process.runtime.name",
  Bp = "process.runtime.version",
  Fp = "process.runtime.description",
  Jp = "service.name",
  zp = "service.namespace",
  Qp = "service.instance.id",
  $p = "service.version",
  qp = "telemetry.sdk.name",
  tS = "telemetry.sdk.language",
  nS = "telemetry.sdk.version",
  eS = "telemetry.auto.version",
  rS = "webengine.name",
  oS = "webengine.version",
  iS = "webengine.description",
  sS = Zh,
  uS = Ph,
  cS = Vh,
  aS = Gh,
  lS = Xh,
  fS = Uh,
  dS = Wh,
  hS = Yh,
  pS = Hh,
  SS = Dh,
  ES = jh,
  mS = xh,
  TS = kh,
  _S = Kh,
  bS = Bh,
  vS = Fh,
  yS = Jh,
  RS = zh,
  AS = Qh,
  OS = $h,
  gS = qh,
  NS = tp,
  CS = np,
  LS = ep,
  IS = rp,
  MS = op,
  wS = ip,
  ZS = sp,
  PS = up,
  VS = cp,
  GS = ap,
  XS = lp,
  US = fp,
  WS = dp,
  YS = hp,
  HS = pp,
  DS = Sp,
  jS = Ep,
  xS = mp,
  kS = Tp,
  KS = _p,
  BS = bp,
  FS = vp,
  JS = yp,
  zS = Rp,
  QS = Ap,
  $S = Op,
  qS = gp,
  tE = Np,
  nE = Cp,
  eE = Lp,
  rE = Ip,
  oE = Mp,
  iE = wp,
  sE = Zp,
  uE = Pp,
  cE = Vp,
  aE = Gp,
  lE = Xp,
  fE = Up,
  dE = Wp,
  hE = Yp,
  pE = Hp,
  SE = Dp,
  EE = jp,
  mE = xp,
  TE = kp,
  _E = Kp,
  bE = Bp,
  vE = Fp,
  yE = Jp,
  RE = zp,
  AE = Qp,
  OE = $p,
  gE = qp,
  NE = tS,
  CE = nS,
  LE = eS,
  IE = rS,
  ME = oS,
  wE = iS,
  ZE = zo([
    Zh,
    Ph,
    Vh,
    Gh,
    Xh,
    Uh,
    Wh,
    Yh,
    Hh,
    Dh,
    jh,
    xh,
    kh,
    Kh,
    Bh,
    Fh,
    Jh,
    zh,
    Qh,
    $h,
    qh,
    tp,
    np,
    ep,
    rp,
    op,
    ip,
    sp,
    up,
    cp,
    ap,
    lp,
    fp,
    dp,
    hp,
    pp,
    Sp,
    Ep,
    mp,
    Tp,
    _p,
    bp,
    vp,
    yp,
    Rp,
    Ap,
    Op,
    gp,
    Np,
    Cp,
    Lp,
    Ip,
    Mp,
    wp,
    Zp,
    Pp,
    Vp,
    Gp,
    Xp,
    Up,
    Wp,
    Yp,
    Hp,
    Dp,
    jp,
    xp,
    kp,
    Kp,
    Bp,
    Fp,
    Jp,
    zp,
    Qp,
    $p,
    qp,
    tS,
    nS,
    eS,
    rS,
    oS,
    iS,
  ]),
  PE = "alibaba_cloud",
  VE = "azure",
  GE = PE,
  XE = VE,
  UE = zo([PE, "aws", VE, "gcp"]),
  WE = "alibaba_cloud_ecs",
  YE = "alibaba_cloud_fc",
  HE = "aws_ec2",
  DE = "aws_ecs",
  jE = "aws_eks",
  xE = "aws_lambda",
  kE = "aws_elastic_beanstalk",
  KE = "azure_vm",
  BE = "azure_container_instances",
  FE = "azure_aks",
  JE = "azure_functions",
  zE = "azure_app_service",
  QE = "gcp_compute_engine",
  $E = "gcp_cloud_run",
  qE = "gcp_kubernetes_engine",
  tm = "gcp_cloud_functions",
  nm = "gcp_app_engine",
  em = WE,
  rm = YE,
  om = HE,
  im = DE,
  sm = jE,
  um = xE,
  cm = kE,
  am = KE,
  lm = BE,
  fm = FE,
  dm = JE,
  hm = zE,
  pm = QE,
  Sm = $E,
  Em = qE,
  mm = tm,
  Tm = nm,
  _m = zo([WE, YE, HE, DE, jE, xE, kE, KE, BE, FE, JE, zE, QE, $E, qE, tm, nm]),
  bm = "fargate",
  vm = bm,
  ym = zo(["ec2", bm]),
  Rm = "amd64",
  Am = "arm32",
  Om = "arm64",
  gm = "ia64",
  Nm = "ppc32",
  Cm = "ppc64",
  Lm = Rm,
  Im = Am,
  Mm = Om,
  wm = gm,
  Zm = Nm,
  Pm = Cm,
  Vm = zo([Rm, Am, Om, gm, Nm, Cm, "x86"]),
  Gm = "windows",
  Xm = "linux",
  Um = "darwin",
  Wm = "freebsd",
  Ym = "netbsd",
  Hm = "openbsd",
  Dm = "dragonflybsd",
  jm = "hpux",
  xm = "solaris",
  km = "z_os",
  Km = Gm,
  Bm = Xm,
  Fm = Um,
  Jm = Wm,
  zm = Ym,
  Qm = Hm,
  $m = Dm,
  qm = jm,
  tT = xm,
  nT = km,
  eT = zo([Gm, Xm, Um, Wm, Ym, Hm, Dm, jm, "aix", xm, km]),
  rT = "dotnet",
  oT = "erlang",
  iT = "java",
  sT = "nodejs",
  uT = "python",
  cT = "ruby",
  aT = "webjs",
  lT = rT,
  fT = oT,
  dT = iT,
  hT = sT,
  pT = uT,
  ST = cT,
  ET = aT,
  mT = zo(["cpp", rT, oT, "go", iT, sT, "php", uT, cT, aT]),
  TT = Object.freeze({
    __proto__: null,
    AWSECSLAUNCHTYPEVALUES_EC2: "ec2",
    AWSECSLAUNCHTYPEVALUES_FARGATE: vm,
    AwsEcsLaunchtypeValues: ym,
    CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS: em,
    CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC: rm,
    CLOUDPLATFORMVALUES_AWS_EC2: om,
    CLOUDPLATFORMVALUES_AWS_ECS: im,
    CLOUDPLATFORMVALUES_AWS_EKS: sm,
    CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK: cm,
    CLOUDPLATFORMVALUES_AWS_LAMBDA: um,
    CLOUDPLATFORMVALUES_AZURE_AKS: fm,
    CLOUDPLATFORMVALUES_AZURE_APP_SERVICE: hm,
    CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES: lm,
    CLOUDPLATFORMVALUES_AZURE_FUNCTIONS: dm,
    CLOUDPLATFORMVALUES_AZURE_VM: am,
    CLOUDPLATFORMVALUES_GCP_APP_ENGINE: Tm,
    CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS: mm,
    CLOUDPLATFORMVALUES_GCP_CLOUD_RUN: Sm,
    CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE: pm,
    CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE: Em,
    CLOUDPROVIDERVALUES_ALIBABA_CLOUD: GE,
    CLOUDPROVIDERVALUES_AWS: "aws",
    CLOUDPROVIDERVALUES_AZURE: XE,
    CLOUDPROVIDERVALUES_GCP: "gcp",
    CloudPlatformValues: _m,
    CloudProviderValues: UE,
    DBCASSANDRACONSISTENCYLEVELVALUES_ALL: "all",
    DBCASSANDRACONSISTENCYLEVELVALUES_ANY: "any",
    DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM: Cf,
    DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE: wf,
    DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM: If,
    DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL: Pf,
    DBCASSANDRACONSISTENCYLEVELVALUES_ONE: "one",
    DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM: Lf,
    DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL: Zf,
    DBCASSANDRACONSISTENCYLEVELVALUES_THREE: Mf,
    DBCASSANDRACONSISTENCYLEVELVALUES_TWO: "two",
    DBSYSTEMVALUES_ADABAS: xl,
    DBSYSTEMVALUES_CACHE: jl,
    DBSYSTEMVALUES_CASSANDRA: uf,
    DBSYSTEMVALUES_CLOUDSCAPE: Gl,
    DBSYSTEMVALUES_COCKROACHDB: _f,
    DBSYSTEMVALUES_COLDFUSION: sf,
    DBSYSTEMVALUES_COSMOSDB: hf,
    DBSYSTEMVALUES_COUCHBASE: ff,
    DBSYSTEMVALUES_COUCHDB: df,
    DBSYSTEMVALUES_DB2: "db2",
    DBSYSTEMVALUES_DERBY: Kl,
    DBSYSTEMVALUES_DYNAMODB: pf,
    DBSYSTEMVALUES_EDB: "edb",
    DBSYSTEMVALUES_ELASTICSEARCH: mf,
    DBSYSTEMVALUES_FILEMAKER: Bl,
    DBSYSTEMVALUES_FIREBIRD: kl,
    DBSYSTEMVALUES_FIRSTSQL: Dl,
    DBSYSTEMVALUES_GEODE: Ef,
    DBSYSTEMVALUES_H2: "h2",
    DBSYSTEMVALUES_HANADB: Yl,
    DBSYSTEMVALUES_HBASE: cf,
    DBSYSTEMVALUES_HIVE: Vl,
    DBSYSTEMVALUES_HSQLDB: Xl,
    DBSYSTEMVALUES_INFORMIX: Fl,
    DBSYSTEMVALUES_INGRES: Hl,
    DBSYSTEMVALUES_INSTANTDB: Jl,
    DBSYSTEMVALUES_INTERBASE: zl,
    DBSYSTEMVALUES_MARIADB: Ql,
    DBSYSTEMVALUES_MAXDB: Wl,
    DBSYSTEMVALUES_MEMCACHED: Tf,
    DBSYSTEMVALUES_MONGODB: af,
    DBSYSTEMVALUES_MSSQL: Il,
    DBSYSTEMVALUES_MYSQL: Ml,
    DBSYSTEMVALUES_NEO4J: Sf,
    DBSYSTEMVALUES_NETEZZA: $l,
    DBSYSTEMVALUES_ORACLE: wl,
    DBSYSTEMVALUES_OTHER_SQL: Ll,
    DBSYSTEMVALUES_PERVASIVE: ql,
    DBSYSTEMVALUES_POINTBASE: tf,
    DBSYSTEMVALUES_POSTGRESQL: Zl,
    DBSYSTEMVALUES_PROGRESS: Ul,
    DBSYSTEMVALUES_REDIS: lf,
    DBSYSTEMVALUES_REDSHIFT: Pl,
    DBSYSTEMVALUES_SQLITE: nf,
    DBSYSTEMVALUES_SYBASE: ef,
    DBSYSTEMVALUES_TERADATA: rf,
    DBSYSTEMVALUES_VERTICA: of,
    DbCassandraConsistencyLevelValues: Vf,
    DbSystemValues: bf,
    FAASDOCUMENTOPERATIONVALUES_DELETE: $f,
    FAASDOCUMENTOPERATIONVALUES_EDIT: Qf,
    FAASDOCUMENTOPERATIONVALUES_INSERT: zf,
    FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD: ed,
    FAASINVOKEDPROVIDERVALUES_AWS: "aws",
    FAASINVOKEDPROVIDERVALUES_AZURE: rd,
    FAASINVOKEDPROVIDERVALUES_GCP: "gcp",
    FAASTRIGGERVALUES_DATASOURCE: Hf,
    FAASTRIGGERVALUES_HTTP: Df,
    FAASTRIGGERVALUES_OTHER: kf,
    FAASTRIGGERVALUES_PUBSUB: jf,
    FAASTRIGGERVALUES_TIMER: xf,
    FaasDocumentOperationValues: qf,
    FaasInvokedProviderValues: od,
    FaasTriggerValues: Kf,
    HOSTARCHVALUES_AMD64: Lm,
    HOSTARCHVALUES_ARM32: Im,
    HOSTARCHVALUES_ARM64: Mm,
    HOSTARCHVALUES_IA64: wm,
    HOSTARCHVALUES_PPC32: Zm,
    HOSTARCHVALUES_PPC64: Pm,
    HOSTARCHVALUES_X86: "x86",
    HTTPFLAVORVALUES_HTTP_1_0: "1.0",
    HTTPFLAVORVALUES_HTTP_1_1: "1.1",
    HTTPFLAVORVALUES_HTTP_2_0: "2.0",
    HTTPFLAVORVALUES_QUIC: Sh,
    HTTPFLAVORVALUES_SPDY: ph,
    HostArchValues: Vm,
    HttpFlavorValues: Eh,
    MESSAGETYPEVALUES_RECEIVED: Mh,
    MESSAGETYPEVALUES_SENT: Ih,
    MESSAGINGDESTINATIONKINDVALUES_QUEUE: _h,
    MESSAGINGDESTINATIONKINDVALUES_TOPIC: bh,
    MESSAGINGOPERATIONVALUES_PROCESS: Oh,
    MESSAGINGOPERATIONVALUES_RECEIVE: Ah,
    MessageTypeValues: wh,
    MessagingDestinationKindValues: vh,
    MessagingOperationValues: gh,
    NETHOSTCONNECTIONSUBTYPEVALUES_CDMA: zd,
    NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT: qd,
    NETHOSTCONNECTIONSUBTYPEVALUES_EDGE: Fd,
    NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD: ih,
    NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0: Qd,
    NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A: $d,
    NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B: oh,
    NETHOSTCONNECTIONSUBTYPEVALUES_GPRS: Bd,
    NETHOSTCONNECTIONSUBTYPEVALUES_GSM: "gsm",
    NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA: th,
    NETHOSTCONNECTIONSUBTYPEVALUES_HSPA: eh,
    NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP: sh,
    NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA: nh,
    NETHOSTCONNECTIONSUBTYPEVALUES_IDEN: rh,
    NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN: ch,
    NETHOSTCONNECTIONSUBTYPEVALUES_LTE: "lte",
    NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA: lh,
    NETHOSTCONNECTIONSUBTYPEVALUES_NR: "nr",
    NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA: ah,
    NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA: uh,
    NETHOSTCONNECTIONSUBTYPEVALUES_UMTS: Jd,
    NETHOSTCONNECTIONTYPEVALUES_CELL: Od,
    NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE: gd,
    NETHOSTCONNECTIONTYPEVALUES_UNKNOWN: Nd,
    NETHOSTCONNECTIONTYPEVALUES_WIFI: Rd,
    NETHOSTCONNECTIONTYPEVALUES_WIRED: Ad,
    NETTRANSPORTVALUES_INPROC: Sd,
    NETTRANSPORTVALUES_IP: "ip",
    NETTRANSPORTVALUES_IP_TCP: fd,
    NETTRANSPORTVALUES_IP_UDP: dd,
    NETTRANSPORTVALUES_OTHER: Ed,
    NETTRANSPORTVALUES_PIPE: pd,
    NETTRANSPORTVALUES_UNIX: hd,
    NetHostConnectionSubtypeValues: fh,
    NetHostConnectionTypeValues: Cd,
    NetTransportValues: md,
    OSTYPEVALUES_AIX: "aix",
    OSTYPEVALUES_DARWIN: Fm,
    OSTYPEVALUES_DRAGONFLYBSD: $m,
    OSTYPEVALUES_FREEBSD: Jm,
    OSTYPEVALUES_HPUX: qm,
    OSTYPEVALUES_LINUX: Bm,
    OSTYPEVALUES_NETBSD: zm,
    OSTYPEVALUES_OPENBSD: Qm,
    OSTYPEVALUES_SOLARIS: tT,
    OSTYPEVALUES_WINDOWS: Km,
    OSTYPEVALUES_Z_OS: nT,
    OsTypeValues: eT,
    RPCGRPCSTATUSCODEVALUES_ABORTED: 10,
    RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS: 6,
    RPCGRPCSTATUSCODEVALUES_CANCELLED: 1,
    RPCGRPCSTATUSCODEVALUES_DATA_LOSS: 15,
    RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED: 4,
    RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION: 9,
    RPCGRPCSTATUSCODEVALUES_INTERNAL: 13,
    RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT: 3,
    RPCGRPCSTATUSCODEVALUES_NOT_FOUND: 5,
    RPCGRPCSTATUSCODEVALUES_OK: 0,
    RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE: 11,
    RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED: 7,
    RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED: 8,
    RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED: 16,
    RPCGRPCSTATUSCODEVALUES_UNAVAILABLE: 14,
    RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED: 12,
    RPCGRPCSTATUSCODEVALUES_UNKNOWN: 2,
    RpcGrpcStatusCodeValues: Nh,
    SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET: Bc,
    SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS: ia,
    SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ: xc,
    SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY: Yc,
    SEMATTRS_AWS_DYNAMODB_COUNT: ra,
    SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE: $c,
    SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES: zc,
    SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES: sa,
    SEMATTRS_AWS_DYNAMODB_INDEX_NAME: Fc,
    SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS: Hc,
    SEMATTRS_AWS_DYNAMODB_LIMIT: Kc,
    SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES: Qc,
    SEMATTRS_AWS_DYNAMODB_PROJECTION: kc,
    SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY: Dc,
    SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY: jc,
    SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT: oa,
    SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD: ta,
    SEMATTRS_AWS_DYNAMODB_SEGMENT: na,
    SEMATTRS_AWS_DYNAMODB_SELECT: Jc,
    SEMATTRS_AWS_DYNAMODB_TABLE_COUNT: qc,
    SEMATTRS_AWS_DYNAMODB_TABLE_NAMES: Wc,
    SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS: ea,
    SEMATTRS_AWS_LAMBDA_INVOKED_ARN: Tu,
    SEMATTRS_CODE_FILEPATH: yc,
    SEMATTRS_CODE_FUNCTION: bc,
    SEMATTRS_CODE_LINENO: Rc,
    SEMATTRS_CODE_NAMESPACE: vc,
    SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL: Lu,
    SEMATTRS_DB_CASSANDRA_COORDINATOR_DC: Pu,
    SEMATTRS_DB_CASSANDRA_COORDINATOR_ID: Zu,
    SEMATTRS_DB_CASSANDRA_IDEMPOTENCE: Mu,
    SEMATTRS_DB_CASSANDRA_KEYSPACE: Nu,
    SEMATTRS_DB_CASSANDRA_PAGE_SIZE: Cu,
    SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT: wu,
    SEMATTRS_DB_CASSANDRA_TABLE: Iu,
    SEMATTRS_DB_CONNECTION_STRING: bu,
    SEMATTRS_DB_HBASE_NAMESPACE: Vu,
    SEMATTRS_DB_JDBC_DRIVER_CLASSNAME: yu,
    SEMATTRS_DB_MONGODB_COLLECTION: Xu,
    SEMATTRS_DB_MSSQL_INSTANCE_NAME: gu,
    SEMATTRS_DB_NAME: Ru,
    SEMATTRS_DB_OPERATION: Ou,
    SEMATTRS_DB_REDIS_DATABASE_INDEX: Gu,
    SEMATTRS_DB_SQL_TABLE: Uu,
    SEMATTRS_DB_STATEMENT: Au,
    SEMATTRS_DB_SYSTEM: _u,
    SEMATTRS_DB_USER: vu,
    SEMATTRS_ENDUSER_ID: Sc,
    SEMATTRS_ENDUSER_ROLE: Ec,
    SEMATTRS_ENDUSER_SCOPE: mc,
    SEMATTRS_EXCEPTION_ESCAPED: Du,
    SEMATTRS_EXCEPTION_MESSAGE: Yu,
    SEMATTRS_EXCEPTION_STACKTRACE: Hu,
    SEMATTRS_EXCEPTION_TYPE: Wu,
    SEMATTRS_FAAS_COLDSTART: Qu,
    SEMATTRS_FAAS_CRON: zu,
    SEMATTRS_FAAS_DOCUMENT_COLLECTION: ku,
    SEMATTRS_FAAS_DOCUMENT_NAME: Fu,
    SEMATTRS_FAAS_DOCUMENT_OPERATION: Ku,
    SEMATTRS_FAAS_DOCUMENT_TIME: Bu,
    SEMATTRS_FAAS_EXECUTION: xu,
    SEMATTRS_FAAS_INVOKED_NAME: $u,
    SEMATTRS_FAAS_INVOKED_PROVIDER: qu,
    SEMATTRS_FAAS_INVOKED_REGION: tc,
    SEMATTRS_FAAS_TIME: Ju,
    SEMATTRS_FAAS_TRIGGER: ju,
    SEMATTRS_HTTP_CLIENT_IP: Uc,
    SEMATTRS_HTTP_FLAVOR: Ic,
    SEMATTRS_HTTP_HOST: Nc,
    SEMATTRS_HTTP_METHOD: Ac,
    SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH: wc,
    SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED: Zc,
    SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH: Pc,
    SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED: Vc,
    SEMATTRS_HTTP_ROUTE: Xc,
    SEMATTRS_HTTP_SCHEME: Cc,
    SEMATTRS_HTTP_SERVER_NAME: Gc,
    SEMATTRS_HTTP_STATUS_CODE: Lc,
    SEMATTRS_HTTP_TARGET: gc,
    SEMATTRS_HTTP_URL: Oc,
    SEMATTRS_HTTP_USER_AGENT: Mc,
    SEMATTRS_MESSAGE_COMPRESSED_SIZE: Ga,
    SEMATTRS_MESSAGE_ID: Va,
    SEMATTRS_MESSAGE_TYPE: Pa,
    SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE: Xa,
    SEMATTRS_MESSAGING_CONSUMER_ID: _a,
    SEMATTRS_MESSAGING_CONVERSATION_ID: Sa,
    SEMATTRS_MESSAGING_DESTINATION: ca,
    SEMATTRS_MESSAGING_DESTINATION_KIND: aa,
    SEMATTRS_MESSAGING_KAFKA_CLIENT_ID: Ra,
    SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP: ya,
    SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY: va,
    SEMATTRS_MESSAGING_KAFKA_PARTITION: Aa,
    SEMATTRS_MESSAGING_KAFKA_TOMBSTONE: Oa,
    SEMATTRS_MESSAGING_MESSAGE_ID: pa,
    SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES: ma,
    SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES: Ea,
    SEMATTRS_MESSAGING_OPERATION: Ta,
    SEMATTRS_MESSAGING_PROTOCOL: fa,
    SEMATTRS_MESSAGING_PROTOCOL_VERSION: da,
    SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY: ba,
    SEMATTRS_MESSAGING_SYSTEM: ua,
    SEMATTRS_MESSAGING_TEMP_DESTINATION: la,
    SEMATTRS_MESSAGING_URL: ha,
    SEMATTRS_NET_HOST_CARRIER_ICC: hc,
    SEMATTRS_NET_HOST_CARRIER_MCC: fc,
    SEMATTRS_NET_HOST_CARRIER_MNC: dc,
    SEMATTRS_NET_HOST_CARRIER_NAME: lc,
    SEMATTRS_NET_HOST_CONNECTION_SUBTYPE: ac,
    SEMATTRS_NET_HOST_CONNECTION_TYPE: cc,
    SEMATTRS_NET_HOST_IP: ic,
    SEMATTRS_NET_HOST_NAME: uc,
    SEMATTRS_NET_HOST_PORT: sc,
    SEMATTRS_NET_PEER_IP: ec,
    SEMATTRS_NET_PEER_NAME: oc,
    SEMATTRS_NET_PEER_PORT: rc,
    SEMATTRS_NET_TRANSPORT: nc,
    SEMATTRS_PEER_SERVICE: pc,
    SEMATTRS_RPC_GRPC_STATUS_CODE: La,
    SEMATTRS_RPC_JSONRPC_ERROR_CODE: wa,
    SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE: Za,
    SEMATTRS_RPC_JSONRPC_REQUEST_ID: Ma,
    SEMATTRS_RPC_JSONRPC_VERSION: Ia,
    SEMATTRS_RPC_METHOD: Ca,
    SEMATTRS_RPC_SERVICE: Na,
    SEMATTRS_RPC_SYSTEM: ga,
    SEMATTRS_THREAD_ID: Tc,
    SEMATTRS_THREAD_NAME: _c,
    SEMRESATTRS_AWS_ECS_CLUSTER_ARN: dS,
    SEMRESATTRS_AWS_ECS_CONTAINER_ARN: fS,
    SEMRESATTRS_AWS_ECS_LAUNCHTYPE: hS,
    SEMRESATTRS_AWS_ECS_TASK_ARN: pS,
    SEMRESATTRS_AWS_ECS_TASK_FAMILY: SS,
    SEMRESATTRS_AWS_ECS_TASK_REVISION: ES,
    SEMRESATTRS_AWS_EKS_CLUSTER_ARN: mS,
    SEMRESATTRS_AWS_LOG_GROUP_ARNS: _S,
    SEMRESATTRS_AWS_LOG_GROUP_NAMES: TS,
    SEMRESATTRS_AWS_LOG_STREAM_ARNS: vS,
    SEMRESATTRS_AWS_LOG_STREAM_NAMES: bS,
    SEMRESATTRS_CLOUD_ACCOUNT_ID: uS,
    SEMRESATTRS_CLOUD_AVAILABILITY_ZONE: aS,
    SEMRESATTRS_CLOUD_PLATFORM: lS,
    SEMRESATTRS_CLOUD_PROVIDER: sS,
    SEMRESATTRS_CLOUD_REGION: cS,
    SEMRESATTRS_CONTAINER_ID: RS,
    SEMRESATTRS_CONTAINER_IMAGE_NAME: OS,
    SEMRESATTRS_CONTAINER_IMAGE_TAG: gS,
    SEMRESATTRS_CONTAINER_NAME: yS,
    SEMRESATTRS_CONTAINER_RUNTIME: AS,
    SEMRESATTRS_DEPLOYMENT_ENVIRONMENT: NS,
    SEMRESATTRS_DEVICE_ID: CS,
    SEMRESATTRS_DEVICE_MODEL_IDENTIFIER: LS,
    SEMRESATTRS_DEVICE_MODEL_NAME: IS,
    SEMRESATTRS_FAAS_ID: wS,
    SEMRESATTRS_FAAS_INSTANCE: PS,
    SEMRESATTRS_FAAS_MAX_MEMORY: VS,
    SEMRESATTRS_FAAS_NAME: MS,
    SEMRESATTRS_FAAS_VERSION: ZS,
    SEMRESATTRS_HOST_ARCH: WS,
    SEMRESATTRS_HOST_ID: GS,
    SEMRESATTRS_HOST_IMAGE_ID: HS,
    SEMRESATTRS_HOST_IMAGE_NAME: YS,
    SEMRESATTRS_HOST_IMAGE_VERSION: DS,
    SEMRESATTRS_HOST_NAME: XS,
    SEMRESATTRS_HOST_TYPE: US,
    SEMRESATTRS_K8S_CLUSTER_NAME: jS,
    SEMRESATTRS_K8S_CONTAINER_NAME: JS,
    SEMRESATTRS_K8S_CRONJOB_NAME: uE,
    SEMRESATTRS_K8S_CRONJOB_UID: sE,
    SEMRESATTRS_K8S_DAEMONSET_NAME: rE,
    SEMRESATTRS_K8S_DAEMONSET_UID: eE,
    SEMRESATTRS_K8S_DEPLOYMENT_NAME: qS,
    SEMRESATTRS_K8S_DEPLOYMENT_UID: $S,
    SEMRESATTRS_K8S_JOB_NAME: iE,
    SEMRESATTRS_K8S_JOB_UID: oE,
    SEMRESATTRS_K8S_NAMESPACE_NAME: KS,
    SEMRESATTRS_K8S_NODE_NAME: xS,
    SEMRESATTRS_K8S_NODE_UID: kS,
    SEMRESATTRS_K8S_POD_NAME: FS,
    SEMRESATTRS_K8S_POD_UID: BS,
    SEMRESATTRS_K8S_REPLICASET_NAME: QS,
    SEMRESATTRS_K8S_REPLICASET_UID: zS,
    SEMRESATTRS_K8S_STATEFULSET_NAME: nE,
    SEMRESATTRS_K8S_STATEFULSET_UID: tE,
    SEMRESATTRS_OS_DESCRIPTION: aE,
    SEMRESATTRS_OS_NAME: lE,
    SEMRESATTRS_OS_TYPE: cE,
    SEMRESATTRS_OS_VERSION: fE,
    SEMRESATTRS_PROCESS_COMMAND: SE,
    SEMRESATTRS_PROCESS_COMMAND_ARGS: mE,
    SEMRESATTRS_PROCESS_COMMAND_LINE: EE,
    SEMRESATTRS_PROCESS_EXECUTABLE_NAME: hE,
    SEMRESATTRS_PROCESS_EXECUTABLE_PATH: pE,
    SEMRESATTRS_PROCESS_OWNER: TE,
    SEMRESATTRS_PROCESS_PID: dE,
    SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION: vE,
    SEMRESATTRS_PROCESS_RUNTIME_NAME: _E,
    SEMRESATTRS_PROCESS_RUNTIME_VERSION: bE,
    SEMRESATTRS_SERVICE_INSTANCE_ID: AE,
    SEMRESATTRS_SERVICE_NAME: yE,
    SEMRESATTRS_SERVICE_NAMESPACE: RE,
    SEMRESATTRS_SERVICE_VERSION: OE,
    SEMRESATTRS_TELEMETRY_AUTO_VERSION: LE,
    SEMRESATTRS_TELEMETRY_SDK_LANGUAGE: NE,
    SEMRESATTRS_TELEMETRY_SDK_NAME: gE,
    SEMRESATTRS_TELEMETRY_SDK_VERSION: CE,
    SEMRESATTRS_WEBENGINE_DESCRIPTION: wE,
    SEMRESATTRS_WEBENGINE_NAME: IE,
    SEMRESATTRS_WEBENGINE_VERSION: ME,
    SemanticAttributes: Ua,
    SemanticResourceAttributes: ZE,
    TELEMETRYSDKLANGUAGEVALUES_CPP: "cpp",
    TELEMETRYSDKLANGUAGEVALUES_DOTNET: lT,
    TELEMETRYSDKLANGUAGEVALUES_ERLANG: fT,
    TELEMETRYSDKLANGUAGEVALUES_GO: "go",
    TELEMETRYSDKLANGUAGEVALUES_JAVA: dT,
    TELEMETRYSDKLANGUAGEVALUES_NODEJS: hT,
    TELEMETRYSDKLANGUAGEVALUES_PHP: "php",
    TELEMETRYSDKLANGUAGEVALUES_PYTHON: pT,
    TELEMETRYSDKLANGUAGEVALUES_RUBY: ST,
    TELEMETRYSDKLANGUAGEVALUES_WEBJS: ET,
    TelemetrySdkLanguageValues: mT,
  }),
  _T =
    (((Qo = {})[ZE.TELEMETRY_SDK_NAME] = "opentelemetry"),
    (Qo[ZE.PROCESS_RUNTIME_NAME] = "node"),
    (Qo[ZE.TELEMETRY_SDK_LANGUAGE] = mT.NODEJS),
    (Qo[ZE.TELEMETRY_SDK_VERSION] = Jo),
    Qo);
var bT,
  vT = Math.pow(10, 6),
  yT = Math.pow(10, 9);
function RT(t) {
  var n = t / 1e3;
  return [Math.trunc(n), Math.round((t % 1e3) * vT)];
}
function AT() {
  var t = Fo.timeOrigin;
  if ("number" != typeof t) {
    var n = Fo;
    t = n.timing && n.timing.fetchStart;
  }
  return t;
}
function OT(t) {
  return NT(RT(AT()), RT("number" == typeof t ? t : Fo.now()));
}
function gT(t) {
  return (
    Array.isArray(t) &&
    2 === t.length &&
    "number" == typeof t[0] &&
    "number" == typeof t[1]
  );
}
function NT(t, n) {
  var e = [t[0] + n[0], t[1] + n[1]];
  return e[1] >= yT && ((e[1] -= yT), (e[0] += 1)), e;
}
!(function (t) {
  (t[(t.SUCCESS = 0)] = "SUCCESS"), (t[(t.FAILED = 1)] = "FAILED");
})(bT || (bT = {}));
var CT = function (t) {
    var n = "function" == typeof Symbol && Symbol.iterator,
      e = n && t[n],
      r = 0;
    if (e) return e.call(t);
    if (t && "number" == typeof t.length)
      return {
        next: function () {
          return (
            t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t }
          );
        },
      };
    throw new TypeError(
      n ? "Object is not iterable." : "Symbol.iterator is not defined."
    );
  },
  LT = (function () {
    function t(t) {
      var n;
      void 0 === t && (t = {}),
        (this.tt = null !== (n = t.propagators) && void 0 !== n ? n : []),
        (this.nt = Array.from(
          new Set(
            this.tt
              .map(function (t) {
                return "function" == typeof t.fields ? t.fields() : [];
              })
              .reduce(function (t, n) {
                return t.concat(n);
              }, [])
          )
        ));
    }
    return (
      (t.prototype.inject = function (t, n, e) {
        var r, o;
        try {
          for (var i = CT(this.tt), s = i.next(); !s.done; s = i.next()) {
            var u = s.value;
            try {
              u.inject(t, n, e);
            } catch (t) {
              Pr.warn(
                "Failed to inject with " +
                  u.constructor.name +
                  ". Err: " +
                  t.message
              );
            }
          }
        } catch (t) {
          r = { error: t };
        } finally {
          try {
            s && !s.done && (o = i.return) && o.call(i);
          } finally {
            if (r) throw r.error;
          }
        }
      }),
      (t.prototype.extract = function (t, n, e) {
        return this.tt.reduce(function (t, r) {
          try {
            return r.extract(t, n, e);
          } catch (t) {
            Pr.warn(
              "Failed to inject with " +
                r.constructor.name +
                ". Err: " +
                t.message
            );
          }
          return t;
        }, t);
      }),
      (t.prototype.fields = function () {
        return this.nt.slice();
      }),
      t
    );
  })(),
  IT = "[_0-9a-z-*/]",
  MT = new RegExp(
    "^(?:" +
      ("[a-z]" + IT + "{0,255}") +
      "|" +
      ("[a-z0-9]" + IT + "{0,240}@[a-z]" + IT + "{0,13}") +
      ")$"
  ),
  wT = /^[ -~]{0,255}[!-~]$/,
  ZT = /,|=/;
var PT = (function () {
    function t(t) {
      (this.U = new Map()), t && this.W(t);
    }
    return (
      (t.prototype.set = function (t, n) {
        var e = this.Y();
        return e.U.has(t) && e.U.delete(t), e.U.set(t, n), e;
      }),
      (t.prototype.unset = function (t) {
        var n = this.Y();
        return n.U.delete(t), n;
      }),
      (t.prototype.get = function (t) {
        return this.U.get(t);
      }),
      (t.prototype.serialize = function () {
        var t = this;
        return this.H()
          .reduce(function (n, e) {
            return n.push(e + "=" + t.get(e)), n;
          }, [])
          .join(",");
      }),
      (t.prototype.W = function (t) {
        t.length > 512 ||
          ((this.U = t
            .split(",")
            .reverse()
            .reduce(function (t, n) {
              var e = n.trim(),
                r = e.indexOf("=");
              if (-1 !== r) {
                var o = e.slice(0, r),
                  i = e.slice(r + 1, n.length);
                (function (t) {
                  return MT.test(t);
                })(o) &&
                  (function (t) {
                    return wT.test(t) && !ZT.test(t);
                  })(i) &&
                  t.set(o, i);
              }
              return t;
            }, new Map())),
          this.U.size > 32 &&
            (this.U = new Map(
              Array.from(this.U.entries()).reverse().slice(0, 32)
            )));
      }),
      (t.prototype.H = function () {
        return Array.from(this.U.keys()).reverse();
      }),
      (t.prototype.Y = function () {
        var n = new t();
        return (n.U = new Map(this.U)), n;
      }),
      t
    );
  })(),
  VT = "traceparent",
  GT = "tracestate",
  XT = new RegExp(
    "^\\s?((?!ff)[\\da-f]{2})-((?![0]{32})[\\da-f]{32})-((?![0]{16})[\\da-f]{16})-([\\da-f]{2})(-.*)?\\s?$"
  );
function UT(t) {
  var n = XT.exec(t);
  return n
    ? "00" === n[1] && n[5]
      ? null
      : { traceId: n[2], spanId: n[3], traceFlags: parseInt(n[4], 16) }
    : null;
}
var WT,
  YT = (function () {
    function t() {}
    return (
      (t.prototype.inject = function (t, n, e) {
        var r = Qr.getSpanContext(t);
        if (r && !oo(t) && mr(r)) {
          var o =
            "00-" +
            r.traceId +
            "-" +
            r.spanId +
            "-0" +
            Number(r.traceFlags || ke.NONE).toString(16);
          e.set(n, VT, o),
            r.traceState && e.set(n, GT, r.traceState.serialize());
        }
      }),
      (t.prototype.extract = function (t, n, e) {
        var r = e.get(n, VT);
        if (!r) return t;
        var o = Array.isArray(r) ? r[0] : r;
        if ("string" != typeof o) return t;
        var i = UT(o);
        if (!i) return t;
        i.isRemote = !0;
        var s = e.get(n, GT);
        if (s) {
          var u = Array.isArray(s) ? s.join(",") : s;
          i.traceState = new PT("string" == typeof u ? u : void 0);
        }
        return Qr.setSpanContext(t, i);
      }),
      (t.prototype.fields = function () {
        return [VT, GT];
      }),
      t
    );
  })(),
  HT = ve("OpenTelemetry SDK Context Key RPC_METADATA");
(WT || (WT = {})).HTTP = "http";
var DT,
  jT,
  xT = (function () {
    function t() {}
    return (
      (t.prototype.shouldSample = function () {
        return { decision: vr.NOT_RECORD };
      }),
      (t.prototype.toString = function () {
        return "AlwaysOffSampler";
      }),
      t
    );
  })(),
  kT = (function () {
    function t() {}
    return (
      (t.prototype.shouldSample = function () {
        return { decision: vr.RECORD_AND_SAMPLED };
      }),
      (t.prototype.toString = function () {
        return "AlwaysOnSampler";
      }),
      t
    );
  })(),
  KT = (function () {
    function t(t) {
      var n, e, r, o;
      (this.et = t.root),
        this.et ||
          (Oo(
            new Error("ParentBasedSampler must have a root sampler configured")
          ),
          (this.et = new kT())),
        (this.rt =
          null !== (n = t.remoteParentSampled) && void 0 !== n ? n : new kT()),
        (this.ot =
          null !== (e = t.remoteParentNotSampled) && void 0 !== e
            ? e
            : new xT()),
        (this.it =
          null !== (r = t.localParentSampled) && void 0 !== r ? r : new kT()),
        (this.st =
          null !== (o = t.localParentNotSampled) && void 0 !== o
            ? o
            : new xT());
    }
    return (
      (t.prototype.shouldSample = function (t, n, e, r, o, i) {
        var s = Qr.getSpanContext(t);
        return s && mr(s)
          ? s.isRemote
            ? s.traceFlags & ke.SAMPLED
              ? this.rt.shouldSample(t, n, e, r, o, i)
              : this.ot.shouldSample(t, n, e, r, o, i)
            : s.traceFlags & ke.SAMPLED
              ? this.it.shouldSample(t, n, e, r, o, i)
              : this.st.shouldSample(t, n, e, r, o, i)
          : this.et.shouldSample(t, n, e, r, o, i);
      }),
      (t.prototype.toString = function () {
        return (
          "ParentBased{root=" +
          this.et.toString() +
          ", remoteParentSampled=" +
          this.rt.toString() +
          ", remoteParentNotSampled=" +
          this.ot.toString() +
          ", localParentSampled=" +
          this.it.toString() +
          ", localParentNotSampled=" +
          this.st.toString() +
          "}"
        );
      }),
      t
    );
  })(),
  BT = (function () {
    function t(t) {
      void 0 === t && (t = 0),
        (this.ut = t),
        (this.ut = this.ct(t)),
        (this.ft = Math.floor(4294967295 * this.ut));
    }
    return (
      (t.prototype.shouldSample = function (t, n) {
        return {
          decision:
            Sr(n) && this.dt(n) < this.ft
              ? vr.RECORD_AND_SAMPLED
              : vr.NOT_RECORD,
        };
      }),
      (t.prototype.toString = function () {
        return "TraceIdRatioBased{" + this.ut + "}";
      }),
      (t.prototype.ct = function (t) {
        return "number" != typeof t || isNaN(t)
          ? 0
          : t >= 1
            ? 1
            : t <= 0
              ? 0
              : t;
      }),
      (t.prototype.dt = function (t) {
        for (var n = 0, e = 0; e < t.length / 8; e++) {
          var r = 8 * e;
          n = (n ^ parseInt(t.slice(r, r + 8), 16)) >>> 0;
        }
        return n;
      }),
      t
    );
  })(),
  FT = "[object Object]",
  JT = "[object Null]",
  zT = "[object Undefined]",
  QT = Function.prototype.toString,
  $T = QT.call(Object),
  qT =
    ((DT = Object.getPrototypeOf),
    (jT = Object),
    function (t) {
      return DT(jT(t));
    }),
  t_ = Object.prototype,
  n_ = t_.hasOwnProperty,
  e_ = Symbol ? Symbol.toStringTag : void 0,
  r_ = t_.toString;
function o_(t) {
  if (
    !(function (t) {
      return null != t && "object" == typeof t;
    })(t) ||
    (function (t) {
      if (null == t) return void 0 === t ? zT : JT;
      return e_ && e_ in Object(t)
        ? (function (t) {
            var n = n_.call(t, e_),
              e = t[e_],
              r = !1;
            try {
              (t[e_] = void 0), (r = !0);
            } catch (t) {}
            var o = r_.call(t);
            r && (n ? (t[e_] = e) : delete t[e_]);
            return o;
          })(t)
        : (function (t) {
            return r_.call(t);
          })(t);
    })(t) !== FT
  )
    return !1;
  var n = qT(t);
  if (null === n) return !0;
  var e = n_.call(n, "constructor") && n.constructor;
  return "function" == typeof e && e instanceof e && QT.call(e) === $T;
}
var i_ = 20;
function s_(t) {
  return a_(t) ? t.slice() : t;
}
function u_(t, n, e, r) {
  var o;
  if ((void 0 === e && (e = 0), !(e > i_))) {
    if ((e++, d_(t) || d_(n) || l_(n))) o = s_(n);
    else if (a_(t)) {
      if (((o = t.slice()), a_(n)))
        for (var i = 0, s = n.length; i < s; i++) o.push(s_(n[i]));
      else if (f_(n))
        for (i = 0, s = (u = Object.keys(n)).length; i < s; i++) {
          o[(c = u[i])] = s_(n[c]);
        }
    } else if (f_(t))
      if (f_(n)) {
        if (
          !(function (t, n) {
            if (!o_(t) || !o_(n)) return !1;
            return !0;
          })(t, n)
        )
          return n;
        o = Object.assign({}, t);
        var u;
        for (i = 0, s = (u = Object.keys(n)).length; i < s; i++) {
          var c,
            a = n[(c = u[i])];
          if (d_(a)) void 0 === a ? delete o[c] : (o[c] = a);
          else {
            var l = o[c],
              f = a;
            if (c_(t, c, r) || c_(n, c, r)) delete o[c];
            else {
              if (f_(l) && f_(f)) {
                var d = r.get(l) || [],
                  h = r.get(f) || [];
                d.push({ obj: t, key: c }),
                  h.push({ obj: n, key: c }),
                  r.set(l, d),
                  r.set(f, h);
              }
              o[c] = u_(o[c], a, e, r);
            }
          }
        }
      } else o = n;
    return o;
  }
}
function c_(t, n, e) {
  for (var r = e.get(t[n]) || [], o = 0, i = r.length; o < i; o++) {
    var s = r[o];
    if (s.key === n && s.obj === t) return !0;
  }
  return !1;
}
function a_(t) {
  return Array.isArray(t);
}
function l_(t) {
  return "function" == typeof t;
}
function f_(t) {
  return !d_(t) && !a_(t) && !l_(t) && "object" == typeof t;
}
function d_(t) {
  return (
    "string" == typeof t ||
    "number" == typeof t ||
    "boolean" == typeof t ||
    void 0 === t ||
    t instanceof Date ||
    t instanceof RegExp ||
    null === t
  );
}
var h_ = (function () {
    var t = function (n, e) {
      return (
        (t =
          Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array &&
            function (t, n) {
              t.__proto__ = n;
            }) ||
          function (t, n) {
            for (var e in n)
              Object.prototype.hasOwnProperty.call(n, e) && (t[e] = n[e]);
          }),
        t(n, e)
      );
    };
    return function (n, e) {
      if ("function" != typeof e && null !== e)
        throw new TypeError(
          "Class extends value " + String(e) + " is not a constructor or null"
        );
      function r() {
        this.constructor = n;
      }
      t(n, e),
        (n.prototype =
          null === e
            ? Object.create(e)
            : ((r.prototype = e.prototype), new r()));
    };
  })(),
  p_ = (function (t) {
    function n(e) {
      var r = t.call(this, e) || this;
      return Object.setPrototypeOf(r, n.prototype), r;
    }
    return h_(n, t), n;
  })(Error);
var S_ = function (t) {
  var n = "function" == typeof Symbol && Symbol.iterator,
    e = n && t[n],
    r = 0;
  if (e) return e.call(t);
  if (t && "number" == typeof t.length)
    return {
      next: function () {
        return (
          t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t }
        );
      },
    };
  throw new TypeError(
    n ? "Object is not iterable." : "Symbol.iterator is not defined."
  );
};
function E_(t, n) {
  return "string" == typeof n ? t === n : !!t.match(n);
}
var m_ = (function () {
    function t() {
      var t = this;
      this.ht = new Promise(function (n, e) {
        (t.p = n), (t.S = e);
      });
    }
    return (
      Object.defineProperty(t.prototype, "promise", {
        get: function () {
          return this.ht;
        },
        enumerable: !1,
        configurable: !0,
      }),
      (t.prototype.resolve = function (t) {
        this.p(t);
      }),
      (t.prototype.reject = function (t) {
        this.S(t);
      }),
      t
    );
  })(),
  T_ = function (t, n) {
    var e = "function" == typeof Symbol && t[Symbol.iterator];
    if (!e) return t;
    var r,
      o,
      i = e.call(t),
      s = [];
    try {
      for (; (void 0 === n || n-- > 0) && !(r = i.next()).done; )
        s.push(r.value);
    } catch (t) {
      o = { error: t };
    } finally {
      try {
        r && !r.done && (e = i.return) && e.call(i);
      } finally {
        if (o) throw o.error;
      }
    }
    return s;
  },
  __ = function (t, n, e) {
    if (e || 2 === arguments.length)
      for (var r, o = 0, i = n.length; o < i; o++)
        (!r && o in n) ||
          (r || (r = Array.prototype.slice.call(n, 0, o)), (r[o] = n[o]));
    return t.concat(r || Array.prototype.slice.call(n));
  },
  b_ = (function () {
    function t(t, n) {
      (this.St = t), (this.Et = n), (this.Tt = !1), (this._t = new m_());
    }
    return (
      Object.defineProperty(t.prototype, "isCalled", {
        get: function () {
          return this.Tt;
        },
        enumerable: !1,
        configurable: !0,
      }),
      Object.defineProperty(t.prototype, "promise", {
        get: function () {
          return this._t.promise;
        },
        enumerable: !1,
        configurable: !0,
      }),
      (t.prototype.call = function () {
        for (var t, n = this, e = [], r = 0; r < arguments.length; r++)
          e[r] = arguments[r];
        if (!this.Tt) {
          this.Tt = !0;
          try {
            Promise.resolve(
              (t = this.St).call.apply(t, __([this.Et], T_(e), !1))
            ).then(
              function (t) {
                return n._t.resolve(t);
              },
              function (t) {
                return n._t.reject(t);
              }
            );
          } catch (t) {
            this._t.reject(t);
          }
        }
        return this._t.promise;
      }),
      t
    );
  })();
var v_ = {
    bt: function (t, n) {
      return new Promise(function (e) {
        Zr.with(ro(Zr.active()), function () {
          t.export(n, function (t) {
            e(t);
          });
        });
      });
    },
  },
  y_ = Object.freeze({
    __proto__: null,
    AlwaysOffSampler: xT,
    AlwaysOnSampler: kT,
    AnchoredClock: Eo,
    BindOnceFuture: b_,
    CompositePropagator: LT,
    DEFAULT_ATTRIBUTE_COUNT_LIMIT: Po,
    DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT: Zo,
    DEFAULT_ENVIRONMENT: Vo,
    DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT: 128,
    DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT: 128,
    get ExportResultCode() {
      return bT;
    },
    ParentBasedSampler: KT,
    get RPCType() {
      return WT;
    },
    RandomIdGenerator: ko,
    SDK_INFO: _T,
    TRACE_PARENT_HEADER: VT,
    TRACE_STATE_HEADER: GT,
    TimeoutError: p_,
    TraceIdRatioBasedSampler: BT,
    TraceState: PT,
    get TracesSamplerValues() {
      return Ro;
    },
    VERSION: Jo,
    W3CBaggagePropagator: So,
    W3CTraceContextPropagator: YT,
    vt: Do,
    addHrTimes: NT,
    baggageUtils: po,
    callWithTimeout: function (t, n) {
      var e,
        r = new Promise(function (t, r) {
          e = setTimeout(function () {
            r(new p_("Operation timed out."));
          }, n);
        });
      return Promise.race([t, r]).then(
        function (t) {
          return clearTimeout(e), t;
        },
        function (t) {
          throw (clearTimeout(e), t);
        }
      );
    },
    deleteRPCMetadata: function (t) {
      return t.deleteValue(HT);
    },
    getEnv: function () {
      var t = Ho(process.env);
      return Object.assign({}, Vo, t);
    },
    getEnvWithoutDefaults: function () {
      return Ho(process.env);
    },
    getRPCMetadata: function (t) {
      return t.getValue(HT);
    },
    getTimeOrigin: AT,
    globalErrorHandler: Oo,
    hexToBase64: function (t) {
      return Buffer.from(xo(t)).toString("base64");
    },
    hexToBinary: xo,
    hrTime: OT,
    hrTimeDuration: function (t, n) {
      var e = n[0] - t[0],
        r = n[1] - t[1];
      return r < 0 && ((e -= 1), (r += yT)), [e, r];
    },
    hrTimeToMicroseconds: function (t) {
      return 1e6 * t[0] + t[1] / 1e3;
    },
    hrTimeToMilliseconds: function (t) {
      return 1e3 * t[0] + t[1] / 1e6;
    },
    hrTimeToNanoseconds: function (t) {
      return t[0] * yT + t[1];
    },
    hrTimeToTimeStamp: function (t) {
      var n = "" + "0".repeat(9) + t[1] + "Z",
        e = n.substr(n.length - 9 - 1);
      return new Date(1e3 * t[0]).toISOString().replace("000Z", e);
    },
    internal: v_,
    isAttributeKey: _o,
    isAttributeValue: bo,
    isTimeInput: function (t) {
      return gT(t) || "number" == typeof t || t instanceof Date;
    },
    isTimeInputHrTime: gT,
    isTracingSuppressed: oo,
    isUrlIgnored: function (t, n) {
      var e, r;
      if (!n) return !1;
      try {
        for (var o = S_(n), i = o.next(); !i.done; i = o.next()) {
          if (E_(t, i.value)) return !0;
        }
      } catch (t) {
        e = { error: t };
      } finally {
        try {
          i && !i.done && (r = o.return) && r.call(o);
        } finally {
          if (e) throw e.error;
        }
      }
      return !1;
    },
    isWrapped: function (t) {
      return (
        "function" == typeof t &&
        "function" == typeof t.__original &&
        "function" == typeof t.__unwrap &&
        !0 === t.__wrapped
      );
    },
    loggingErrorHandler: yo,
    merge: function () {
      for (var t = [], n = 0; n < arguments.length; n++) t[n] = arguments[n];
      for (var e = t.shift(), r = new WeakMap(); t.length > 0; )
        e = u_(e, t.shift(), 0, r);
      return e;
    },
    millisToHrTime: RT,
    otperformance: Fo,
    parseEnvironment: Ho,
    parseTraceParent: UT,
    sanitizeAttributes: function (t) {
      var n,
        e,
        r = {};
      if ("object" != typeof t || null == t) return r;
      try {
        for (
          var o = mo(Object.entries(t)), i = o.next();
          !i.done;
          i = o.next()
        ) {
          var s = To(i.value, 2),
            u = s[0],
            c = s[1];
          _o(u)
            ? bo(c)
              ? Array.isArray(c)
                ? (r[u] = c.slice())
                : (r[u] = c)
              : Pr.warn("Invalid attribute value set for key: " + u)
            : Pr.warn("Invalid attribute key: " + u);
        }
      } catch (t) {
        n = { error: t };
      } finally {
        try {
          i && !i.done && (e = o.return) && e.call(o);
        } finally {
          if (n) throw n.error;
        }
      }
      return r;
    },
    setGlobalErrorHandler: function (t) {
      Ao = t;
    },
    setRPCMetadata: function (t, n) {
      return t.setValue(HT, n);
    },
    suppressTracing: ro,
    timeInputToHrTime: function (t) {
      if (gT(t)) return t;
      if ("number" == typeof t) return t < AT() ? OT(t) : RT(t);
      if (t instanceof Date) return RT(t.getTime());
      throw TypeError("Invalid input type");
    },
    unrefTimer: function (t) {
      t.unref();
    },
    unsuppressTracing: function (t) {
      return t.deleteValue(eo);
    },
    urlMatches: E_,
  }),
  R_ = Ht(y_),
  A_ = { exports: {} };
var O_ = {
  MAX_LENGTH: 256,
  MAX_SAFE_COMPONENT_LENGTH: 16,
  MAX_SAFE_BUILD_LENGTH: 250,
  MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991,
  RELEASE_TYPES: [
    "major",
    "premajor",
    "minor",
    "preminor",
    "patch",
    "prepatch",
    "prerelease",
  ],
  SEMVER_SPEC_VERSION: "2.0.0",
  FLAG_INCLUDE_PRERELEASE: 1,
  FLAG_LOOSE: 2,
};
var g_ =
  "object" == typeof process &&
  process.env &&
  process.env.NODE_DEBUG &&
  /\bsemver\b/i.test(process.env.NODE_DEBUG)
    ? (...t) => console.error("SEMVER", ...t)
    : () => {};
!(function (t, n) {
  const {
      MAX_SAFE_COMPONENT_LENGTH: e,
      MAX_SAFE_BUILD_LENGTH: r,
      MAX_LENGTH: o,
    } = O_,
    i = g_,
    s = ((n = t.exports = {}).re = []),
    u = (n.safeRe = []),
    c = (n.src = []),
    a = (n.t = {});
  let l = 0;
  const f = "[a-zA-Z0-9-]",
    d = [
      ["\\s", 1],
      ["\\d", o],
      [f, r],
    ],
    h = (t, n, e) => {
      const r = ((t) => {
          for (const [n, e] of d)
            t = t
              .split(`${n}*`)
              .join(`${n}{0,${e}}`)
              .split(`${n}+`)
              .join(`${n}{1,${e}}`);
          return t;
        })(n),
        o = l++;
      i(t, o, n),
        (a[t] = o),
        (c[o] = n),
        (s[o] = new RegExp(n, e ? "g" : void 0)),
        (u[o] = new RegExp(r, e ? "g" : void 0));
    };
  h("NUMERICIDENTIFIER", "0|[1-9]\\d*"),
    h("NUMERICIDENTIFIERLOOSE", "\\d+"),
    h("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${f}*`),
    h(
      "MAINVERSION",
      `(${c[a.NUMERICIDENTIFIER]})\\.(${c[a.NUMERICIDENTIFIER]})\\.(${
        c[a.NUMERICIDENTIFIER]
      })`
    ),
    h(
      "MAINVERSIONLOOSE",
      `(${c[a.NUMERICIDENTIFIERLOOSE]})\\.(${c[a.NUMERICIDENTIFIERLOOSE]})\\.(${
        c[a.NUMERICIDENTIFIERLOOSE]
      })`
    ),
    h(
      "PRERELEASEIDENTIFIER",
      `(?:${c[a.NUMERICIDENTIFIER]}|${c[a.NONNUMERICIDENTIFIER]})`
    ),
    h(
      "PRERELEASEIDENTIFIERLOOSE",
      `(?:${c[a.NUMERICIDENTIFIERLOOSE]}|${c[a.NONNUMERICIDENTIFIER]})`
    ),
    h(
      "PRERELEASE",
      `(?:-(${c[a.PRERELEASEIDENTIFIER]}(?:\\.${c[a.PRERELEASEIDENTIFIER]})*))`
    ),
    h(
      "PRERELEASELOOSE",
      `(?:-?(${c[a.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${
        c[a.PRERELEASEIDENTIFIERLOOSE]
      })*))`
    ),
    h("BUILDIDENTIFIER", `${f}+`),
    h(
      "BUILD",
      `(?:\\+(${c[a.BUILDIDENTIFIER]}(?:\\.${c[a.BUILDIDENTIFIER]})*))`
    ),
    h("FULLPLAIN", `v?${c[a.MAINVERSION]}${c[a.PRERELEASE]}?${c[a.BUILD]}?`),
    h("FULL", `^${c[a.FULLPLAIN]}$`),
    h(
      "LOOSEPLAIN",
      `[v=\\s]*${c[a.MAINVERSIONLOOSE]}${c[a.PRERELEASELOOSE]}?${c[a.BUILD]}?`
    ),
    h("LOOSE", `^${c[a.LOOSEPLAIN]}$`),
    h("GTLT", "((?:<|>)?=?)"),
    h("XRANGEIDENTIFIERLOOSE", `${c[a.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`),
    h("XRANGEIDENTIFIER", `${c[a.NUMERICIDENTIFIER]}|x|X|\\*`),
    h(
      "XRANGEPLAIN",
      `[v=\\s]*(${c[a.XRANGEIDENTIFIER]})(?:\\.(${
        c[a.XRANGEIDENTIFIER]
      })(?:\\.(${c[a.XRANGEIDENTIFIER]})(?:${c[a.PRERELEASE]})?${
        c[a.BUILD]
      }?)?)?`
    ),
    h(
      "XRANGEPLAINLOOSE",
      `[v=\\s]*(${c[a.XRANGEIDENTIFIERLOOSE]})(?:\\.(${
        c[a.XRANGEIDENTIFIERLOOSE]
      })(?:\\.(${c[a.XRANGEIDENTIFIERLOOSE]})(?:${c[a.PRERELEASELOOSE]})?${
        c[a.BUILD]
      }?)?)?`
    ),
    h("XRANGE", `^${c[a.GTLT]}\\s*${c[a.XRANGEPLAIN]}$`),
    h("XRANGELOOSE", `^${c[a.GTLT]}\\s*${c[a.XRANGEPLAINLOOSE]}$`),
    h(
      "COERCE",
      `(^|[^\\d])(\\d{1,${e}})(?:\\.(\\d{1,${e}}))?(?:\\.(\\d{1,${e}}))?(?:$|[^\\d])`
    ),
    h("COERCERTL", c[a.COERCE], !0),
    h("LONETILDE", "(?:~>?)"),
    h("TILDETRIM", `(\\s*)${c[a.LONETILDE]}\\s+`, !0),
    (n.tildeTrimReplace = "$1~"),
    h("TILDE", `^${c[a.LONETILDE]}${c[a.XRANGEPLAIN]}$`),
    h("TILDELOOSE", `^${c[a.LONETILDE]}${c[a.XRANGEPLAINLOOSE]}$`),
    h("LONECARET", "(?:\\^)"),
    h("CARETTRIM", `(\\s*)${c[a.LONECARET]}\\s+`, !0),
    (n.caretTrimReplace = "$1^"),
    h("CARET", `^${c[a.LONECARET]}${c[a.XRANGEPLAIN]}$`),
    h("CARETLOOSE", `^${c[a.LONECARET]}${c[a.XRANGEPLAINLOOSE]}$`),
    h("COMPARATORLOOSE", `^${c[a.GTLT]}\\s*(${c[a.LOOSEPLAIN]})$|^$`),
    h("COMPARATOR", `^${c[a.GTLT]}\\s*(${c[a.FULLPLAIN]})$|^$`),
    h(
      "COMPARATORTRIM",
      `(\\s*)${c[a.GTLT]}\\s*(${c[a.LOOSEPLAIN]}|${c[a.XRANGEPLAIN]})`,
      !0
    ),
    (n.comparatorTrimReplace = "$1$2$3"),
    h(
      "HYPHENRANGE",
      `^\\s*(${c[a.XRANGEPLAIN]})\\s+-\\s+(${c[a.XRANGEPLAIN]})\\s*$`
    ),
    h(
      "HYPHENRANGELOOSE",
      `^\\s*(${c[a.XRANGEPLAINLOOSE]})\\s+-\\s+(${c[a.XRANGEPLAINLOOSE]})\\s*$`
    ),
    h("STAR", "(<|>)?=?\\s*\\*"),
    h("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"),
    h("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
})(A_, A_.exports);
var N_ = A_.exports;
const C_ = Object.freeze({ loose: !0 }),
  L_ = Object.freeze({});
var I_ = (t) => (t ? ("object" != typeof t ? C_ : t) : L_);
const M_ = /^[0-9]+$/,
  w_ = (t, n) => {
    const e = M_.test(t),
      r = M_.test(n);
    return (
      e && r && ((t = +t), (n = +n)),
      t === n ? 0 : e && !r ? -1 : r && !e ? 1 : t < n ? -1 : 1
    );
  };
var Z_ = { compareIdentifiers: w_, rcompareIdentifiers: (t, n) => w_(n, t) };
const P_ = g_,
  { MAX_LENGTH: V_, MAX_SAFE_INTEGER: G_ } = O_,
  { safeRe: X_, t: U_ } = N_,
  W_ = I_,
  { compareIdentifiers: Y_ } = Z_;
var H_ = class t {
  constructor(n, e) {
    if (((e = W_(e)), n instanceof t)) {
      if (
        n.loose === !!e.loose &&
        n.includePrerelease === !!e.includePrerelease
      )
        return n;
      n = n.version;
    } else if ("string" != typeof n)
      throw new TypeError(
        `Invalid version. Must be a string. Got type "${typeof n}".`
      );
    if (n.length > V_)
      throw new TypeError(`version is longer than ${V_} characters`);
    P_("SemVer", n, e),
      (this.options = e),
      (this.loose = !!e.loose),
      (this.includePrerelease = !!e.includePrerelease);
    const r = n.trim().match(e.loose ? X_[U_.LOOSE] : X_[U_.FULL]);
    if (!r) throw new TypeError(`Invalid Version: ${n}`);
    if (
      ((this.raw = n),
      (this.major = +r[1]),
      (this.minor = +r[2]),
      (this.patch = +r[3]),
      this.major > G_ || this.major < 0)
    )
      throw new TypeError("Invalid major version");
    if (this.minor > G_ || this.minor < 0)
      throw new TypeError("Invalid minor version");
    if (this.patch > G_ || this.patch < 0)
      throw new TypeError("Invalid patch version");
    r[4]
      ? (this.prerelease = r[4].split(".").map((t) => {
          if (/^[0-9]+$/.test(t)) {
            const n = +t;
            if (n >= 0 && n < G_) return n;
          }
          return t;
        }))
      : (this.prerelease = []),
      (this.build = r[5] ? r[5].split(".") : []),
      this.format();
  }
  format() {
    return (
      (this.version = `${this.major}.${this.minor}.${this.patch}`),
      this.prerelease.length &&
        (this.version += `-${this.prerelease.join(".")}`),
      this.version
    );
  }
  toString() {
    return this.version;
  }
  compare(n) {
    if (
      (P_("SemVer.compare", this.version, this.options, n), !(n instanceof t))
    ) {
      if ("string" == typeof n && n === this.version) return 0;
      n = new t(n, this.options);
    }
    return n.version === this.version
      ? 0
      : this.compareMain(n) || this.comparePre(n);
  }
  compareMain(n) {
    return (
      n instanceof t || (n = new t(n, this.options)),
      Y_(this.major, n.major) ||
        Y_(this.minor, n.minor) ||
        Y_(this.patch, n.patch)
    );
  }
  comparePre(n) {
    if (
      (n instanceof t || (n = new t(n, this.options)),
      this.prerelease.length && !n.prerelease.length)
    )
      return -1;
    if (!this.prerelease.length && n.prerelease.length) return 1;
    if (!this.prerelease.length && !n.prerelease.length) return 0;
    let e = 0;
    do {
      const t = this.prerelease[e],
        r = n.prerelease[e];
      if ((P_("prerelease compare", e, t, r), void 0 === t && void 0 === r))
        return 0;
      if (void 0 === r) return 1;
      if (void 0 === t) return -1;
      if (t !== r) return Y_(t, r);
    } while (++e);
  }
  compareBuild(n) {
    n instanceof t || (n = new t(n, this.options));
    let e = 0;
    do {
      const t = this.build[e],
        r = n.build[e];
      if ((P_("prerelease compare", e, t, r), void 0 === t && void 0 === r))
        return 0;
      if (void 0 === r) return 1;
      if (void 0 === t) return -1;
      if (t !== r) return Y_(t, r);
    } while (++e);
  }
  inc(t, n, e) {
    switch (t) {
      case "premajor":
        (this.prerelease.length = 0),
          (this.patch = 0),
          (this.minor = 0),
          this.major++,
          this.inc("pre", n, e);
        break;
      case "preminor":
        (this.prerelease.length = 0),
          (this.patch = 0),
          this.minor++,
          this.inc("pre", n, e);
        break;
      case "prepatch":
        (this.prerelease.length = 0),
          this.inc("patch", n, e),
          this.inc("pre", n, e);
        break;
      case "prerelease":
        0 === this.prerelease.length && this.inc("patch", n, e),
          this.inc("pre", n, e);
        break;
      case "major":
        (0 === this.minor &&
          0 === this.patch &&
          0 !== this.prerelease.length) ||
          this.major++,
          (this.minor = 0),
          (this.patch = 0),
          (this.prerelease = []);
        break;
      case "minor":
        (0 === this.patch && 0 !== this.prerelease.length) || this.minor++,
          (this.patch = 0),
          (this.prerelease = []);
        break;
      case "patch":
        0 === this.prerelease.length && this.patch++, (this.prerelease = []);
        break;
      case "pre": {
        const t = Number(e) ? 1 : 0;
        if (!n && !1 === e)
          throw new Error("invalid increment argument: identifier is empty");
        if (0 === this.prerelease.length) this.prerelease = [t];
        else {
          let r = this.prerelease.length;
          for (; --r >= 0; )
            "number" == typeof this.prerelease[r] &&
              (this.prerelease[r]++, (r = -2));
          if (-1 === r) {
            if (n === this.prerelease.join(".") && !1 === e)
              throw new Error(
                "invalid increment argument: identifier already exists"
              );
            this.prerelease.push(t);
          }
        }
        if (n) {
          let r = [n, t];
          !1 === e && (r = [n]),
            0 === Y_(this.prerelease[0], n)
              ? isNaN(this.prerelease[1]) && (this.prerelease = r)
              : (this.prerelease = r);
        }
        break;
      }
      default:
        throw new Error(`invalid increment argument: ${t}`);
    }
    return (
      (this.raw = this.format()),
      this.build.length && (this.raw += `+${this.build.join(".")}`),
      this
    );
  }
};
const D_ = H_;
var j_ = (t, n, e = !1) => {
  if (t instanceof D_) return t;
  try {
    return new D_(t, n);
  } catch (t) {
    if (!e) return null;
    throw t;
  }
};
const x_ = j_;
var k_ = (t, n) => {
  const e = x_(t, n);
  return e ? e.version : null;
};
const K_ = j_;
var B_ = (t, n) => {
  const e = K_(t.trim().replace(/^[=v]+/, ""), n);
  return e ? e.version : null;
};
const F_ = H_;
var J_ = (t, n, e, r, o) => {
  "string" == typeof e && ((o = r), (r = e), (e = void 0));
  try {
    return new F_(t instanceof F_ ? t.version : t, e).inc(n, r, o).version;
  } catch (t) {
    return null;
  }
};
const z_ = j_;
var Q_ = (t, n) => {
  const e = z_(t, null, !0),
    r = z_(n, null, !0),
    o = e.compare(r);
  if (0 === o) return null;
  const i = o > 0,
    s = i ? e : r,
    u = i ? r : e,
    c = !!s.prerelease.length;
  if (!!u.prerelease.length && !c)
    return u.patch || u.minor
      ? s.patch
        ? "patch"
        : s.minor
          ? "minor"
          : "major"
      : "major";
  const a = c ? "pre" : "";
  return e.major !== r.major
    ? a + "major"
    : e.minor !== r.minor
      ? a + "minor"
      : e.patch !== r.patch
        ? a + "patch"
        : "prerelease";
};
const $_ = H_;
var q_ = (t, n) => new $_(t, n).major;
const tb = H_;
var nb = (t, n) => new tb(t, n).minor;
const eb = H_;
var rb = (t, n) => new eb(t, n).patch;
const ob = j_;
var ib = (t, n) => {
  const e = ob(t, n);
  return e && e.prerelease.length ? e.prerelease : null;
};
const sb = H_;
var ub = (t, n, e) => new sb(t, e).compare(new sb(n, e));
const cb = ub;
var ab = (t, n, e) => cb(n, t, e);
const lb = ub;
var fb = (t, n) => lb(t, n, !0);
const db = H_;
var hb = (t, n, e) => {
  const r = new db(t, e),
    o = new db(n, e);
  return r.compare(o) || r.compareBuild(o);
};
const pb = hb;
var Sb = (t, n) => t.sort((t, e) => pb(t, e, n));
const Eb = hb;
var mb = (t, n) => t.sort((t, e) => Eb(e, t, n));
const Tb = ub;
var _b = (t, n, e) => Tb(t, n, e) > 0;
const bb = ub;
var vb = (t, n, e) => bb(t, n, e) < 0;
const yb = ub;
var Rb = (t, n, e) => 0 === yb(t, n, e);
const Ab = ub;
var Ob = (t, n, e) => 0 !== Ab(t, n, e);
const gb = ub;
var Nb = (t, n, e) => gb(t, n, e) >= 0;
const Cb = ub;
var Lb = (t, n, e) => Cb(t, n, e) <= 0;
const Ib = Rb,
  Mb = Ob,
  wb = _b,
  Zb = Nb,
  Pb = vb,
  Vb = Lb;
var Gb = (t, n, e, r) => {
  switch (n) {
    case "===":
      return (
        "object" == typeof t && (t = t.version),
        "object" == typeof e && (e = e.version),
        t === e
      );
    case "!==":
      return (
        "object" == typeof t && (t = t.version),
        "object" == typeof e && (e = e.version),
        t !== e
      );
    case "":
    case "=":
    case "==":
      return Ib(t, e, r);
    case "!=":
      return Mb(t, e, r);
    case ">":
      return wb(t, e, r);
    case ">=":
      return Zb(t, e, r);
    case "<":
      return Pb(t, e, r);
    case "<=":
      return Vb(t, e, r);
    default:
      throw new TypeError(`Invalid operator: ${n}`);
  }
};
const Xb = H_,
  Ub = j_,
  { safeRe: Wb, t: Yb } = N_;
var Hb,
  Db,
  jb,
  xb,
  kb,
  Kb,
  Bb,
  Fb,
  Jb,
  zb,
  Qb = (t, n) => {
    if (t instanceof Xb) return t;
    if (("number" == typeof t && (t = String(t)), "string" != typeof t))
      return null;
    let e = null;
    if ((n = n || {}).rtl) {
      let n;
      for (
        ;
        (n = Wb[Yb.COERCERTL].exec(t)) &&
        (!e || e.index + e[0].length !== t.length);

      )
        (e && n.index + n[0].length === e.index + e[0].length) || (e = n),
          (Wb[Yb.COERCERTL].lastIndex = n.index + n[1].length + n[2].length);
      Wb[Yb.COERCERTL].lastIndex = -1;
    } else e = t.match(Wb[Yb.COERCE]);
    return null === e ? null : Ub(`${e[2]}.${e[3] || "0"}.${e[4] || "0"}`, n);
  };
function $b() {
  if (xb) return jb;
  function t(n) {
    var e = this;
    if (
      (e instanceof t || (e = new t()),
      (e.tail = null),
      (e.head = null),
      (e.length = 0),
      n && "function" == typeof n.forEach)
    )
      n.forEach(function (t) {
        e.push(t);
      });
    else if (arguments.length > 0)
      for (var r = 0, o = arguments.length; r < o; r++) e.push(arguments[r]);
    return e;
  }
  function n(t, n, e) {
    var r = n === t.head ? new o(e, null, n, t) : new o(e, n, n.next, t);
    return (
      null === r.next && (t.tail = r),
      null === r.prev && (t.head = r),
      t.length++,
      r
    );
  }
  function e(t, n) {
    (t.tail = new o(n, t.tail, null, t)),
      t.head || (t.head = t.tail),
      t.length++;
  }
  function r(t, n) {
    (t.head = new o(n, null, t.head, t)),
      t.tail || (t.tail = t.head),
      t.length++;
  }
  function o(t, n, e, r) {
    if (!(this instanceof o)) return new o(t, n, e, r);
    (this.list = r),
      (this.value = t),
      n ? ((n.next = this), (this.prev = n)) : (this.prev = null),
      e ? ((e.prev = this), (this.next = e)) : (this.next = null);
  }
  (xb = 1),
    (jb = t),
    (t.Node = o),
    (t.create = t),
    (t.prototype.removeNode = function (t) {
      if (t.list !== this)
        throw new Error("removing node which does not belong to this list");
      var n = t.next,
        e = t.prev;
      return (
        n && (n.prev = e),
        e && (e.next = n),
        t === this.head && (this.head = n),
        t === this.tail && (this.tail = e),
        t.list.length--,
        (t.next = null),
        (t.prev = null),
        (t.list = null),
        n
      );
    }),
    (t.prototype.unshiftNode = function (t) {
      if (t !== this.head) {
        t.list && t.list.removeNode(t);
        var n = this.head;
        (t.list = this),
          (t.next = n),
          n && (n.prev = t),
          (this.head = t),
          this.tail || (this.tail = t),
          this.length++;
      }
    }),
    (t.prototype.pushNode = function (t) {
      if (t !== this.tail) {
        t.list && t.list.removeNode(t);
        var n = this.tail;
        (t.list = this),
          (t.prev = n),
          n && (n.next = t),
          (this.tail = t),
          this.head || (this.head = t),
          this.length++;
      }
    }),
    (t.prototype.push = function () {
      for (var t = 0, n = arguments.length; t < n; t++) e(this, arguments[t]);
      return this.length;
    }),
    (t.prototype.unshift = function () {
      for (var t = 0, n = arguments.length; t < n; t++) r(this, arguments[t]);
      return this.length;
    }),
    (t.prototype.pop = function () {
      if (this.tail) {
        var t = this.tail.value;
        return (
          (this.tail = this.tail.prev),
          this.tail ? (this.tail.next = null) : (this.head = null),
          this.length--,
          t
        );
      }
    }),
    (t.prototype.shift = function () {
      if (this.head) {
        var t = this.head.value;
        return (
          (this.head = this.head.next),
          this.head ? (this.head.prev = null) : (this.tail = null),
          this.length--,
          t
        );
      }
    }),
    (t.prototype.forEach = function (t, n) {
      n = n || this;
      for (var e = this.head, r = 0; null !== e; r++)
        t.call(n, e.value, r, this), (e = e.next);
    }),
    (t.prototype.forEachReverse = function (t, n) {
      n = n || this;
      for (var e = this.tail, r = this.length - 1; null !== e; r--)
        t.call(n, e.value, r, this), (e = e.prev);
    }),
    (t.prototype.get = function (t) {
      for (var n = 0, e = this.head; null !== e && n < t; n++) e = e.next;
      if (n === t && null !== e) return e.value;
    }),
    (t.prototype.getReverse = function (t) {
      for (var n = 0, e = this.tail; null !== e && n < t; n++) e = e.prev;
      if (n === t && null !== e) return e.value;
    }),
    (t.prototype.map = function (n, e) {
      e = e || this;
      for (var r = new t(), o = this.head; null !== o; )
        r.push(n.call(e, o.value, this)), (o = o.next);
      return r;
    }),
    (t.prototype.mapReverse = function (n, e) {
      e = e || this;
      for (var r = new t(), o = this.tail; null !== o; )
        r.push(n.call(e, o.value, this)), (o = o.prev);
      return r;
    }),
    (t.prototype.reduce = function (t, n) {
      var e,
        r = this.head;
      if (arguments.length > 1) e = n;
      else {
        if (!this.head)
          throw new TypeError("Reduce of empty list with no initial value");
        (r = this.head.next), (e = this.head.value);
      }
      for (var o = 0; null !== r; o++) (e = t(e, r.value, o)), (r = r.next);
      return e;
    }),
    (t.prototype.reduceReverse = function (t, n) {
      var e,
        r = this.tail;
      if (arguments.length > 1) e = n;
      else {
        if (!this.tail)
          throw new TypeError("Reduce of empty list with no initial value");
        (r = this.tail.prev), (e = this.tail.value);
      }
      for (var o = this.length - 1; null !== r; o--)
        (e = t(e, r.value, o)), (r = r.prev);
      return e;
    }),
    (t.prototype.toArray = function () {
      for (
        var t = new Array(this.length), n = 0, e = this.head;
        null !== e;
        n++
      )
        (t[n] = e.value), (e = e.next);
      return t;
    }),
    (t.prototype.toArrayReverse = function () {
      for (
        var t = new Array(this.length), n = 0, e = this.tail;
        null !== e;
        n++
      )
        (t[n] = e.value), (e = e.prev);
      return t;
    }),
    (t.prototype.slice = function (n, e) {
      (e = e || this.length) < 0 && (e += this.length),
        (n = n || 0) < 0 && (n += this.length);
      var r = new t();
      if (e < n || e < 0) return r;
      n < 0 && (n = 0), e > this.length && (e = this.length);
      for (var o = 0, i = this.head; null !== i && o < n; o++) i = i.next;
      for (; null !== i && o < e; o++, i = i.next) r.push(i.value);
      return r;
    }),
    (t.prototype.sliceReverse = function (n, e) {
      (e = e || this.length) < 0 && (e += this.length),
        (n = n || 0) < 0 && (n += this.length);
      var r = new t();
      if (e < n || e < 0) return r;
      n < 0 && (n = 0), e > this.length && (e = this.length);
      for (var o = this.length, i = this.tail; null !== i && o > e; o--)
        i = i.prev;
      for (; null !== i && o > n; o--, i = i.prev) r.push(i.value);
      return r;
    }),
    (t.prototype.splice = function (t, e, ...r) {
      t > this.length && (t = this.length - 1), t < 0 && (t = this.length + t);
      for (var o = 0, i = this.head; null !== i && o < t; o++) i = i.next;
      var s = [];
      for (o = 0; i && o < e; o++) s.push(i.value), (i = this.removeNode(i));
      null === i && (i = this.tail),
        i !== this.head && i !== this.tail && (i = i.prev);
      for (o = 0; o < r.length; o++) i = n(this, i, r[o]);
      return s;
    }),
    (t.prototype.reverse = function () {
      for (var t = this.head, n = this.tail, e = t; null !== e; e = e.prev) {
        var r = e.prev;
        (e.prev = e.next), (e.next = r);
      }
      return (this.head = n), (this.tail = t), this;
    });
  try {
    (Db
      ? Hb
      : ((Db = 1),
        (Hb = function (t) {
          t.prototype[Symbol.iterator] = function* () {
            for (let t = this.head; t; t = t.next) yield t.value;
          };
        })))(t);
  } catch (t) {}
  return jb;
}
function qb() {
  if (Fb) return Bb;
  Fb = 1;
  class t {
    constructor(n, e) {
      if (((e = r(e)), n instanceof t))
        return n.loose === !!e.loose &&
          n.includePrerelease === !!e.includePrerelease
          ? n
          : new t(n.raw, e);
      if (n instanceof o)
        return (this.raw = n.value), (this.set = [[n]]), this.format(), this;
      if (
        ((this.options = e),
        (this.loose = !!e.loose),
        (this.includePrerelease = !!e.includePrerelease),
        (this.raw = n.trim().split(/\s+/).join(" ")),
        (this.set = this.raw
          .split("||")
          .map((t) => this.parseRange(t.trim()))
          .filter((t) => t.length)),
        !this.set.length)
      )
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      if (this.set.length > 1) {
        const t = this.set[0];
        if (
          ((this.set = this.set.filter((t) => !p(t[0]))), 0 === this.set.length)
        )
          this.set = [t];
        else if (this.set.length > 1)
          for (const t of this.set)
            if (1 === t.length && S(t[0])) {
              this.set = [t];
              break;
            }
      }
      this.format();
    }
    format() {
      return (
        (this.range = this.set
          .map((t) => t.join(" ").trim())
          .join("||")
          .trim()),
        this.range
      );
    }
    toString() {
      return this.range;
    }
    parseRange(t) {
      const n =
          ((this.options.includePrerelease && d) | (this.options.loose && h)) +
          ":" +
          t,
        r = e.get(n);
      if (r) return r;
      const s = this.options.loose,
        S = s ? u[c.HYPHENRANGELOOSE] : u[c.HYPHENRANGE];
      (t = t.replace(S, N(this.options.includePrerelease))),
        i("hyphen replace", t),
        (t = t.replace(u[c.COMPARATORTRIM], a)),
        i("comparator trim", t),
        (t = t.replace(u[c.TILDETRIM], l)),
        i("tilde trim", t),
        (t = t.replace(u[c.CARETTRIM], f)),
        i("caret trim", t);
      let E = t
        .split(" ")
        .map((t) => m(t, this.options))
        .join(" ")
        .split(/\s+/)
        .map((t) => g(t, this.options));
      s &&
        (E = E.filter(
          (t) => (
            i("loose invalid filter", t, this.options),
            !!t.match(u[c.COMPARATORLOOSE])
          )
        )),
        i("range list", E);
      const T = new Map(),
        _ = E.map((t) => new o(t, this.options));
      for (const t of _) {
        if (p(t)) return [t];
        T.set(t.value, t);
      }
      T.size > 1 && T.has("") && T.delete("");
      const b = [...T.values()];
      return e.set(n, b), b;
    }
    intersects(n, e) {
      if (!(n instanceof t)) throw new TypeError("a Range is required");
      return this.set.some(
        (t) =>
          E(t, e) &&
          n.set.some(
            (n) => E(n, e) && t.every((t) => n.every((n) => t.intersects(n, e)))
          )
      );
    }
    test(t) {
      if (!t) return !1;
      if ("string" == typeof t)
        try {
          t = new s(t, this.options);
        } catch (t) {
          return !1;
        }
      for (let n = 0; n < this.set.length; n++)
        if (C(this.set[n], t, this.options)) return !0;
      return !1;
    }
  }
  Bb = t;
  const n = (function () {
      if (Kb) return kb;
      Kb = 1;
      const t = $b(),
        n = Symbol("max"),
        e = Symbol("length"),
        r = Symbol("lengthCalculator"),
        o = Symbol("allowStale"),
        i = Symbol("maxAge"),
        s = Symbol("dispose"),
        u = Symbol("noDisposeOnSet"),
        c = Symbol("lruList"),
        a = Symbol("cache"),
        l = Symbol("updateAgeOnGet"),
        f = () => 1,
        d = (t, n, e) => {
          const r = t[a].get(n);
          if (r) {
            const n = r.value;
            if (h(t, n)) {
              if ((S(t, r), !t[o])) return;
            } else
              e && (t[l] && (r.value.now = Date.now()), t[c].unshiftNode(r));
            return n.value;
          }
        },
        h = (t, n) => {
          if (!n || (!n.maxAge && !t[i])) return !1;
          const e = Date.now() - n.now;
          return n.maxAge ? e > n.maxAge : t[i] && e > t[i];
        },
        p = (t) => {
          if (t[e] > t[n])
            for (let r = t[c].tail; t[e] > t[n] && null !== r; ) {
              const n = r.prev;
              S(t, r), (r = n);
            }
        },
        S = (t, n) => {
          if (n) {
            const r = n.value;
            t[s] && t[s](r.key, r.value),
              (t[e] -= r.length),
              t[a].delete(r.key),
              t[c].removeNode(n);
          }
        };
      class E {
        constructor(t, n, e, r, o) {
          (this.key = t),
            (this.value = n),
            (this.length = e),
            (this.now = r),
            (this.maxAge = o || 0);
        }
      }
      const m = (t, n, e, r) => {
        let i = e.value;
        h(t, i) && (S(t, e), t[o] || (i = void 0)),
          i && n.call(r, i.value, i.key, t);
      };
      return (
        (kb = class {
          constructor(t) {
            if (
              ("number" == typeof t && (t = { max: t }),
              t || (t = {}),
              t.max && ("number" != typeof t.max || t.max < 0))
            )
              throw new TypeError("max must be a non-negative number");
            this[n] = t.max || 1 / 0;
            const e = t.length || f;
            if (
              ((this[r] = "function" != typeof e ? f : e),
              (this[o] = t.stale || !1),
              t.maxAge && "number" != typeof t.maxAge)
            )
              throw new TypeError("maxAge must be a number");
            (this[i] = t.maxAge || 0),
              (this[s] = t.dispose),
              (this[u] = t.noDisposeOnSet || !1),
              (this[l] = t.updateAgeOnGet || !1),
              this.reset();
          }
          set max(t) {
            if ("number" != typeof t || t < 0)
              throw new TypeError("max must be a non-negative number");
            (this[n] = t || 1 / 0), p(this);
          }
          get max() {
            return this[n];
          }
          set allowStale(t) {
            this[o] = !!t;
          }
          get allowStale() {
            return this[o];
          }
          set maxAge(t) {
            if ("number" != typeof t)
              throw new TypeError("maxAge must be a non-negative number");
            (this[i] = t), p(this);
          }
          get maxAge() {
            return this[i];
          }
          set lengthCalculator(t) {
            "function" != typeof t && (t = f),
              t !== this[r] &&
                ((this[r] = t),
                (this[e] = 0),
                this[c].forEach((t) => {
                  (t.length = this[r](t.value, t.key)), (this[e] += t.length);
                })),
              p(this);
          }
          get lengthCalculator() {
            return this[r];
          }
          get length() {
            return this[e];
          }
          get itemCount() {
            return this[c].length;
          }
          rforEach(t, n) {
            n = n || this;
            for (let e = this[c].tail; null !== e; ) {
              const r = e.prev;
              m(this, t, e, n), (e = r);
            }
          }
          forEach(t, n) {
            n = n || this;
            for (let e = this[c].head; null !== e; ) {
              const r = e.next;
              m(this, t, e, n), (e = r);
            }
          }
          keys() {
            return this[c].toArray().map((t) => t.key);
          }
          values() {
            return this[c].toArray().map((t) => t.value);
          }
          reset() {
            this[s] &&
              this[c] &&
              this[c].length &&
              this[c].forEach((t) => this[s](t.key, t.value)),
              (this[a] = new Map()),
              (this[c] = new t()),
              (this[e] = 0);
          }
          dump() {
            return this[c]
              .map(
                (t) =>
                  !h(this, t) && {
                    k: t.key,
                    v: t.value,
                    e: t.now + (t.maxAge || 0),
                  }
              )
              .toArray()
              .filter((t) => t);
          }
          dumpLru() {
            return this[c];
          }
          set(t, o, l) {
            if ((l = l || this[i]) && "number" != typeof l)
              throw new TypeError("maxAge must be a number");
            const f = l ? Date.now() : 0,
              d = this[r](o, t);
            if (this[a].has(t)) {
              if (d > this[n]) return S(this, this[a].get(t)), !1;
              const r = this[a].get(t).value;
              return (
                this[s] && (this[u] || this[s](t, r.value)),
                (r.now = f),
                (r.maxAge = l),
                (r.value = o),
                (this[e] += d - r.length),
                (r.length = d),
                this.get(t),
                p(this),
                !0
              );
            }
            const h = new E(t, o, d, f, l);
            return h.length > this[n]
              ? (this[s] && this[s](t, o), !1)
              : ((this[e] += h.length),
                this[c].unshift(h),
                this[a].set(t, this[c].head),
                p(this),
                !0);
          }
          has(t) {
            if (!this[a].has(t)) return !1;
            const n = this[a].get(t).value;
            return !h(this, n);
          }
          get(t) {
            return d(this, t, !0);
          }
          peek(t) {
            return d(this, t, !1);
          }
          pop() {
            const t = this[c].tail;
            return t ? (S(this, t), t.value) : null;
          }
          del(t) {
            S(this, this[a].get(t));
          }
          load(t) {
            this.reset();
            const n = Date.now();
            for (let e = t.length - 1; e >= 0; e--) {
              const r = t[e],
                o = r.e || 0;
              if (0 === o) this.set(r.k, r.v);
              else {
                const t = o - n;
                t > 0 && this.set(r.k, r.v, t);
              }
            }
          }
          prune() {
            this[a].forEach((t, n) => d(this, n, !1));
          }
        }),
        kb
      );
    })(),
    e = new n({ max: 1e3 }),
    r = I_,
    o = tv(),
    i = g_,
    s = H_,
    {
      safeRe: u,
      t: c,
      comparatorTrimReplace: a,
      tildeTrimReplace: l,
      caretTrimReplace: f,
    } = N_,
    { FLAG_INCLUDE_PRERELEASE: d, FLAG_LOOSE: h } = O_,
    p = (t) => "<0.0.0-0" === t.value,
    S = (t) => "" === t.value,
    E = (t, n) => {
      let e = !0;
      const r = t.slice();
      let o = r.pop();
      for (; e && r.length; )
        (e = r.every((t) => o.intersects(t, n))), (o = r.pop());
      return e;
    },
    m = (t, n) => (
      i("comp", t, n),
      (t = v(t, n)),
      i("caret", t),
      (t = _(t, n)),
      i("tildes", t),
      (t = R(t, n)),
      i("xrange", t),
      (t = O(t, n)),
      i("stars", t),
      t
    ),
    T = (t) => !t || "x" === t.toLowerCase() || "*" === t,
    _ = (t, n) =>
      t
        .trim()
        .split(/\s+/)
        .map((t) => b(t, n))
        .join(" "),
    b = (t, n) => {
      const e = n.loose ? u[c.TILDELOOSE] : u[c.TILDE];
      return t.replace(e, (n, e, r, o, s) => {
        let u;
        return (
          i("tilde", t, n, e, r, o, s),
          T(e)
            ? (u = "")
            : T(r)
              ? (u = `>=${e}.0.0 <${+e + 1}.0.0-0`)
              : T(o)
                ? (u = `>=${e}.${r}.0 <${e}.${+r + 1}.0-0`)
                : s
                  ? (i("replaceTilde pr", s),
                    (u = `>=${e}.${r}.${o}-${s} <${e}.${+r + 1}.0-0`))
                  : (u = `>=${e}.${r}.${o} <${e}.${+r + 1}.0-0`),
          i("tilde return", u),
          u
        );
      });
    },
    v = (t, n) =>
      t
        .trim()
        .split(/\s+/)
        .map((t) => y(t, n))
        .join(" "),
    y = (t, n) => {
      i("caret", t, n);
      const e = n.loose ? u[c.CARETLOOSE] : u[c.CARET],
        r = n.includePrerelease ? "-0" : "";
      return t.replace(e, (n, e, o, s, u) => {
        let c;
        return (
          i("caret", t, n, e, o, s, u),
          T(e)
            ? (c = "")
            : T(o)
              ? (c = `>=${e}.0.0${r} <${+e + 1}.0.0-0`)
              : T(s)
                ? (c =
                    "0" === e
                      ? `>=${e}.${o}.0${r} <${e}.${+o + 1}.0-0`
                      : `>=${e}.${o}.0${r} <${+e + 1}.0.0-0`)
                : u
                  ? (i("replaceCaret pr", u),
                    (c =
                      "0" === e
                        ? "0" === o
                          ? `>=${e}.${o}.${s}-${u} <${e}.${o}.${+s + 1}-0`
                          : `>=${e}.${o}.${s}-${u} <${e}.${+o + 1}.0-0`
                        : `>=${e}.${o}.${s}-${u} <${+e + 1}.0.0-0`))
                  : (i("no pr"),
                    (c =
                      "0" === e
                        ? "0" === o
                          ? `>=${e}.${o}.${s}${r} <${e}.${o}.${+s + 1}-0`
                          : `>=${e}.${o}.${s}${r} <${e}.${+o + 1}.0-0`
                        : `>=${e}.${o}.${s} <${+e + 1}.0.0-0`)),
          i("caret return", c),
          c
        );
      });
    },
    R = (t, n) => (
      i("replaceXRanges", t, n),
      t
        .split(/\s+/)
        .map((t) => A(t, n))
        .join(" ")
    ),
    A = (t, n) => {
      t = t.trim();
      const e = n.loose ? u[c.XRANGELOOSE] : u[c.XRANGE];
      return t.replace(e, (e, r, o, s, u, c) => {
        i("xRange", t, e, r, o, s, u, c);
        const a = T(o),
          l = a || T(s),
          f = l || T(u),
          d = f;
        return (
          "=" === r && d && (r = ""),
          (c = n.includePrerelease ? "-0" : ""),
          a
            ? (e = ">" === r || "<" === r ? "<0.0.0-0" : "*")
            : r && d
              ? (l && (s = 0),
                (u = 0),
                ">" === r
                  ? ((r = ">="),
                    l
                      ? ((o = +o + 1), (s = 0), (u = 0))
                      : ((s = +s + 1), (u = 0)))
                  : "<=" === r && ((r = "<"), l ? (o = +o + 1) : (s = +s + 1)),
                "<" === r && (c = "-0"),
                (e = `${r + o}.${s}.${u}${c}`))
              : l
                ? (e = `>=${o}.0.0${c} <${+o + 1}.0.0-0`)
                : f && (e = `>=${o}.${s}.0${c} <${o}.${+s + 1}.0-0`),
          i("xRange return", e),
          e
        );
      });
    },
    O = (t, n) => (i("replaceStars", t, n), t.trim().replace(u[c.STAR], "")),
    g = (t, n) => (
      i("replaceGTE0", t, n),
      t.trim().replace(u[n.includePrerelease ? c.GTE0PRE : c.GTE0], "")
    ),
    N = (t) => (n, e, r, o, i, s, u, c, a, l, f, d, h) =>
      `${(e = T(r)
        ? ""
        : T(o)
          ? `>=${r}.0.0${t ? "-0" : ""}`
          : T(i)
            ? `>=${r}.${o}.0${t ? "-0" : ""}`
            : s
              ? `>=${e}`
              : `>=${e}${t ? "-0" : ""}`)} ${(c = T(a)
        ? ""
        : T(l)
          ? `<${+a + 1}.0.0-0`
          : T(f)
            ? `<${a}.${+l + 1}.0-0`
            : d
              ? `<=${a}.${l}.${f}-${d}`
              : t
                ? `<${a}.${l}.${+f + 1}-0`
                : `<=${c}`)}`.trim(),
    C = (t, n, e) => {
      for (let e = 0; e < t.length; e++) if (!t[e].test(n)) return !1;
      if (n.prerelease.length && !e.includePrerelease) {
        for (let e = 0; e < t.length; e++)
          if (
            (i(t[e].semver),
            t[e].semver !== o.ANY && t[e].semver.prerelease.length > 0)
          ) {
            const r = t[e].semver;
            if (
              r.major === n.major &&
              r.minor === n.minor &&
              r.patch === n.patch
            )
              return !0;
          }
        return !1;
      }
      return !0;
    };
  return Bb;
}
function tv() {
  if (zb) return Jb;
  zb = 1;
  const t = Symbol("SemVer ANY");
  class n {
    static get ANY() {
      return t;
    }
    constructor(r, o) {
      if (((o = e(o)), r instanceof n)) {
        if (r.loose === !!o.loose) return r;
        r = r.value;
      }
      (r = r.trim().split(/\s+/).join(" ")),
        s("comparator", r, o),
        (this.options = o),
        (this.loose = !!o.loose),
        this.parse(r),
        this.semver === t
          ? (this.value = "")
          : (this.value = this.operator + this.semver.version),
        s("comp", this);
    }
    parse(n) {
      const e = this.options.loose ? r[o.COMPARATORLOOSE] : r[o.COMPARATOR],
        i = n.match(e);
      if (!i) throw new TypeError(`Invalid comparator: ${n}`);
      (this.operator = void 0 !== i[1] ? i[1] : ""),
        "=" === this.operator && (this.operator = ""),
        i[2]
          ? (this.semver = new u(i[2], this.options.loose))
          : (this.semver = t);
    }
    toString() {
      return this.value;
    }
    test(n) {
      if (
        (s("Comparator.test", n, this.options.loose),
        this.semver === t || n === t)
      )
        return !0;
      if ("string" == typeof n)
        try {
          n = new u(n, this.options);
        } catch (t) {
          return !1;
        }
      return i(n, this.operator, this.semver, this.options);
    }
    intersects(t, r) {
      if (!(t instanceof n)) throw new TypeError("a Comparator is required");
      return "" === this.operator
        ? "" === this.value || new c(t.value, r).test(this.value)
        : "" === t.operator
          ? "" === t.value || new c(this.value, r).test(t.semver)
          : (!(r = e(r)).includePrerelease ||
              ("<0.0.0-0" !== this.value && "<0.0.0-0" !== t.value)) &&
            !(
              !r.includePrerelease &&
              (this.value.startsWith("<0.0.0") || t.value.startsWith("<0.0.0"))
            ) &&
            (!(!this.operator.startsWith(">") || !t.operator.startsWith(">")) ||
              !(
                !this.operator.startsWith("<") || !t.operator.startsWith("<")
              ) ||
              !(
                this.semver.version !== t.semver.version ||
                !this.operator.includes("=") ||
                !t.operator.includes("=")
              ) ||
              !!(
                i(this.semver, "<", t.semver, r) &&
                this.operator.startsWith(">") &&
                t.operator.startsWith("<")
              ) ||
              !!(
                i(this.semver, ">", t.semver, r) &&
                this.operator.startsWith("<") &&
                t.operator.startsWith(">")
              ));
    }
  }
  Jb = n;
  const e = I_,
    { safeRe: r, t: o } = N_,
    i = Gb,
    s = g_,
    u = H_,
    c = qb();
  return Jb;
}
const nv = qb();
var ev = (t, n, e) => {
  try {
    n = new nv(n, e);
  } catch (t) {
    return !1;
  }
  return n.test(t);
};
const rv = qb();
var ov = (t, n) =>
  new rv(t, n).set.map((t) =>
    t
      .map((t) => t.value)
      .join(" ")
      .trim()
      .split(" ")
  );
const iv = H_,
  sv = qb();
var uv = (t, n, e) => {
  let r = null,
    o = null,
    i = null;
  try {
    i = new sv(n, e);
  } catch (t) {
    return null;
  }
  return (
    t.forEach((t) => {
      i.test(t) &&
        ((r && -1 !== o.compare(t)) || ((r = t), (o = new iv(r, e))));
    }),
    r
  );
};
const cv = H_,
  av = qb();
var lv = (t, n, e) => {
  let r = null,
    o = null,
    i = null;
  try {
    i = new av(n, e);
  } catch (t) {
    return null;
  }
  return (
    t.forEach((t) => {
      i.test(t) && ((r && 1 !== o.compare(t)) || ((r = t), (o = new cv(r, e))));
    }),
    r
  );
};
const fv = H_,
  dv = qb(),
  hv = _b;
var pv = (t, n) => {
  t = new dv(t, n);
  let e = new fv("0.0.0");
  if (t.test(e)) return e;
  if (((e = new fv("0.0.0-0")), t.test(e))) return e;
  e = null;
  for (let n = 0; n < t.set.length; ++n) {
    const r = t.set[n];
    let o = null;
    r.forEach((t) => {
      const n = new fv(t.semver.version);
      switch (t.operator) {
        case ">":
          0 === n.prerelease.length ? n.patch++ : n.prerelease.push(0),
            (n.raw = n.format());
        case "":
        case ">=":
          (o && !hv(n, o)) || (o = n);
          break;
        case "<":
        case "<=":
          break;
        default:
          throw new Error(`Unexpected operation: ${t.operator}`);
      }
    }),
      !o || (e && !hv(e, o)) || (e = o);
  }
  return e && t.test(e) ? e : null;
};
const Sv = qb();
var Ev = (t, n) => {
  try {
    return new Sv(t, n).range || "*";
  } catch (t) {
    return null;
  }
};
const mv = H_,
  Tv = tv(),
  { ANY: _v } = Tv,
  bv = qb(),
  vv = ev,
  yv = _b,
  Rv = vb,
  Av = Lb,
  Ov = Nb;
var gv = (t, n, e, r) => {
  let o, i, s, u, c;
  switch (((t = new mv(t, r)), (n = new bv(n, r)), e)) {
    case ">":
      (o = yv), (i = Av), (s = Rv), (u = ">"), (c = ">=");
      break;
    case "<":
      (o = Rv), (i = Ov), (s = yv), (u = "<"), (c = "<=");
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }
  if (vv(t, n, r)) return !1;
  for (let e = 0; e < n.set.length; ++e) {
    const a = n.set[e];
    let l = null,
      f = null;
    if (
      (a.forEach((t) => {
        t.semver === _v && (t = new Tv(">=0.0.0")),
          (l = l || t),
          (f = f || t),
          o(t.semver, l.semver, r)
            ? (l = t)
            : s(t.semver, f.semver, r) && (f = t);
      }),
      l.operator === u || l.operator === c)
    )
      return !1;
    if ((!f.operator || f.operator === u) && i(t, f.semver)) return !1;
    if (f.operator === c && s(t, f.semver)) return !1;
  }
  return !0;
};
const Nv = gv;
var Cv = (t, n, e) => Nv(t, n, ">", e);
const Lv = gv;
var Iv = (t, n, e) => Lv(t, n, "<", e);
const Mv = qb();
var wv = (t, n, e) => (
  (t = new Mv(t, e)), (n = new Mv(n, e)), t.intersects(n, e)
);
const Zv = ev,
  Pv = ub;
const Vv = qb(),
  Gv = tv(),
  { ANY: Xv } = Gv,
  Uv = ev,
  Wv = ub,
  Yv = [new Gv(">=0.0.0-0")],
  Hv = [new Gv(">=0.0.0")],
  Dv = (t, n, e) => {
    if (t === n) return !0;
    if (1 === t.length && t[0].semver === Xv) {
      if (1 === n.length && n[0].semver === Xv) return !0;
      t = e.includePrerelease ? Yv : Hv;
    }
    if (1 === n.length && n[0].semver === Xv) {
      if (e.includePrerelease) return !0;
      n = Hv;
    }
    const r = new Set();
    let o, i, s, u, c, a, l;
    for (const n of t)
      ">" === n.operator || ">=" === n.operator
        ? (o = jv(o, n, e))
        : "<" === n.operator || "<=" === n.operator
          ? (i = xv(i, n, e))
          : r.add(n.semver);
    if (r.size > 1) return null;
    if (o && i) {
      if (((s = Wv(o.semver, i.semver, e)), s > 0)) return null;
      if (0 === s && (">=" !== o.operator || "<=" !== i.operator)) return null;
    }
    for (const t of r) {
      if (o && !Uv(t, String(o), e)) return null;
      if (i && !Uv(t, String(i), e)) return null;
      for (const r of n) if (!Uv(t, String(r), e)) return !1;
      return !0;
    }
    let f =
        !(!i || e.includePrerelease || !i.semver.prerelease.length) && i.semver,
      d =
        !(!o || e.includePrerelease || !o.semver.prerelease.length) && o.semver;
    f &&
      1 === f.prerelease.length &&
      "<" === i.operator &&
      0 === f.prerelease[0] &&
      (f = !1);
    for (const t of n) {
      if (
        ((l = l || ">" === t.operator || ">=" === t.operator),
        (a = a || "<" === t.operator || "<=" === t.operator),
        o)
      )
        if (
          (d &&
            t.semver.prerelease &&
            t.semver.prerelease.length &&
            t.semver.major === d.major &&
            t.semver.minor === d.minor &&
            t.semver.patch === d.patch &&
            (d = !1),
          ">" === t.operator || ">=" === t.operator)
        ) {
          if (((u = jv(o, t, e)), u === t && u !== o)) return !1;
        } else if (">=" === o.operator && !Uv(o.semver, String(t), e))
          return !1;
      if (i)
        if (
          (f &&
            t.semver.prerelease &&
            t.semver.prerelease.length &&
            t.semver.major === f.major &&
            t.semver.minor === f.minor &&
            t.semver.patch === f.patch &&
            (f = !1),
          "<" === t.operator || "<=" === t.operator)
        ) {
          if (((c = xv(i, t, e)), c === t && c !== i)) return !1;
        } else if ("<=" === i.operator && !Uv(i.semver, String(t), e))
          return !1;
      if (!t.operator && (i || o) && 0 !== s) return !1;
    }
    return !(o && a && !i && 0 !== s) && !(i && l && !o && 0 !== s) && !d && !f;
  },
  jv = (t, n, e) => {
    if (!t) return n;
    const r = Wv(t.semver, n.semver, e);
    return r > 0
      ? t
      : r < 0 || (">" === n.operator && ">=" === t.operator)
        ? n
        : t;
  },
  xv = (t, n, e) => {
    if (!t) return n;
    const r = Wv(t.semver, n.semver, e);
    return r < 0
      ? t
      : r > 0 || ("<" === n.operator && "<=" === t.operator)
        ? n
        : t;
  };
var kv = (t, n, e = {}) => {
  if (t === n) return !0;
  (t = new Vv(t, e)), (n = new Vv(n, e));
  let r = !1;
  t: for (const o of t.set) {
    for (const t of n.set) {
      const n = Dv(o, t, e);
      if (((r = r || null !== n), n)) continue t;
    }
    if (r) return !1;
  }
  return !0;
};
const Kv = N_,
  Bv = O_,
  Fv = H_,
  Jv = Z_,
  zv = (t, n, e) => {
    const r = [];
    let o = null,
      i = null;
    const s = t.sort((t, n) => Pv(t, n, e));
    for (const t of s) {
      Zv(t, n, e)
        ? ((i = t), o || (o = t))
        : (i && r.push([o, i]), (i = null), (o = null));
    }
    o && r.push([o, null]);
    const u = [];
    for (const [t, n] of r)
      t === n
        ? u.push(t)
        : n || t !== s[0]
          ? n
            ? t === s[0]
              ? u.push(`<=${n}`)
              : u.push(`${t} - ${n}`)
            : u.push(`>=${t}`)
          : u.push("*");
    const c = u.join(" || "),
      a = "string" == typeof n.raw ? n.raw : String(n);
    return c.length < a.length ? c : n;
  };
var Qv = {
    parse: j_,
    valid: k_,
    clean: B_,
    inc: J_,
    diff: Q_,
    major: q_,
    minor: nb,
    patch: rb,
    prerelease: ib,
    compare: ub,
    rcompare: ab,
    compareLoose: fb,
    compareBuild: hb,
    sort: Sb,
    rsort: mb,
    gt: _b,
    lt: vb,
    eq: Rb,
    neq: Ob,
    gte: Nb,
    lte: Lb,
    cmp: Gb,
    coerce: Qb,
    Comparator: tv(),
    Range: qb(),
    satisfies: ev,
    toComparators: ov,
    maxSatisfying: uv,
    minSatisfying: lv,
    minVersion: pv,
    validRange: Ev,
    outside: gv,
    gtr: Cv,
    ltr: Iv,
    intersects: wv,
    simplifyRange: zv,
    subset: kv,
    SemVer: Fv,
    re: Kv.re,
    src: Kv.src,
    tokens: Kv.t,
    SEMVER_SPEC_VERSION: Bv.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: Bv.RELEASE_TYPES,
    compareIdentifiers: Jv.compareIdentifiers,
    rcompareIdentifiers: Jv.rcompareIdentifiers,
  },
  $v = {},
  qv = Ht(TT),
  ty = {};
!(function (t) {
  Object.defineProperty(t, "__esModule", { value: !0 }),
    (t.AttributeNames = void 0),
    (function (t) {
      (t.HTTP_ERROR_NAME = "http.error_name"),
        (t.HTTP_ERROR_MESSAGE = "http.error_message"),
        (t.HTTP_STATUS_TEXT = "http.status_text");
    })(t.AttributeNames || (t.AttributeNames = {}));
})(ty),
  (function (t) {
    Object.defineProperty(t, "__esModule", { value: !0 }),
      (t.headerCapture =
        t.getIncomingRequestMetricAttributesOnResponse =
        t.getIncomingRequestAttributesOnResponse =
        t.getIncomingRequestMetricAttributes =
        t.getIncomingRequestAttributes =
        t.getOutgoingRequestMetricAttributesOnResponse =
        t.getOutgoingRequestAttributesOnResponse =
        t.setAttributesFromHttpKind =
        t.getOutgoingRequestMetricAttributes =
        t.getOutgoingRequestAttributes =
        t.extractHostnameAndPort =
        t.isValidOptionsType =
        t.getRequestInfo =
        t.isCompressed =
        t.setResponseContentLengthAttribute =
        t.setRequestContentLengthAttribute =
        t.setSpanWithError =
        t.isIgnored =
        t.satisfiesPattern =
        t.parseResponseStatus =
        t.getAbsoluteUrl =
          void 0);
    const n = no,
      e = qv,
      r = R_,
      o = u,
      i = ty;
    t.getAbsoluteUrl = (t, n, e = "http:") => {
      const r = t || {},
        o = r.protocol || e,
        i = (r.port || "").toString(),
        s = r.path || "/";
      let u = r.host || r.hostname || n.host || "localhost";
      return (
        -1 === u.indexOf(":") &&
          i &&
          "80" !== i &&
          "443" !== i &&
          (u += `:${i}`),
        `${o}//${u}${s}`
      );
    };
    t.parseResponseStatus = (t, e) => {
      const r = t === n.SpanKind.CLIENT ? 400 : 500;
      return e && e >= 100 && e < r
        ? n.SpanStatusCode.UNSET
        : n.SpanStatusCode.ERROR;
    };
    t.satisfiesPattern = (t, n) => {
      if ("string" == typeof n) return n === t;
      if (n instanceof RegExp) return n.test(t);
      if ("function" == typeof n) return n(t);
      throw new TypeError("Pattern is in unsupported datatype");
    };
    t.isIgnored = (n, e, r) => {
      if (!e) return !1;
      try {
        for (const r of e) if ((0, t.satisfiesPattern)(n, r)) return !0;
      } catch (t) {
        r && r(t);
      }
      return !1;
    };
    t.setSpanWithError = (t, e) => {
      const r = e.message;
      t.setAttribute(i.AttributeNames.HTTP_ERROR_NAME, e.name),
        t.setAttribute(i.AttributeNames.HTTP_ERROR_MESSAGE, r),
        t.setStatus({ code: n.SpanStatusCode.ERROR, message: r }),
        t.recordException(e);
    };
    t.setRequestContentLengthAttribute = (n, r) => {
      const o = s(n.headers);
      null !== o &&
        ((0, t.isCompressed)(n.headers)
          ? (r[e.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH] = o)
          : (r[e.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED] = o));
    };
    function s(t) {
      const n = t["content-length"];
      if (void 0 === n) return null;
      const e = parseInt(n, 10);
      return isNaN(e) ? null : e;
    }
    t.setResponseContentLengthAttribute = (n, r) => {
      const o = s(n.headers);
      null !== o &&
        ((0, t.isCompressed)(n.headers)
          ? (r[e.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH] = o)
          : (r[e.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED] = o));
    };
    t.isCompressed = (t) => {
      const n = t["content-encoding"];
      return !!n && "identity" !== n;
    };
    t.getRequestInfo = (t, n) => {
      let e,
        r = "/",
        i = "";
      if ("string" == typeof t)
        (e = o.parse(t)),
          (r = e.pathname || "/"),
          (i = `${e.protocol || "http:"}//${e.host}`),
          void 0 !== n && Object.assign(e, n);
      else if (t instanceof o.URL)
        (e = {
          protocol: t.protocol,
          hostname:
            "string" == typeof t.hostname && t.hostname.startsWith("[")
              ? t.hostname.slice(1, -1)
              : t.hostname,
          path: `${t.pathname || ""}${t.search || ""}`,
        }),
          "" !== t.port && (e.port = Number(t.port)),
          (t.username || t.password) &&
            (e.auth = `${t.username}:${t.password}`),
          (r = t.pathname),
          (i = t.origin),
          void 0 !== n && Object.assign(e, n);
      else {
        (e = Object.assign({ protocol: t.host ? "http:" : void 0 }, t)),
          (r = t.pathname),
          !r && e.path && (r = o.parse(e.path).pathname || "/");
        const n =
          e.host || (null != e.port ? `${e.hostname}${e.port}` : e.hostname);
        i = `${e.protocol || "http:"}//${n}`;
      }
      return {
        origin: i,
        pathname: r,
        method: e.method ? e.method.toUpperCase() : "GET",
        optionsParsed: e,
      };
    };
    t.isValidOptionsType = (t) => {
      if (!t) return !1;
      const n = typeof t;
      return "string" === n || ("object" === n && !Array.isArray(t));
    };
    t.extractHostnameAndPort = (t) => {
      var n;
      if (t.hostname && t.port) return { hostname: t.hostname, port: t.port };
      const e =
          (null === (n = t.host) || void 0 === n
            ? void 0
            : n.match(/^([^:/ ]+)(:\d{1,5})?/)) || null,
        r = t.hostname || (null === e ? "localhost" : e[1]);
      let o = t.port;
      return (
        o ||
          (o =
            e && e[2]
              ? e[2].substring(1)
              : "https:" === t.protocol
                ? "443"
                : "80"),
        { hostname: r, port: o }
      );
    };
    t.getOutgoingRequestAttributes = (n, r) => {
      var o;
      const i = r.hostname,
        s = r.port,
        u = n.method,
        c = u ? u.toUpperCase() : "GET",
        a = n.headers || {},
        l = a["user-agent"],
        f = {
          [e.SEMATTRS_HTTP_URL]: (0, t.getAbsoluteUrl)(n, a, `${r.component}:`),
          [e.SEMATTRS_HTTP_METHOD]: c,
          [e.SEMATTRS_HTTP_TARGET]: n.path || "/",
          [e.SEMATTRS_NET_PEER_NAME]: i,
          [e.SEMATTRS_HTTP_HOST]:
            null !== (o = a.host) && void 0 !== o ? o : `${i}:${s}`,
        };
      return (
        void 0 !== l && (f[e.SEMATTRS_HTTP_USER_AGENT] = l),
        Object.assign(f, r.hookAttributes)
      );
    };
    t.getOutgoingRequestMetricAttributes = (t) => {
      const n = {};
      return (
        (n[e.SEMATTRS_HTTP_METHOD] = t[e.SEMATTRS_HTTP_METHOD]),
        (n[e.SEMATTRS_NET_PEER_NAME] = t[e.SEMATTRS_NET_PEER_NAME]),
        n
      );
    };
    t.setAttributesFromHttpKind = (t, n) => {
      t &&
        ((n[e.SEMATTRS_HTTP_FLAVOR] = t),
        "QUIC" !== t.toUpperCase()
          ? (n[e.SEMATTRS_NET_TRANSPORT] = e.NETTRANSPORTVALUES_IP_TCP)
          : (n[e.SEMATTRS_NET_TRANSPORT] = e.NETTRANSPORTVALUES_IP_UDP));
    };
    t.getOutgoingRequestAttributesOnResponse = (n) => {
      const { statusCode: r, statusMessage: o, httpVersion: s, socket: u } = n,
        c = {};
      if (u) {
        const { remoteAddress: t, remotePort: n } = u;
        (c[e.SEMATTRS_NET_PEER_IP] = t), (c[e.SEMATTRS_NET_PEER_PORT] = n);
      }
      return (
        (0, t.setResponseContentLengthAttribute)(n, c),
        r &&
          ((c[e.SEMATTRS_HTTP_STATUS_CODE] = r),
          (c[i.AttributeNames.HTTP_STATUS_TEXT] = (o || "").toUpperCase())),
        (0, t.setAttributesFromHttpKind)(s, c),
        c
      );
    };
    t.getOutgoingRequestMetricAttributesOnResponse = (t) => {
      const n = {};
      return (
        (n[e.SEMATTRS_NET_PEER_PORT] = t[e.SEMATTRS_NET_PEER_PORT]),
        (n[e.SEMATTRS_HTTP_STATUS_CODE] = t[e.SEMATTRS_HTTP_STATUS_CODE]),
        (n[e.SEMATTRS_HTTP_FLAVOR] = t[e.SEMATTRS_HTTP_FLAVOR]),
        n
      );
    };
    t.getIncomingRequestAttributes = (n, r) => {
      const i = n.headers,
        s = i["user-agent"],
        u = i["x-forwarded-for"],
        c = n.method || "GET",
        a = n.httpVersion,
        l = n.url ? o.parse(n.url) : null,
        f = (null == l ? void 0 : l.host) || i.host,
        d =
          (null == l ? void 0 : l.hostname) ||
          (null == f ? void 0 : f.replace(/^(.*)(:[0-9]{1,5})/, "$1")) ||
          "localhost",
        h = r.serverName,
        p = {
          [e.SEMATTRS_HTTP_URL]: (0, t.getAbsoluteUrl)(l, i, `${r.component}:`),
          [e.SEMATTRS_HTTP_HOST]: f,
          [e.SEMATTRS_NET_HOST_NAME]: d,
          [e.SEMATTRS_HTTP_METHOD]: c,
          [e.SEMATTRS_HTTP_SCHEME]: r.component,
        };
      return (
        "string" == typeof u &&
          (p[e.SEMATTRS_HTTP_CLIENT_IP] = u.split(",")[0]),
        "string" == typeof h && (p[e.SEMATTRS_HTTP_SERVER_NAME] = h),
        l && (p[e.SEMATTRS_HTTP_TARGET] = l.path || "/"),
        void 0 !== s && (p[e.SEMATTRS_HTTP_USER_AGENT] = s),
        (0, t.setRequestContentLengthAttribute)(n, p),
        (0, t.setAttributesFromHttpKind)(a, p),
        Object.assign(p, r.hookAttributes)
      );
    };
    t.getIncomingRequestMetricAttributes = (t) => {
      const n = {};
      return (
        (n[e.SEMATTRS_HTTP_SCHEME] = t[e.SEMATTRS_HTTP_SCHEME]),
        (n[e.SEMATTRS_HTTP_METHOD] = t[e.SEMATTRS_HTTP_METHOD]),
        (n[e.SEMATTRS_NET_HOST_NAME] = t[e.SEMATTRS_NET_HOST_NAME]),
        (n[e.SEMATTRS_HTTP_FLAVOR] = t[e.SEMATTRS_HTTP_FLAVOR]),
        n
      );
    };
    t.getIncomingRequestAttributesOnResponse = (t, o) => {
      const { socket: s } = t,
        { statusCode: u, statusMessage: c } = o,
        a = (0, r.getRPCMetadata)(n.context.active()),
        l = {};
      if (s) {
        const {
          localAddress: t,
          localPort: n,
          remoteAddress: r,
          remotePort: o,
        } = s;
        (l[e.SEMATTRS_NET_HOST_IP] = t),
          (l[e.SEMATTRS_NET_HOST_PORT] = n),
          (l[e.SEMATTRS_NET_PEER_IP] = r),
          (l[e.SEMATTRS_NET_PEER_PORT] = o);
      }
      return (
        (l[e.SEMATTRS_HTTP_STATUS_CODE] = u),
        (l[i.AttributeNames.HTTP_STATUS_TEXT] = (c || "").toUpperCase()),
        (null == a ? void 0 : a.type) === r.RPCType.HTTP &&
          void 0 !== a.route &&
          (l[e.SEMATTRS_HTTP_ROUTE] = a.route),
        l
      );
    };
    (t.getIncomingRequestMetricAttributesOnResponse = (t) => {
      const n = {};
      return (
        (n[e.SEMATTRS_HTTP_STATUS_CODE] = t[e.SEMATTRS_HTTP_STATUS_CODE]),
        (n[e.SEMATTRS_NET_HOST_PORT] = t[e.SEMATTRS_NET_HOST_PORT]),
        void 0 !== t[e.SEMATTRS_HTTP_ROUTE] &&
          (n[e.SEMATTRS_HTTP_ROUTE] = t[e.SEMATTRS_HTTP_ROUTE]),
        n
      );
    }),
      (t.headerCapture = function (t, n) {
        const e = new Map();
        for (let t = 0, r = n.length; t < r; t++) {
          const r = n[t].toLowerCase();
          e.set(r, r.replace(/-/g, "_"));
        }
        return (n, r) => {
          for (const o of e.keys()) {
            const i = r(o);
            if (void 0 === i) continue;
            const s = e.get(o),
              u = `http.${t}.header.${s}`;
            "string" == typeof i
              ? n.setAttribute(u, [i])
              : Array.isArray(i)
                ? n.setAttribute(u, i)
                : n.setAttribute(u, [i]);
          }
        };
      });
  })($v);
var ny = {};
Object.defineProperty(ny, "__esModule", { value: !0 }),
  (ny.VERSION = void 0),
  (ny.VERSION = "0.51.1");
var ey = (function () {
    function t() {}
    return (t.prototype.emit = function (t) {}), t;
  })(),
  ry = (function () {
    function t() {}
    return (
      (t.prototype.getLogger = function (t, n, e) {
        return new ey();
      }),
      t
    );
  })(),
  oy = new ry(),
  iy = "object" == typeof globalThis ? globalThis : global,
  sy = Symbol.for("io.opentelemetry.js.api.logs"),
  uy = iy;
var cy = (function () {
    function t() {}
    return (
      (t.getInstance = function () {
        return this.L || (this.L = new t()), this.L;
      }),
      (t.prototype.setGlobalLoggerProvider = function (t) {
        return uy[sy]
          ? this.getLoggerProvider()
          : ((uy[sy] =
              ((n = 1),
              (e = t),
              (r = oy),
              function (t) {
                return t === n ? e : r;
              })),
            t);
        var n, e, r;
      }),
      (t.prototype.getLoggerProvider = function () {
        var t, n;
        return null !==
          (n =
            null === (t = uy[sy]) || void 0 === t ? void 0 : t.call(uy, 1)) &&
          void 0 !== n
          ? n
          : oy;
      }),
      (t.prototype.getLogger = function (t, n, e) {
        return this.getLoggerProvider().getLogger(t, n, e);
      }),
      (t.prototype.disable = function () {
        delete uy[sy];
      }),
      t
    );
  })(),
  ay = cy.getInstance();
function ly(t) {
  void 0 === t && (t = []);
  for (var n = [], e = 0, r = t.length; e < r; e++) {
    var o = t[e];
    if (Array.isArray(o)) {
      var i = ly(o);
      n = n.concat(i.instrumentations);
    } else
      "function" == typeof o
        ? n.push(new o())
        : o.instrumentationName && n.push(o);
  }
  return { instrumentations: n };
}
function fy(t) {
  return "function" == typeof t;
}
var dy = console.error.bind(console);
function hy(t, n, e) {
  var r = !!t[n] && t.propertyIsEnumerable(n);
  Object.defineProperty(t, n, {
    configurable: !0,
    enumerable: r,
    writable: !0,
    value: e,
  });
}
function py(t) {
  t &&
    t.logger &&
    (fy(t.logger)
      ? (dy = t.logger)
      : dy("new logger isn't a function, not replacing"));
}
function Sy(t, n, e) {
  if (t && t[n]) {
    if (!e) return dy("no wrapper function"), void dy(new Error().stack);
    if (fy(t[n]) && fy(e)) {
      var r = t[n],
        o = e(r, n);
      return (
        hy(o, "__original", r),
        hy(o, "__unwrap", function () {
          t[n] === o && hy(t, n, r);
        }),
        hy(o, "__wrapped", !0),
        hy(t, n, o),
        o
      );
    }
    dy("original object and wrapper must be functions");
  } else dy("no original function " + n + " to wrap");
}
function Ey(t, n) {
  return t && t[n]
    ? t[n].__unwrap
      ? t[n].__unwrap()
      : void dy(
          "no original to unwrap to -- has " + n + " already been unwrapped?"
        )
    : (dy("no function to unwrap."), void dy(new Error().stack));
}
(py.wrap = Sy),
  (py.massWrap = function (t, n, e) {
    if (!t)
      return (
        dy("must provide one or more modules to patch"),
        void dy(new Error().stack)
      );
    Array.isArray(t) || (t = [t]),
      n && Array.isArray(n)
        ? t.forEach(function (t) {
            n.forEach(function (n) {
              Sy(t, n, e);
            });
          })
        : dy("must provide one or more functions to wrap on modules");
  }),
  (py.unwrap = Ey),
  (py.massUnwrap = function (t, n) {
    if (!t)
      return (
        dy("must provide one or more modules to patch"),
        void dy(new Error().stack)
      );
    Array.isArray(t) || (t = [t]),
      n && Array.isArray(n)
        ? t.forEach(function (t) {
            n.forEach(function (n) {
              Ey(t, n);
            });
          })
        : dy("must provide one or more functions to unwrap on modules");
  });
var my,
  Ty = py,
  _y = function () {
    return (
      (_y =
        Object.assign ||
        function (t) {
          for (var n, e = 1, r = arguments.length; e < r; e++)
            for (var o in (n = arguments[e]))
              Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
          return t;
        }),
      _y.apply(this, arguments)
    );
  },
  by = (function () {
    function t(t, n, e) {
      void 0 === e && (e = {}),
        (this.instrumentationName = t),
        (this.instrumentationVersion = n),
        (this.yt = Ty.wrap),
        (this.Rt = Ty.unwrap),
        (this.At = Ty.massWrap),
        (this.Ot = Ty.massUnwrap),
        (this.Nt = _y({ enabled: !0 }, e)),
        (this.Ct = Pr.createComponentLogger({ namespace: t })),
        (this.Lt = Qr.getTracer(t, n)),
        (this.It = Ur.getMeter(t, n)),
        (this.Mt = ay.getLogger(t, n)),
        this.wt();
    }
    return (
      Object.defineProperty(t.prototype, "meter", {
        get: function () {
          return this.It;
        },
        enumerable: !1,
        configurable: !0,
      }),
      (t.prototype.setMeterProvider = function (t) {
        (this.It = t.getMeter(
          this.instrumentationName,
          this.instrumentationVersion
        )),
          this.wt();
      }),
      Object.defineProperty(t.prototype, "logger", {
        get: function () {
          return this.Mt;
        },
        enumerable: !1,
        configurable: !0,
      }),
      (t.prototype.setLoggerProvider = function (t) {
        this.Mt = t.getLogger(
          this.instrumentationName,
          this.instrumentationVersion
        );
      }),
      (t.prototype.getModuleDefinitions = function () {
        var t,
          n = null !== (t = this.init()) && void 0 !== t ? t : [];
        return Array.isArray(n) ? n : [n];
      }),
      (t.prototype.wt = function () {}),
      (t.prototype.getConfig = function () {
        return this.Nt;
      }),
      (t.prototype.setConfig = function (t) {
        void 0 === t && (t = {}), (this.Nt = Object.assign({}, t));
      }),
      (t.prototype.setTracerProvider = function (t) {
        this.Lt = t.getTracer(
          this.instrumentationName,
          this.instrumentationVersion
        );
      }),
      Object.defineProperty(t.prototype, "tracer", {
        get: function () {
          return this.Lt;
        },
        enumerable: !1,
        configurable: !0,
      }),
      t
    );
  })(),
  vy = { exports: {} },
  yy =
    i.homedir ||
    function () {
      var t = process.env.HOME,
        n =
          process.env.LOGNAME ||
          process.env.USER ||
          process.env.LNAME ||
          process.env.USERNAME;
      return "win32" === process.platform
        ? process.env.USERPROFILE ||
            process.env.HOMEDRIVE + process.env.HOMEPATH ||
            t ||
            null
        : "darwin" === process.platform
          ? t || (n ? "/Users/" + n : null)
          : "linux" === process.platform
            ? t || (0 === process.getuid() ? "/root" : n ? "/home/" + n : null)
            : t || null;
    },
  Ry = function () {
    var t = Error.prepareStackTrace;
    Error.prepareStackTrace = function (t, n) {
      return n;
    };
    var n = new Error().stack;
    return (Error.prepareStackTrace = t), n[2].getFileName();
  },
  Ay = { exports: {} };
var Oy = n,
  gy =
    Oy.parse ||
    (function () {
      if (my) return Ay.exports;
      my = 1;
      var t = "win32" === process.platform,
        n =
          /^(((?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?[\\\/]?)(?:[^\\\/]*[\\\/])*)((\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))[\\\/]*$/,
        e = {};
      e.parse = function (t) {
        if ("string" != typeof t)
          throw new TypeError(
            "Parameter 'pathString' must be a string, not " + typeof t
          );
        var e,
          r = ((e = t), n.exec(e).slice(1));
        if (!r || 5 !== r.length)
          throw new TypeError("Invalid path '" + t + "'");
        return {
          root: r[1],
          dir: r[0] === r[1] ? r[0] : r[0].slice(0, -1),
          base: r[2],
          ext: r[4],
          name: r[3],
        };
      };
      var r = /^((\/?)(?:[^\/]*\/)*)((\.{1,2}|[^\/]+?|)(\.[^.\/]*|))[\/]*$/,
        o = {};
      return (
        (o.parse = function (t) {
          if ("string" != typeof t)
            throw new TypeError(
              "Parameter 'pathString' must be a string, not " + typeof t
            );
          var n,
            e = ((n = t), r.exec(n).slice(1));
          if (!e || 5 !== e.length)
            throw new TypeError("Invalid path '" + t + "'");
          return {
            root: e[1],
            dir: e[0].slice(0, -1),
            base: e[2],
            ext: e[4],
            name: e[3],
          };
        }),
        (Ay.exports = t ? e.parse : o.parse),
        (Ay.exports.posix = o.parse),
        (Ay.exports.win32 = e.parse),
        Ay.exports
      );
    })(),
  Ny = function (t, n) {
    var e = "/";
    /^([A-Za-z]:)/.test(t) ? (e = "") : /^\\\\/.test(t) && (e = "\\\\");
    for (var r = [t], o = gy(t); o.dir !== r[r.length - 1]; )
      r.push(o.dir), (o = gy(o.dir));
    return r.reduce(function (t, r) {
      return t.concat(
        n.map(function (t) {
          return Oy.resolve(e, r, t);
        })
      );
    }, []);
  },
  Cy = function (t, n, e) {
    var r =
      n && n.moduleDirectory ? [].concat(n.moduleDirectory) : ["node_modules"];
    if (n && "function" == typeof n.paths)
      return n.paths(
        e,
        t,
        function () {
          return Ny(t, r);
        },
        n
      );
    var o = Ny(t, r);
    return n && n.paths ? o.concat(n.paths) : o;
  },
  Ly = function (t, n) {
    return n || {};
  },
  Iy = Array.prototype.slice,
  My = Object.prototype.toString,
  wy = function (t) {
    var n = this;
    if ("function" != typeof n || "[object Function]" !== My.call(n))
      throw new TypeError(
        "Function.prototype.bind called on incompatible " + n
      );
    for (
      var e,
        r = Iy.call(arguments, 1),
        o = Math.max(0, n.length - r.length),
        i = [],
        s = 0;
      s < o;
      s++
    )
      i.push("$" + s);
    if (
      ((e = Function(
        "binder",
        "return function (" +
          i.join(",") +
          "){ return binder.apply(this,arguments); }"
      )(function () {
        if (this instanceof e) {
          var o = n.apply(this, r.concat(Iy.call(arguments)));
          return Object(o) === o ? o : this;
        }
        return n.apply(t, r.concat(Iy.call(arguments)));
      })),
      n.prototype)
    ) {
      var u = function () {};
      (u.prototype = n.prototype),
        (e.prototype = new u()),
        (u.prototype = null);
    }
    return e;
  },
  Zy = (Function.prototype.bind || wy).call(
    Function.call,
    Object.prototype.hasOwnProperty
  );
function Py(t, n) {
  for (
    var e = t.split("."),
      r = n.split(" "),
      o = r.length > 1 ? r[0] : "=",
      i = (r.length > 1 ? r[1] : r[0]).split("."),
      s = 0;
    s < 3;
    ++s
  ) {
    var u = parseInt(e[s] || 0, 10),
      c = parseInt(i[s] || 0, 10);
    if (u !== c) return "<" === o ? u < c : ">=" === o && u >= c;
  }
  return ">=" === o;
}
function Vy(t, n) {
  var e = n.split(/ ?&& ?/);
  if (0 === e.length) return !1;
  for (var r = 0; r < e.length; ++r) if (!Py(t, e[r])) return !1;
  return !0;
}
var Gy = {
    assert: !0,
    "node:assert": [">= 14.18 && < 15", ">= 16"],
    "assert/strict": ">= 15",
    "node:assert/strict": ">= 16",
    async_hooks: ">= 8",
    "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
    buffer_ieee754: ">= 0.5 && < 0.9.7",
    buffer: !0,
    "node:buffer": [">= 14.18 && < 15", ">= 16"],
    child_process: !0,
    "node:child_process": [">= 14.18 && < 15", ">= 16"],
    cluster: ">= 0.5",
    "node:cluster": [">= 14.18 && < 15", ">= 16"],
    console: !0,
    "node:console": [">= 14.18 && < 15", ">= 16"],
    constants: !0,
    "node:constants": [">= 14.18 && < 15", ">= 16"],
    crypto: !0,
    "node:crypto": [">= 14.18 && < 15", ">= 16"],
    Zt: ">= 1 && < 8",
    Pt: "< 8",
    dgram: !0,
    "node:dgram": [">= 14.18 && < 15", ">= 16"],
    diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
    "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
    dns: !0,
    "node:dns": [">= 14.18 && < 15", ">= 16"],
    "dns/promises": ">= 15",
    "node:dns/promises": ">= 16",
    domain: ">= 0.7.12",
    "node:domain": [">= 14.18 && < 15", ">= 16"],
    events: !0,
    "node:events": [">= 14.18 && < 15", ">= 16"],
    freelist: "< 6",
    fs: !0,
    "node:fs": [">= 14.18 && < 15", ">= 16"],
    "fs/promises": [">= 10 && < 10.1", ">= 14"],
    "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
    Vt: ">= 0.11.1",
    "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
    Gt: ">= 0.11.1",
    "node:_http_client": [">= 14.18 && < 15", ">= 16"],
    Xt: ">= 0.11.1",
    "node:_http_common": [">= 14.18 && < 15", ">= 16"],
    Ut: ">= 0.11.1",
    "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
    Wt: ">= 0.11.1",
    "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
    Yt: ">= 0.11.1",
    "node:_http_server": [">= 14.18 && < 15", ">= 16"],
    http: !0,
    "node:http": [">= 14.18 && < 15", ">= 16"],
    http2: ">= 8.8",
    "node:http2": [">= 14.18 && < 15", ">= 16"],
    https: !0,
    "node:https": [">= 14.18 && < 15", ">= 16"],
    inspector: ">= 8",
    "node:inspector": [">= 14.18 && < 15", ">= 16"],
    "inspector/promises": [">= 19"],
    "node:inspector/promises": [">= 19"],
    Ht: "< 8",
    module: !0,
    "node:module": [">= 14.18 && < 15", ">= 16"],
    net: !0,
    "node:net": [">= 14.18 && < 15", ">= 16"],
    "node-inspect/lib/_inspect": ">= 7.6 && < 12",
    "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
    "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
    os: !0,
    "node:os": [">= 14.18 && < 15", ">= 16"],
    path: !0,
    "node:path": [">= 14.18 && < 15", ">= 16"],
    "path/posix": ">= 15.3",
    "node:path/posix": ">= 16",
    "path/win32": ">= 15.3",
    "node:path/win32": ">= 16",
    perf_hooks: ">= 8.5",
    "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
    process: ">= 1",
    "node:process": [">= 14.18 && < 15", ">= 16"],
    punycode: ">= 0.5",
    "node:punycode": [">= 14.18 && < 15", ">= 16"],
    querystring: !0,
    "node:querystring": [">= 14.18 && < 15", ">= 16"],
    readline: !0,
    "node:readline": [">= 14.18 && < 15", ">= 16"],
    "readline/promises": ">= 17",
    "node:readline/promises": ">= 17",
    repl: !0,
    "node:repl": [">= 14.18 && < 15", ">= 16"],
    smalloc: ">= 0.11.5 && < 3",
    Dt: ">= 0.9.4",
    "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
    jt: ">= 0.9.4",
    "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
    xt: ">= 1.4.1",
    "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
    kt: ">= 0.9.4",
    "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
    Kt: ">= 0.9.4",
    "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
    Bt: ">= 0.9.4",
    "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
    stream: !0,
    "node:stream": [">= 14.18 && < 15", ">= 16"],
    "stream/consumers": ">= 16.7",
    "node:stream/consumers": ">= 16.7",
    "stream/promises": ">= 15",
    "node:stream/promises": ">= 16",
    "stream/web": ">= 16.5",
    "node:stream/web": ">= 16.5",
    string_decoder: !0,
    "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
    sys: [">= 0.4 && < 0.7", ">= 0.8"],
    "node:sys": [">= 14.18 && < 15", ">= 16"],
    "node:test": [">= 16.17 && < 17", ">= 18"],
    timers: !0,
    "node:timers": [">= 14.18 && < 15", ">= 16"],
    "timers/promises": ">= 15",
    "node:timers/promises": ">= 16",
    Ft: ">= 0.11.13",
    "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
    Jt: ">= 0.11.3 && < 10",
    zt: ">= 0.11.3",
    "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
    tls: !0,
    "node:tls": [">= 14.18 && < 15", ">= 16"],
    trace_events: ">= 10",
    "node:trace_events": [">= 14.18 && < 15", ">= 16"],
    tty: !0,
    "node:tty": [">= 14.18 && < 15", ">= 16"],
    url: !0,
    "node:url": [">= 14.18 && < 15", ">= 16"],
    util: !0,
    "node:util": [">= 14.18 && < 15", ">= 16"],
    "util/types": ">= 15.3",
    "node:util/types": ">= 16",
    "v8/tools/arguments": ">= 10 && < 12",
    "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    v8: ">= 1",
    "node:v8": [">= 14.18 && < 15", ">= 16"],
    vm: !0,
    "node:vm": [">= 14.18 && < 15", ">= 16"],
    wasi: ">= 13.4 && < 13.5",
    worker_threads: ">= 11.7",
    "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
    zlib: ">= 0.5",
    "node:zlib": [">= 14.18 && < 15", ">= 16"],
  },
  Xy = function (t, n) {
    return (
      Zy(Gy, t) &&
      (function (t, n) {
        if ("boolean" == typeof n) return n;
        var e = void 0 === t ? process.versions && process.versions.node : t;
        if ("string" != typeof e)
          throw new TypeError(
            void 0 === t
              ? "Unable to determine current node version"
              : "If provided, a valid node version is required"
          );
        if (n && "object" == typeof n) {
          for (var r = 0; r < n.length; ++r) if (Vy(e, n[r])) return !0;
          return !1;
        }
        return Vy(e, n);
      })(n, Gy[t])
    );
  },
  Uy = o,
  Wy = yy,
  Yy = n,
  Hy = Ry,
  Dy = Cy,
  jy = Ly,
  xy = Xy,
  ky =
    "win32" !== process.platform &&
    Uy.realpath &&
    "function" == typeof Uy.realpath.native
      ? Uy.realpath.native
      : Uy.realpath,
  Ky = Wy(),
  By = function (t, n) {
    Uy.stat(t, function (t, e) {
      return t
        ? "ENOENT" === t.code || "ENOTDIR" === t.code
          ? n(null, !1)
          : n(t)
        : n(null, e.isFile() || e.isFIFO());
    });
  },
  Fy = function (t, n) {
    Uy.stat(t, function (t, e) {
      return t
        ? "ENOENT" === t.code || "ENOTDIR" === t.code
          ? n(null, !1)
          : n(t)
        : n(null, e.isDirectory());
    });
  },
  Jy = function (t, n) {
    ky(t, function (e, r) {
      e && "ENOENT" !== e.code ? n(e) : n(null, e ? t : r);
    });
  },
  zy = function (t, n, e, r) {
    e && !1 === e.preserveSymlinks ? t(n, r) : r(null, n);
  },
  Qy = function (t, n, e) {
    t(n, function (t, n) {
      if (t) e(t);
      else
        try {
          var r = JSON.parse(n);
          e(null, r);
        } catch (t) {
          e(null);
        }
    });
  },
  $y = {
    assert: !0,
    "node:assert": [">= 14.18 && < 15", ">= 16"],
    "assert/strict": ">= 15",
    "node:assert/strict": ">= 16",
    async_hooks: ">= 8",
    "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
    buffer_ieee754: ">= 0.5 && < 0.9.7",
    buffer: !0,
    "node:buffer": [">= 14.18 && < 15", ">= 16"],
    child_process: !0,
    "node:child_process": [">= 14.18 && < 15", ">= 16"],
    cluster: ">= 0.5",
    "node:cluster": [">= 14.18 && < 15", ">= 16"],
    console: !0,
    "node:console": [">= 14.18 && < 15", ">= 16"],
    constants: !0,
    "node:constants": [">= 14.18 && < 15", ">= 16"],
    crypto: !0,
    "node:crypto": [">= 14.18 && < 15", ">= 16"],
    Zt: ">= 1 && < 8",
    Pt: "< 8",
    dgram: !0,
    "node:dgram": [">= 14.18 && < 15", ">= 16"],
    diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
    "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
    dns: !0,
    "node:dns": [">= 14.18 && < 15", ">= 16"],
    "dns/promises": ">= 15",
    "node:dns/promises": ">= 16",
    domain: ">= 0.7.12",
    "node:domain": [">= 14.18 && < 15", ">= 16"],
    events: !0,
    "node:events": [">= 14.18 && < 15", ">= 16"],
    freelist: "< 6",
    fs: !0,
    "node:fs": [">= 14.18 && < 15", ">= 16"],
    "fs/promises": [">= 10 && < 10.1", ">= 14"],
    "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
    Vt: ">= 0.11.1",
    "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
    Gt: ">= 0.11.1",
    "node:_http_client": [">= 14.18 && < 15", ">= 16"],
    Xt: ">= 0.11.1",
    "node:_http_common": [">= 14.18 && < 15", ">= 16"],
    Ut: ">= 0.11.1",
    "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
    Wt: ">= 0.11.1",
    "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
    Yt: ">= 0.11.1",
    "node:_http_server": [">= 14.18 && < 15", ">= 16"],
    http: !0,
    "node:http": [">= 14.18 && < 15", ">= 16"],
    http2: ">= 8.8",
    "node:http2": [">= 14.18 && < 15", ">= 16"],
    https: !0,
    "node:https": [">= 14.18 && < 15", ">= 16"],
    inspector: ">= 8",
    "node:inspector": [">= 14.18 && < 15", ">= 16"],
    Ht: "< 8",
    module: !0,
    "node:module": [">= 14.18 && < 15", ">= 16"],
    net: !0,
    "node:net": [">= 14.18 && < 15", ">= 16"],
    "node-inspect/lib/_inspect": ">= 7.6 && < 12",
    "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
    "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
    os: !0,
    "node:os": [">= 14.18 && < 15", ">= 16"],
    path: !0,
    "node:path": [">= 14.18 && < 15", ">= 16"],
    "path/posix": ">= 15.3",
    "node:path/posix": ">= 16",
    "path/win32": ">= 15.3",
    "node:path/win32": ">= 16",
    perf_hooks: ">= 8.5",
    "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
    process: ">= 1",
    "node:process": [">= 14.18 && < 15", ">= 16"],
    punycode: ">= 0.5",
    "node:punycode": [">= 14.18 && < 15", ">= 16"],
    querystring: !0,
    "node:querystring": [">= 14.18 && < 15", ">= 16"],
    readline: !0,
    "node:readline": [">= 14.18 && < 15", ">= 16"],
    "readline/promises": ">= 17",
    "node:readline/promises": ">= 17",
    repl: !0,
    "node:repl": [">= 14.18 && < 15", ">= 16"],
    smalloc: ">= 0.11.5 && < 3",
    Dt: ">= 0.9.4",
    "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
    jt: ">= 0.9.4",
    "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
    xt: ">= 1.4.1",
    "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
    kt: ">= 0.9.4",
    "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
    Kt: ">= 0.9.4",
    "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
    Bt: ">= 0.9.4",
    "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
    stream: !0,
    "node:stream": [">= 14.18 && < 15", ">= 16"],
    "stream/consumers": ">= 16.7",
    "node:stream/consumers": ">= 16.7",
    "stream/promises": ">= 15",
    "node:stream/promises": ">= 16",
    "stream/web": ">= 16.5",
    "node:stream/web": ">= 16.5",
    string_decoder: !0,
    "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
    sys: [">= 0.4 && < 0.7", ">= 0.8"],
    "node:sys": [">= 14.18 && < 15", ">= 16"],
    "node:test": ">= 18",
    timers: !0,
    "node:timers": [">= 14.18 && < 15", ">= 16"],
    "timers/promises": ">= 15",
    "node:timers/promises": ">= 16",
    Ft: ">= 0.11.13",
    "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
    Jt: ">= 0.11.3 && < 10",
    zt: ">= 0.11.3",
    "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
    tls: !0,
    "node:tls": [">= 14.18 && < 15", ">= 16"],
    trace_events: ">= 10",
    "node:trace_events": [">= 14.18 && < 15", ">= 16"],
    tty: !0,
    "node:tty": [">= 14.18 && < 15", ">= 16"],
    url: !0,
    "node:url": [">= 14.18 && < 15", ">= 16"],
    util: !0,
    "node:util": [">= 14.18 && < 15", ">= 16"],
    "util/types": ">= 15.3",
    "node:util/types": ">= 16",
    "v8/tools/arguments": ">= 10 && < 12",
    "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    v8: ">= 1",
    "node:v8": [">= 14.18 && < 15", ">= 16"],
    vm: !0,
    "node:vm": [">= 14.18 && < 15", ">= 16"],
    wasi: ">= 13.4 && < 13.5",
    worker_threads: ">= 11.7",
    "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
    zlib: ">= 0.5",
    "node:zlib": [">= 14.18 && < 15", ">= 16"],
  },
  qy =
    (process.versions &&
      process.versions.node &&
      process.versions.node.split(".")) ||
    [];
function tR(t) {
  for (
    var n = t.split(" "),
      e = n.length > 1 ? n[0] : "=",
      r = (n.length > 1 ? n[1] : n[0]).split("."),
      o = 0;
    o < 3;
    ++o
  ) {
    var i = parseInt(qy[o] || 0, 10),
      s = parseInt(r[o] || 0, 10);
    if (i !== s) return "<" === e ? i < s : ">=" === e && i >= s;
  }
  return ">=" === e;
}
function nR(t) {
  var n = t.split(/ ?&& ?/);
  if (0 === n.length) return !1;
  for (var e = 0; e < n.length; ++e) if (!tR(n[e])) return !1;
  return !0;
}
function eR(t) {
  if ("boolean" == typeof t) return t;
  if (t && "object" == typeof t) {
    for (var n = 0; n < t.length; ++n) if (nR(t[n])) return !0;
    return !1;
  }
  return nR(t);
}
var rR = $y,
  oR = {};
for (var iR in rR)
  Object.prototype.hasOwnProperty.call(rR, iR) && (oR[iR] = eR(rR[iR]));
var sR = oR,
  uR = Xy,
  cR = Xy,
  aR = o,
  lR = n,
  fR = yy,
  dR = Ry,
  hR = Cy,
  pR = Ly,
  SR =
    "win32" !== process.platform &&
    aR.realpathSync &&
    "function" == typeof aR.realpathSync.native
      ? aR.realpathSync.native
      : aR.realpathSync,
  ER = fR(),
  mR = function (t) {
    try {
      var n = aR.statSync(t, { throwIfNoEntry: !1 });
    } catch (t) {
      if (t && ("ENOENT" === t.code || "ENOTDIR" === t.code)) return !1;
      throw t;
    }
    return !!n && (n.isFile() || n.isFIFO());
  },
  TR = function (t) {
    try {
      var n = aR.statSync(t, { throwIfNoEntry: !1 });
    } catch (t) {
      if (t && ("ENOENT" === t.code || "ENOTDIR" === t.code)) return !1;
      throw t;
    }
    return !!n && n.isDirectory();
  },
  _R = function (t) {
    try {
      return SR(t);
    } catch (t) {
      if ("ENOENT" !== t.code) throw t;
    }
    return t;
  },
  bR = function (t, n, e) {
    return e && !1 === e.preserveSymlinks ? t(n) : n;
  },
  vR = function (t, n) {
    var e = t(n);
    try {
      return JSON.parse(e);
    } catch (t) {}
  },
  yR = function (t, n, e) {
    var r = e,
      o = n;
    if (("function" == typeof n && ((r = o), (o = {})), "string" != typeof t)) {
      var i = new TypeError("Path must be a string.");
      return process.nextTick(function () {
        r(i);
      });
    }
    var s = (o = jy(t, o)).isFile || By,
      u = o.isDirectory || Fy,
      c = o.readFile || Uy.readFile,
      a = o.realpath || Jy,
      l = o.readPackage || Qy;
    if (o.readFile && o.readPackage) {
      var f = new TypeError(
        "`readFile` and `readPackage` are mutually exclusive."
      );
      return process.nextTick(function () {
        r(f);
      });
    }
    var d = o.packageIterator,
      h = o.extensions || [".js"],
      p = !1 !== o.includeCoreModules,
      S = o.basedir || Yy.dirname(Hy()),
      E = o.filename || S;
    o.paths = o.paths || [
      Yy.join(Ky, ".node_modules"),
      Yy.join(Ky, ".node_libraries"),
    ];
    var m,
      T = Yy.resolve(S);
    function _(n, e, i) {
      n
        ? r(n)
        : e
          ? r(null, e, i)
          : y(m, function (n, e, i) {
              if (n) r(n);
              else if (e)
                zy(a, e, o, function (t, n) {
                  t ? r(t) : r(null, n, i);
                });
              else {
                var s = new Error(
                  "Cannot find module '" + t + "' from '" + E + "'"
                );
                (s.code = "MODULE_NOT_FOUND"), r(s);
              }
            });
    }
    function b(t, n, e) {
      var r = n,
        i = e;
      "function" == typeof r && ((i = r), (r = void 0)),
        (function t(n, e, r) {
          if (0 === n.length) return i(null, void 0, r);
          var u = e + n[0],
            c = r;
          c ? a(null, c) : v(Yy.dirname(u), a);
          function a(r, a, f) {
            if (((c = a), r)) return i(r);
            if (f && c && o.pathFilter) {
              var d = Yy.relative(f, u),
                p = d.slice(0, d.length - n[0].length),
                S = o.pathFilter(c, e, p);
              if (S) return t([""].concat(h.slice()), Yy.resolve(f, S), c);
            }
            s(u, l);
          }
          function l(r, o) {
            return r ? i(r) : o ? i(null, u, c) : void t(n.slice(1), e, c);
          }
        })([""].concat(h), t, r);
    }
    function v(t, n) {
      return "" === t ||
        "/" === t ||
        ("win32" === process.platform && /^\w:[/\\]*$/.test(t)) ||
        /[/\\]node_modules[/\\]*$/.test(t)
        ? n(null)
        : void zy(a, t, o, function (e, r) {
            if (e) return v(Yy.dirname(t), n);
            var i = Yy.join(r, "package.json");
            s(i, function (e, r) {
              if (!r) return v(Yy.dirname(t), n);
              l(c, i, function (e, r) {
                e && n(e);
                var s = r;
                s && o.packageFilter && (s = o.packageFilter(s, i)),
                  n(null, s, t);
              });
            });
          });
    }
    function y(t, n, e) {
      var r = e,
        i = n;
      "function" == typeof i && ((r = i), (i = o.package)),
        zy(a, t, o, function (n, e) {
          if (n) return r(n);
          var u = Yy.join(e, "package.json");
          s(u, function (n, e) {
            return n
              ? r(n)
              : e
                ? void l(c, u, function (n, e) {
                    if (n) return r(n);
                    var i = e;
                    if (
                      (i && o.packageFilter && (i = o.packageFilter(i, u)),
                      i && i.main)
                    ) {
                      if ("string" != typeof i.main) {
                        var s = new TypeError(
                          "package " + i.name + " `main` must be a string"
                        );
                        return (s.code = "INVALID_PACKAGE_MAIN"), r(s);
                      }
                      return (
                        ("." !== i.main && "./" !== i.main) ||
                          (i.main = "index"),
                        void b(Yy.resolve(t, i.main), i, function (n, e, o) {
                          return n
                            ? r(n)
                            : e
                              ? r(null, e, o)
                              : o
                                ? void y(
                                    Yy.resolve(t, o.main),
                                    o,
                                    function (n, e, o) {
                                      return n
                                        ? r(n)
                                        : e
                                          ? r(null, e, o)
                                          : void b(Yy.join(t, "index"), o, r);
                                    }
                                  )
                                : b(Yy.join(t, "index"), o, r);
                        })
                      );
                    }
                    b(Yy.join(t, "/index"), i, r);
                  })
                : b(Yy.join(t, "index"), i, r);
          });
        });
    }
    function R(t, n) {
      if (0 === n.length) return t(null, void 0);
      var e = n[0];
      function r(n, r, s) {
        return n ? t(n) : r ? t(null, r, s) : void y(e, o.package, i);
      }
      function i(e, r, o) {
        return e ? t(e) : r ? t(null, r, o) : void R(t, n.slice(1));
      }
      u(Yy.dirname(e), function (i, s) {
        if (i) return t(i);
        if (!s) return R(t, n.slice(1));
        b(e, o.package, r);
      });
    }
    zy(a, T, o, function (n, e) {
      n
        ? r(n)
        : (function (n) {
            if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(t))
              (m = Yy.resolve(n, t)),
                ("." !== t && ".." !== t && "/" !== t.slice(-1)) || (m += "/"),
                /\/$/.test(t) && m === n
                  ? y(m, o.package, _)
                  : b(m, o.package, _);
            else {
              if (p && xy(t)) return r(null, t);
              !(function (t, n, e) {
                var r = function () {
                  return (function (t, n, e) {
                    for (var r = Dy(n, e, t), o = 0; o < r.length; o++)
                      r[o] = Yy.join(r[o], t);
                    return r;
                  })(t, n, o);
                };
                R(e, d ? d(t, n, r, o) : r());
              })(t, n, function (n, e, i) {
                if (n) r(n);
                else {
                  if (e)
                    return zy(a, e, o, function (t, n) {
                      t ? r(t) : r(null, n, i);
                    });
                  var s = new Error(
                    "Cannot find module '" + t + "' from '" + E + "'"
                  );
                  (s.code = "MODULE_NOT_FOUND"), r(s);
                }
              });
            }
          })(e);
    });
  };
(yR.core = sR),
  (yR.isCore = function (t) {
    return uR(t);
  }),
  (yR.sync = function (t, n) {
    if ("string" != typeof t) throw new TypeError("Path must be a string.");
    var e = pR(t, n),
      r = e.isFile || mR,
      o = e.readFileSync || aR.readFileSync,
      i = e.isDirectory || TR,
      s = e.realpathSync || _R,
      u = e.readPackageSync || vR;
    if (e.readFileSync && e.readPackageSync)
      throw new TypeError(
        "`readFileSync` and `readPackageSync` are mutually exclusive."
      );
    var c = e.packageIterator,
      a = e.extensions || [".js"],
      l = !1 !== e.includeCoreModules,
      f = e.basedir || lR.dirname(dR()),
      d = e.filename || f;
    e.paths = e.paths || [
      lR.join(ER, ".node_modules"),
      lR.join(ER, ".node_libraries"),
    ];
    var h = bR(s, lR.resolve(f), e);
    if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(t)) {
      var p = lR.resolve(h, t);
      ("." !== t && ".." !== t && "/" !== t.slice(-1)) || (p += "/");
      var S = T(p) || b(p);
      if (S) return bR(s, S, e);
    } else {
      if (l && cR(t)) return t;
      var E = (function (t, n) {
        for (
          var r = function () {
              return (function (t, n, e) {
                for (var r = hR(n, e, t), o = 0; o < r.length; o++)
                  r[o] = lR.join(r[o], t);
                return r;
              })(t, n, e);
            },
            o = c ? c(t, n, r, e) : r(),
            s = 0;
          s < o.length;
          s++
        ) {
          var u = o[s];
          if (i(lR.dirname(u))) {
            var a = T(u);
            if (a) return a;
            var l = b(u);
            if (l) return l;
          }
        }
      })(t, h);
      if (E) return bR(s, E, e);
    }
    var m = new Error("Cannot find module '" + t + "' from '" + d + "'");
    throw ((m.code = "MODULE_NOT_FOUND"), m);
    function T(t) {
      var n = _(lR.dirname(t));
      if (n && n.dir && n.pkg && e.pathFilter) {
        var o = lR.relative(n.dir, t),
          i = e.pathFilter(n.pkg, t, o);
        i && (t = lR.resolve(n.dir, i));
      }
      if (r(t)) return t;
      for (var s = 0; s < a.length; s++) {
        var u = t + a[s];
        if (r(u)) return u;
      }
    }
    function _(t) {
      if (
        "" !== t &&
        "/" !== t &&
        !(
          ("win32" === process.platform && /^\w:[/\\]*$/.test(t)) ||
          /[/\\]node_modules[/\\]*$/.test(t)
        )
      ) {
        var n = lR.join(bR(s, t, e), "package.json");
        if (!r(n)) return _(lR.dirname(t));
        var i = u(o, n);
        return (
          i && e.packageFilter && (i = e.packageFilter(i, t)),
          { pkg: i, dir: t }
        );
      }
    }
    function b(t) {
      var n = lR.join(bR(s, t, e), "/package.json");
      if (r(n)) {
        try {
          var i = u(o, n);
        } catch (t) {}
        if (
          (i && e.packageFilter && (i = e.packageFilter(i, t)), i && i.main)
        ) {
          if ("string" != typeof i.main) {
            var c = new TypeError(
              "package " + i.name + " `main` must be a string"
            );
            throw ((c.code = "INVALID_PACKAGE_MAIN"), c);
          }
          ("." !== i.main && "./" !== i.main) || (i.main = "index");
          try {
            var a = T(lR.resolve(t, i.main));
            if (a) return a;
            var l = b(lR.resolve(t, i.main));
            if (l) return l;
          } catch (t) {}
        }
      }
      return T(lR.join(t, "/index"));
    }
  });
var RR,
  AR,
  OR,
  gR,
  NR,
  CR = yR,
  LR = { exports: {} },
  IR = { exports: {} };
function MR() {
  if (AR) return RR;
  AR = 1;
  var t = 1e3,
    n = 60 * t,
    e = 60 * n,
    r = 24 * e,
    o = 7 * r,
    i = 365.25 * r;
  function s(t, n, e, r) {
    var o = n >= 1.5 * e;
    return Math.round(t / e) + " " + r + (o ? "s" : "");
  }
  return (RR = function (u, c) {
    c = c || {};
    var a = typeof u;
    if ("string" === a && u.length > 0)
      return (function (s) {
        if ((s = String(s)).length > 100) return;
        var u =
          /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
            s
          );
        if (!u) return;
        var c = parseFloat(u[1]);
        switch ((u[2] || "ms").toLowerCase()) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return c * i;
          case "weeks":
          case "week":
          case "w":
            return c * o;
          case "days":
          case "day":
          case "d":
            return c * r;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return c * e;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return c * n;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return c * t;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return c;
          default:
            return;
        }
      })(u);
    if ("number" === a && isFinite(u))
      return c.long
        ? (function (o) {
            var i = Math.abs(o);
            if (i >= r) return s(o, i, r, "day");
            if (i >= e) return s(o, i, e, "hour");
            if (i >= n) return s(o, i, n, "minute");
            if (i >= t) return s(o, i, t, "second");
            return o + " ms";
          })(u)
        : (function (o) {
            var i = Math.abs(o);
            if (i >= r) return Math.round(o / r) + "d";
            if (i >= e) return Math.round(o / e) + "h";
            if (i >= n) return Math.round(o / n) + "m";
            if (i >= t) return Math.round(o / t) + "s";
            return o + "ms";
          })(u);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" +
        JSON.stringify(u)
    );
  });
}
function wR() {
  if (gR) return OR;
  return (
    (gR = 1),
    (OR = function (t) {
      function n(t) {
        let r,
          o,
          i,
          s = null;
        function u(...t) {
          if (!u.enabled) return;
          const e = u,
            o = Number(new Date()),
            i = o - (r || o);
          (e.diff = i),
            (e.prev = r),
            (e.curr = o),
            (r = o),
            (t[0] = n.coerce(t[0])),
            "string" != typeof t[0] && t.unshift("%O");
          let s = 0;
          (t[0] = t[0].replace(/%([a-zA-Z%])/g, (r, o) => {
            if ("%%" === r) return "%";
            s++;
            const i = n.formatters[o];
            if ("function" == typeof i) {
              const n = t[s];
              (r = i.call(e, n)), t.splice(s, 1), s--;
            }
            return r;
          })),
            n.formatArgs.call(e, t);
          (e.log || n.log).apply(e, t);
        }
        return (
          (u.namespace = t),
          (u.useColors = n.useColors()),
          (u.color = n.selectColor(t)),
          (u.extend = e),
          (u.destroy = n.destroy),
          Object.defineProperty(u, "enabled", {
            enumerable: !0,
            configurable: !1,
            get: () =>
              null !== s
                ? s
                : (o !== n.namespaces &&
                    ((o = n.namespaces), (i = n.enabled(t))),
                  i),
            set: (t) => {
              s = t;
            },
          }),
          "function" == typeof n.init && n.init(u),
          u
        );
      }
      function e(t, e) {
        const r = n(this.namespace + (void 0 === e ? ":" : e) + t);
        return (r.log = this.log), r;
      }
      function r(t) {
        return t
          .toString()
          .substring(2, t.toString().length - 2)
          .replace(/\.\*\?$/, "*");
      }
      return (
        (n.debug = n),
        (n.default = n),
        (n.coerce = function (t) {
          if (t instanceof Error) return t.stack || t.message;
          return t;
        }),
        (n.disable = function () {
          const t = [
            ...n.names.map(r),
            ...n.skips.map(r).map((t) => "-" + t),
          ].join(",");
          return n.enable(""), t;
        }),
        (n.enable = function (t) {
          let e;
          n.save(t), (n.namespaces = t), (n.names = []), (n.skips = []);
          const r = ("string" == typeof t ? t : "").split(/[\s,]+/),
            o = r.length;
          for (e = 0; e < o; e++)
            r[e] &&
              ("-" === (t = r[e].replace(/\*/g, ".*?"))[0]
                ? n.skips.push(new RegExp("^" + t.slice(1) + "$"))
                : n.names.push(new RegExp("^" + t + "$")));
        }),
        (n.enabled = function (t) {
          if ("*" === t[t.length - 1]) return !0;
          let e, r;
          for (e = 0, r = n.skips.length; e < r; e++)
            if (n.skips[e].test(t)) return !1;
          for (e = 0, r = n.names.length; e < r; e++)
            if (n.names[e].test(t)) return !0;
          return !1;
        }),
        (n.humanize = MR()),
        (n.destroy = function () {
          console.warn(
            "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
          );
        }),
        Object.keys(t).forEach((e) => {
          n[e] = t[e];
        }),
        (n.names = []),
        (n.skips = []),
        (n.formatters = {}),
        (n.selectColor = function (t) {
          let e = 0;
          for (let n = 0; n < t.length; n++)
            (e = (e << 5) - e + t.charCodeAt(n)), (e |= 0);
          return n.colors[Math.abs(e) % n.colors.length];
        }),
        n.enable(n.load()),
        n
      );
    }),
    OR
  );
}
var ZR,
  PR,
  VR,
  GR,
  XR,
  UR = { exports: {} };
function WR() {
  return PR
    ? ZR
    : ((PR = 1),
      (ZR = (t, n = process.argv) => {
        const e = t.startsWith("-") ? "" : 1 === t.length ? "-" : "--",
          r = n.indexOf(e + t),
          o = n.indexOf("--");
        return -1 !== r && (-1 === o || r < o);
      }));
}
"undefined" == typeof process ||
"renderer" === process.type ||
!0 === process.browser ||
process.__nwjs
  ? (LR.exports =
      (NR ||
        ((NR = 1),
        (function (t, n) {
          (n.formatArgs = function (n) {
            if (
              ((n[0] =
                (this.useColors ? "%c" : "") +
                this.namespace +
                (this.useColors ? " %c" : " ") +
                n[0] +
                (this.useColors ? "%c " : " ") +
                "+" +
                t.exports.humanize(this.diff)),
              !this.useColors)
            )
              return;
            const e = "color: " + this.color;
            n.splice(1, 0, e, "color: inherit");
            let r = 0,
              o = 0;
            n[0].replace(/%[a-zA-Z%]/g, (t) => {
              "%%" !== t && (r++, "%c" === t && (o = r));
            }),
              n.splice(o, 0, e);
          }),
            (n.save = function (t) {
              try {
                t
                  ? n.storage.setItem("debug", t)
                  : n.storage.removeItem("debug");
              } catch (t) {}
            }),
            (n.load = function () {
              let t;
              try {
                t = n.storage.getItem("debug");
              } catch (t) {}
              return (
                !t &&
                  "undefined" != typeof process &&
                  "env" in process &&
                  (t = process.env.DEBUG),
                t
              );
            }),
            (n.useColors = function () {
              return (
                !(
                  "undefined" == typeof window ||
                  !window.process ||
                  ("renderer" !== window.process.type && !window.process.__nwjs)
                ) ||
                (("undefined" == typeof navigator ||
                  !navigator.userAgent ||
                  !navigator.userAgent
                    .toLowerCase()
                    .match(/(edge|trident)\/(\d+)/)) &&
                  (("undefined" != typeof document &&
                    document.documentElement &&
                    document.documentElement.style &&
                    document.documentElement.style.WebkitAppearance) ||
                    ("undefined" != typeof window &&
                      window.console &&
                      (window.console.firebug ||
                        (window.console.exception && window.console.table))) ||
                    ("undefined" != typeof navigator &&
                      navigator.userAgent &&
                      navigator.userAgent
                        .toLowerCase()
                        .match(/firefox\/(\d+)/) &&
                      parseInt(RegExp.$1, 10) >= 31) ||
                    ("undefined" != typeof navigator &&
                      navigator.userAgent &&
                      navigator.userAgent
                        .toLowerCase()
                        .match(/applewebkit\/(\d+)/))))
              );
            }),
            (n.storage = (function () {
              try {
                return localStorage;
              } catch (t) {}
            })()),
            (n.destroy = (() => {
              let t = !1;
              return () => {
                t ||
                  ((t = !0),
                  console.warn(
                    "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
                  ));
              };
            })()),
            (n.colors = [
              "#0000CC",
              "#0000FF",
              "#0033CC",
              "#0033FF",
              "#0066CC",
              "#0066FF",
              "#0099CC",
              "#0099FF",
              "#00CC00",
              "#00CC33",
              "#00CC66",
              "#00CC99",
              "#00CCCC",
              "#00CCFF",
              "#3300CC",
              "#3300FF",
              "#3333CC",
              "#3333FF",
              "#3366CC",
              "#3366FF",
              "#3399CC",
              "#3399FF",
              "#33CC00",
              "#33CC33",
              "#33CC66",
              "#33CC99",
              "#33CCCC",
              "#33CCFF",
              "#6600CC",
              "#6600FF",
              "#6633CC",
              "#6633FF",
              "#66CC00",
              "#66CC33",
              "#9900CC",
              "#9900FF",
              "#9933CC",
              "#9933FF",
              "#99CC00",
              "#99CC33",
              "#CC0000",
              "#CC0033",
              "#CC0066",
              "#CC0099",
              "#CC00CC",
              "#CC00FF",
              "#CC3300",
              "#CC3333",
              "#CC3366",
              "#CC3399",
              "#CC33CC",
              "#CC33FF",
              "#CC6600",
              "#CC6633",
              "#CC9900",
              "#CC9933",
              "#CCCC00",
              "#CCCC33",
              "#FF0000",
              "#FF0033",
              "#FF0066",
              "#FF0099",
              "#FF00CC",
              "#FF00FF",
              "#FF3300",
              "#FF3333",
              "#FF3366",
              "#FF3399",
              "#FF33CC",
              "#FF33FF",
              "#FF6600",
              "#FF6633",
              "#FF9900",
              "#FF9933",
              "#FFCC00",
              "#FFCC33",
            ]),
            (n.log = console.debug || console.log || (() => {})),
            (t.exports = wR()(n));
          const { formatters: e } = t.exports;
          e.j = function (t) {
            try {
              return JSON.stringify(t);
            } catch (t) {
              return "[UnexpectedJSONParseError]: " + t.message;
            }
          };
        })(IR, IR.exports)),
      IR.exports))
  : (LR.exports =
      (XR ||
        ((XR = 1),
        (function (t, n) {
          const r = s,
            o = e;
          (n.init = function (t) {
            t.inspectOpts = {};
            const e = Object.keys(n.inspectOpts);
            for (let r = 0; r < e.length; r++)
              t.inspectOpts[e[r]] = n.inspectOpts[e[r]];
          }),
            (n.log = function (...t) {
              return process.stderr.write(o.format(...t) + "\n");
            }),
            (n.formatArgs = function (e) {
              const { namespace: r, useColors: o } = this;
              if (o) {
                const n = this.color,
                  o = "[3" + (n < 8 ? n : "8;5;" + n),
                  i = `  ${o};1m${r} [0m`;
                (e[0] = i + e[0].split("\n").join("\n" + i)),
                  e.push(o + "m+" + t.exports.humanize(this.diff) + "[0m");
              } else
                e[0] =
                  (n.inspectOpts.hideDate
                    ? ""
                    : new Date().toISOString() + " ") +
                  r +
                  " " +
                  e[0];
            }),
            (n.save = function (t) {
              t ? (process.env.DEBUG = t) : delete process.env.DEBUG;
            }),
            (n.load = function () {
              return process.env.DEBUG;
            }),
            (n.useColors = function () {
              return "colors" in n.inspectOpts
                ? Boolean(n.inspectOpts.colors)
                : r.isatty(process.stderr.fd);
            }),
            (n.destroy = o.deprecate(
              () => {},
              "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
            )),
            (n.colors = [6, 2, 3, 4, 5, 1]);
          try {
            const t = (function () {
              if (GR) return VR;
              GR = 1;
              const t = i,
                n = s,
                e = WR(),
                { env: r } = process;
              let o;
              function u(t) {
                return (
                  0 !== t && {
                    level: t,
                    hasBasic: !0,
                    has256: t >= 2,
                    has16m: t >= 3,
                  }
                );
              }
              function c(n, i) {
                if (0 === o) return 0;
                if (e("color=16m") || e("color=full") || e("color=truecolor"))
                  return 3;
                if (e("color=256")) return 2;
                if (n && !i && void 0 === o) return 0;
                const s = o || 0;
                if ("dumb" === r.TERM) return s;
                if ("win32" === process.platform) {
                  const n = t.release().split(".");
                  return Number(n[0]) >= 10 && Number(n[2]) >= 10586
                    ? Number(n[2]) >= 14931
                      ? 3
                      : 2
                    : 1;
                }
                if ("CI" in r)
                  return [
                    "TRAVIS",
                    "CIRCLECI",
                    "APPVEYOR",
                    "GITLAB_CI",
                    "GITHUB_ACTIONS",
                    "BUILDKITE",
                  ].some((t) => t in r) || "codeship" === r.CI_NAME
                    ? 1
                    : s;
                if ("TEAMCITY_VERSION" in r)
                  return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(
                    r.TEAMCITY_VERSION
                  )
                    ? 1
                    : 0;
                if ("truecolor" === r.COLORTERM) return 3;
                if ("TERM_PROGRAM" in r) {
                  const t = parseInt(
                    (r.TERM_PROGRAM_VERSION || "").split(".")[0],
                    10
                  );
                  switch (r.TERM_PROGRAM) {
                    case "iTerm.app":
                      return t >= 3 ? 3 : 2;
                    case "Apple_Terminal":
                      return 2;
                  }
                }
                return /-256(color)?$/i.test(r.TERM)
                  ? 2
                  : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(
                        r.TERM
                      ) || "COLORTERM" in r
                    ? 1
                    : s;
              }
              return (
                e("no-color") ||
                e("no-colors") ||
                e("color=false") ||
                e("color=never")
                  ? (o = 0)
                  : (e("color") ||
                      e("colors") ||
                      e("color=true") ||
                      e("color=always")) &&
                    (o = 1),
                "FORCE_COLOR" in r &&
                  (o =
                    "true" === r.FORCE_COLOR
                      ? 1
                      : "false" === r.FORCE_COLOR
                        ? 0
                        : 0 === r.FORCE_COLOR.length
                          ? 1
                          : Math.min(parseInt(r.FORCE_COLOR, 10), 3)),
                (VR = {
                  supportsColor: function (t) {
                    return u(c(t, t && t.isTTY));
                  },
                  stdout: u(c(!0, n.isatty(1))),
                  stderr: u(c(!0, n.isatty(2))),
                }),
                VR
              );
            })();
            t &&
              (t.stderr || t).level >= 2 &&
              (n.colors = [
                20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57,
                62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99,
                112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164,
                165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185,
                196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208,
                209, 214, 215, 220, 221,
              ]);
          } catch (t) {}
          (n.inspectOpts = Object.keys(process.env)
            .filter((t) => /^debug_/i.test(t))
            .reduce((t, n) => {
              const e = n
                .substring(6)
                .toLowerCase()
                .replace(/_([a-z])/g, (t, n) => n.toUpperCase());
              let r = process.env[n];
              return (
                (r =
                  !!/^(yes|on|true|enabled)$/i.test(r) ||
                  (!/^(no|off|false|disabled)$/i.test(r) &&
                    ("null" === r ? null : Number(r)))),
                (t[e] = r),
                t
              );
            }, {})),
            (t.exports = wR()(n));
          const { formatters: u } = t.exports;
          (u.o = function (t) {
            return (
              (this.inspectOpts.colors = this.useColors),
              o
                .inspect(t, this.inspectOpts)
                .split("\n")
                .map((t) => t.trim())
                .join(" ")
            );
          }),
            (u.O = function (t) {
              return (
                (this.inspectOpts.colors = this.useColors),
                o.inspect(t, this.inspectOpts)
              );
            });
        })(UR, UR.exports)),
      UR.exports));
var YR = LR.exports,
  HR = n,
  DR = function (t) {
    var n = t.split(HR.sep),
      e = n.lastIndexOf("node_modules");
    if (-1 !== e && n[e + 1]) {
      var r = "@" === n[e + 1][0],
        o = r ? 3 : 2;
      return {
        name: r ? n[e + 1] + "/" + n[e + 2] : n[e + 1],
        basedir: n.slice(0, e + o).join(HR.sep),
        path: n.slice(e + o).join(HR.sep),
      };
    }
  },
  jR = { url: "https://github.com/elastic/require-in-the-middle/issues" };
const xR = n,
  kR = r,
  KR = CR,
  BR = YR("require-in-the-middle"),
  FR = DR;
vy.exports = qR;
var JR = (vy.exports.Hook = qR);
let zR;
if (kR.isBuiltin) zR = kR.isBuiltin;
else {
  const [t, n] = process.versions.node.split(".").map(Number);
  zR =
    8 === t && n < 8
      ? (t) => "http2" === t || !!KR.core[t]
      : (t) => !!KR.core[t];
}
const QR = /([/\\]index)?(\.js)?$/;
class $R {
  constructor() {
    (this.Qt = new Map()), (this.$t = Symbol("RitmExports"));
  }
  has(t, n) {
    if (this.Qt.has(t)) return !0;
    if (n) return !1;
    {
      const n = require.cache[t];
      return !(!n || !(this.$t in n));
    }
  }
  get(t, n) {
    const e = this.Qt.get(t);
    if (void 0 !== e) return e;
    if (!n) {
      const n = require.cache[t];
      return n && n[this.$t];
    }
  }
  set(t, n, e) {
    e
      ? this.Qt.set(t, n)
      : t in require.cache
        ? (require.cache[t][this.$t] = n)
        : (BR('non-core module is unexpectedly not in require.cache: "%s"', t),
          this.Qt.set(t, n));
  }
}
function qR(t, n, e) {
  if (this instanceof qR == !1) return new qR(t, n, e);
  if (
    ("function" == typeof t
      ? ((e = t), (t = null), (n = null))
      : "function" == typeof n && ((e = n), (n = null)),
    "function" != typeof kR.qt)
  )
    return (
      console.error(
        "Error: Expected Module._resolveFilename to be a function (was: %s) - aborting!",
        typeof kR.qt
      ),
      void console.error(
        "Please report this error as an issue related to Node.js %s at %s",
        process.version,
        jR.url
      )
    );
  (this.N = new $R()), (this.tn = !1), (this.nn = kR.prototype.require);
  const r = this,
    o = new Set(),
    i = !!n && !0 === n.internals,
    s = Array.isArray(t);
  BR("registering require hook"),
    (this.en = kR.prototype.require =
      function (n) {
        if (!0 === r.tn)
          return (
            BR("ignoring require call - module is soft-unhooked"),
            r.nn.apply(this, arguments)
          );
        const u = zR(n);
        let c, a, l;
        if (u) {
          if (((c = n), n.startsWith("node:"))) {
            const t = n.slice(5);
            zR(t) && (c = t);
          }
        } else
          try {
            c = kR.qt(n, this);
          } catch (t) {
            return (
              BR(
                'Module._resolveFilename("%s") threw %j, calling original Module.require',
                n,
                t.message
              ),
              r.nn.apply(this, arguments)
            );
          }
        if (
          (BR(
            "processing %s module require('%s'): %s",
            !0 === u ? "core" : "non-core",
            n,
            c
          ),
          !0 === r.N.has(c, u))
        )
          return (
            BR("returning already patched cached module: %s", c), r.N.get(c, u)
          );
        const f = o.has(c);
        !1 === f && o.add(c);
        const d = r.nn.apply(this, arguments);
        if (!0 === f)
          return (
            BR(
              "module is in the process of being patched already - ignoring: %s",
              c
            ),
            d
          );
        if ((o.delete(c), !0 === u)) {
          if (!0 === s && !1 === t.includes(c))
            return BR("ignoring core module not on whitelist: %s", c), d;
          a = c;
        } else if (!0 === s && t.includes(c)) {
          const t = xR.parse(c);
          (a = t.name), (l = t.dir);
        } else {
          const e = FR(c);
          if (void 0 === e) return BR("could not parse filename: %s", c), d;
          (a = e.name), (l = e.basedir);
          const o = (function (t) {
            const n = "/" !== xR.sep ? t.path.split(xR.sep).join("/") : t.path;
            return xR.posix.join(t.name, n).replace(QR, "");
          })(e);
          if (
            (BR(
              "resolved filename to module: %s (id: %s, resolved: %s, basedir: %s)",
              a,
              n,
              o,
              l
            ),
            !0 === s && !1 === t.includes(a))
          ) {
            if (!1 === t.includes(o)) return d;
            a = o;
          } else {
            let t;
            try {
              t = KR.sync(a, { basedir: l });
            } catch (t) {
              return BR("could not resolve module: %s", a), r.N.set(c, d, u), d;
            }
            if (t !== c) {
              if (!0 !== i)
                return (
                  BR("ignoring require of non-main module file: %s", t),
                  r.N.set(c, d, u),
                  d
                );
              (a = a + xR.sep + xR.relative(l, c)),
                BR("preparing to process require of internal file: %s", a);
            }
          }
        }
        r.N.set(c, d, u), BR("calling require hook: %s", a);
        const h = e(d, a, l);
        return r.N.set(c, h, u), BR("returning module: %s", a), h;
      });
}
qR.prototype.unhook = function () {
  (this.tn = !0),
    this.en === kR.prototype.require
      ? ((kR.prototype.require = this.nn), BR("unhook successful"))
      : BR("unhook unsuccessful");
};
var tA = function (t) {
    var n = "function" == typeof Symbol && Symbol.iterator,
      e = n && t[n],
      r = 0;
    if (e) return e.call(t);
    if (t && "number" == typeof t.length)
      return {
        next: function () {
          return (
            t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t }
          );
        },
      };
    throw new TypeError(
      n ? "Object is not iterable." : "Symbol.iterator is not defined."
    );
  },
  nA = function (t, n) {
    var e = "function" == typeof Symbol && t[Symbol.iterator];
    if (!e) return t;
    var r,
      o,
      i = e.call(t),
      s = [];
    try {
      for (; (void 0 === n || n-- > 0) && !(r = i.next()).done; )
        s.push(r.value);
    } catch (t) {
      o = { error: t };
    } finally {
      try {
        r && !r.done && (e = i.return) && e.call(i);
      } finally {
        if (o) throw o.error;
      }
    }
    return s;
  },
  eA = function (t, n, e) {
    if (e || 2 === arguments.length)
      for (var r, o = 0, i = n.length; o < i; o++)
        (!r && o in n) ||
          (r || (r = Array.prototype.slice.call(n, 0, o)), (r[o] = n[o]));
    return t.concat(r || Array.prototype.slice.call(n));
  },
  rA = "/",
  oA = function () {
    (this.hooks = []), (this.children = new Map());
  },
  iA = (function () {
    function t() {
      (this.rn = new oA()), (this.sn = 0);
    }
    return (
      (t.prototype.insert = function (t) {
        var n,
          e,
          r = this.rn;
        try {
          for (
            var o = tA(t.moduleName.split(rA)), i = o.next();
            !i.done;
            i = o.next()
          ) {
            var s = i.value,
              u = r.children.get(s);
            u || ((u = new oA()), r.children.set(s, u)), (r = u);
          }
        } catch (t) {
          n = { error: t };
        } finally {
          try {
            i && !i.done && (e = o.return) && e.call(o);
          } finally {
            if (n) throw n.error;
          }
        }
        r.hooks.push({ hook: t, insertedId: this.sn++ });
      }),
      (t.prototype.search = function (t, n) {
        var e,
          r,
          o = void 0 === n ? {} : n,
          i = o.maintainInsertionOrder,
          s = o.fullOnly,
          u = this.rn,
          c = [],
          a = !0;
        try {
          for (var l = tA(t.split(rA)), f = l.next(); !f.done; f = l.next()) {
            var d = f.value,
              h = u.children.get(d);
            if (!h) {
              a = !1;
              break;
            }
            s || c.push.apply(c, eA([], nA(h.hooks), !1)), (u = h);
          }
        } catch (t) {
          e = { error: t };
        } finally {
          try {
            f && !f.done && (r = l.return) && r.call(l);
          } finally {
            if (e) throw e.error;
          }
        }
        return (
          s && a && c.push.apply(c, eA([], nA(u.hooks), !1)),
          0 === c.length
            ? []
            : 1 === c.length
              ? [c[0].hook]
              : (i &&
                  c.sort(function (t, n) {
                    return t.insertedId - n.insertedId;
                  }),
                c.map(function (t) {
                  return t.hook;
                }))
        );
      }),
      t
    );
  })(),
  sA = function (t) {
    var n = "function" == typeof Symbol && Symbol.iterator,
      e = n && t[n],
      r = 0;
    if (e) return e.call(t);
    if (t && "number" == typeof t.length)
      return {
        next: function () {
          return (
            t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t }
          );
        },
      };
    throw new TypeError(
      n ? "Object is not iterable." : "Symbol.iterator is not defined."
    );
  },
  uA = ["afterEach", "after", "beforeEach", "before", "describe", "it"].every(
    function (t) {
      return "function" == typeof global[t];
    }
  ),
  cA = (function () {
    function t() {
      (this.un = new iA()), this.cn();
    }
    return (
      (t.prototype.cn = function () {
        var t = this;
        new JR(null, { internals: !0 }, function (n, e, r) {
          var o,
            i,
            s,
            u = ((s = e), A.sep !== rA ? s.split(A.sep).join(rA) : s),
            c = t.un.search(u, {
              maintainInsertionOrder: !0,
              fullOnly: void 0 === r,
            });
          try {
            for (var a = sA(c), l = a.next(); !l.done; l = a.next()) {
              n = (0, l.value.onRequire)(n, e, r);
            }
          } catch (t) {
            o = { error: t };
          } finally {
            try {
              l && !l.done && (i = a.return) && i.call(a);
            } finally {
              if (o) throw o.error;
            }
          }
          return n;
        });
      }),
      (t.prototype.register = function (t, n) {
        var e = { moduleName: t, onRequire: n };
        return this.un.insert(e), e;
      }),
      (t.getInstance = function () {
        var n;
        return uA
          ? new t()
          : (this.L = null !== (n = this.L) && void 0 !== n ? n : new t());
      }),
      t
    );
  })();
var aA = { exports: {} },
  lA = {};
const fA = [],
  dA = new WeakMap(),
  hA = new Map(),
  pA = [],
  SA = {
    set: (t, n, e) => dA.get(t)[n](e),
    defineProperty(t, n, e) {
      if (!("value" in e))
        throw new Error(
          "Getters/setters are not supported for exports property descriptors."
        );
      return dA.get(t)[n](e.value);
    },
  };
(lA.register = function (t, n, e, r) {
  hA.set(t, r), dA.set(n, e);
  const o = new Proxy(n, SA);
  fA.forEach((n) => n(t, o)), pA.push([t, o]);
}),
  (lA.importHooks = fA),
  (lA.specifiers = hA),
  (lA.toHook = pA);
const EA = n,
  mA = DR,
  { fileURLToPath: TA } = u,
  { importHooks: _A, specifiers: bA, toHook: vA } = lA;
function yA(t) {
  _A.push(t), vA.forEach(([n, e]) => t(n, e));
}
function RA(t) {
  const n = _A.indexOf(t);
  n > -1 && _A.splice(n, 1);
}
function AA(t, n, e, r) {
  const o = t(n, e, r);
  o && o !== n && (n.default = o);
}
function OA(t, n, e) {
  if (this instanceof OA == !1) return new OA(t, n, e);
  "function" == typeof t
    ? ((e = t), (t = null), (n = null))
    : "function" == typeof n && ((e = n), (n = null));
  const r = !!n && !0 === n.internals;
  (this.an = (n, o) => {
    const i = n;
    let s;
    if (n.startsWith("node:")) n = n.replace(/^node:/, "");
    else {
      if (n.startsWith("file://"))
        try {
          n = TA(n);
        } catch (t) {}
      const t = mA(n);
      t && ((n = t.name), (s = t.basedir));
    }
    if (t) {
      for (const u of t)
        if (u === n) {
          if (s)
            if (r) n = n + EA.sep + EA.relative(s, TA(i));
            else if (!s.endsWith(bA.get(i))) continue;
          AA(e, o, n, s);
        }
    } else AA(e, o, n, s);
  }),
    yA(this.an);
}
(OA.prototype.unhook = function () {
  RA(this.an);
}),
  (aA.exports = OA);
var gA = (aA.exports.addHook = yA),
  NA = (aA.exports.removeHook = RA),
  CA = aA.exports,
  LA = R({ __proto__: null, addHook: gA, default: Yt(CA), removeHook: NA }, [
    CA,
  ]),
  IA = (function () {
    var t = function (n, e) {
      return (
        (t =
          Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array &&
            function (t, n) {
              t.__proto__ = n;
            }) ||
          function (t, n) {
            for (var e in n)
              Object.prototype.hasOwnProperty.call(n, e) && (t[e] = n[e]);
          }),
        t(n, e)
      );
    };
    return function (n, e) {
      if ("function" != typeof e && null !== e)
        throw new TypeError(
          "Class extends value " + String(e) + " is not a constructor or null"
        );
      function r() {
        this.constructor = n;
      }
      t(n, e),
        (n.prototype =
          null === e
            ? Object.create(e)
            : ((r.prototype = e.prototype), new r()));
    };
  })(),
  MA = function (t) {
    var n = "function" == typeof Symbol && Symbol.iterator,
      e = n && t[n],
      r = 0;
    if (e) return e.call(t);
    if (t && "number" == typeof t.length)
      return {
        next: function () {
          return (
            t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t }
          );
        },
      };
    throw new TypeError(
      n ? "Object is not iterable." : "Symbol.iterator is not defined."
    );
  },
  wA = (function (t) {
    function n(n, r, o) {
      void 0 === o && (o = {});
      var i = t.call(this, n, r, o) || this;
      (i.ln = []),
        (i.fn = cA.getInstance()),
        (i.dn = !1),
        (i.yt = function (t, n, r) {
          if (e.types.isProxy(t)) {
            var o = Ty.wrap(Object.assign({}, t), n, r);
            return Object.defineProperty(t, n, { value: o });
          }
          return Ty.wrap(t, n, r);
        }),
        (i.Rt = function (t, n) {
          return e.types.isProxy(t)
            ? Object.defineProperty(t, n, { value: t[n] })
            : Ty.unwrap(t, n);
        }),
        (i.At = function (t, n, e) {
          t
            ? (Array.isArray(t) || (t = [t]),
              n && Array.isArray(n)
                ? t.forEach(function (t) {
                    n.forEach(function (n) {
                      i.yt(t, n, e);
                    });
                  })
                : Pr.error(
                    "must provide one or more functions to wrap on modules"
                  ))
            : Pr.error("must provide one or more modules to patch");
        }),
        (i.Ot = function (t, n) {
          t
            ? (Array.isArray(t) || (t = [t]),
              n && Array.isArray(n)
                ? t.forEach(function (t) {
                    n.forEach(function (n) {
                      i.Rt(t, n);
                    });
                  })
                : Pr.error(
                    "must provide one or more functions to wrap on modules"
                  ))
            : Pr.error("must provide one or more modules to patch");
        });
      var s = i.init();
      return (
        s && !Array.isArray(s) && (s = [s]),
        (i.hn = s || []),
        0 === i.hn.length &&
          Pr.debug(
            "No modules instrumentation has been defined for '" +
              i.instrumentationName +
              "@" +
              i.instrumentationVersion +
              "', nothing will be patched"
          ),
        i.Nt.enabled && i.enable(),
        i
      );
    }
    return (
      IA(n, t),
      (n.prototype.pn = function () {
        var t = this;
        this.hn.forEach(function (n) {
          var e = n.name;
          try {
            var r = require.resolve(e);
            require.cache[r] &&
              t.Ct.warn(
                "Module " +
                  e +
                  " has been loaded before " +
                  t.instrumentationName +
                  " so it might not work, please initialize it before requiring " +
                  e
              );
          } catch (t) {}
        });
      }),
      (n.prototype.Sn = function (t) {
        try {
          var n = o.readFileSync(A.join(t, "package.json"), {
              encoding: "utf8",
            }),
            e = JSON.parse(n).version;
          return "string" == typeof e ? e : void 0;
        } catch (n) {
          Pr.warn("Failed extracting version", t);
        }
      }),
      (n.prototype.En = function (t, n, e, r) {
        var o,
          i = this;
        if (!r)
          return "function" == typeof t.patch &&
            ((t.moduleExports = n), this.dn)
            ? (this.Ct.debug(
                "Applying instrumentation patch for nodejs core module on require hook",
                { module: t.name }
              ),
              t.patch(n))
            : n;
        var s = this.Sn(r);
        if (((t.moduleVersion = s), t.name === e))
          return ZA(t.supportedVersions, s, t.includePrerelease) &&
            "function" == typeof t.patch &&
            ((t.moduleExports = n), this.dn)
            ? (this.Ct.debug(
                "Applying instrumentation patch for module on require hook",
                { module: t.name, version: t.moduleVersion, baseDir: r }
              ),
              t.patch(n, t.moduleVersion))
            : n;
        var u = null !== (o = t.files) && void 0 !== o ? o : [],
          c = A.normalize(e);
        return u
          .filter(function (t) {
            return t.name === c;
          })
          .filter(function (n) {
            return ZA(n.supportedVersions, s, t.includePrerelease);
          })
          .reduce(function (n, e) {
            return (
              (e.moduleExports = n),
              i.dn
                ? (i.Ct.debug(
                    "Applying instrumentation patch for nodejs module file on require hook",
                    {
                      module: t.name,
                      version: t.moduleVersion,
                      fileName: e.name,
                      baseDir: r,
                    }
                  ),
                  e.patch(n, t.moduleVersion))
                : n
            );
          }, n);
      }),
      (n.prototype.enable = function () {
        var t,
          n,
          e,
          r,
          o,
          i,
          s = this;
        if (!this.dn)
          if (((this.dn = !0), this.ln.length > 0))
            try {
              for (var u = MA(this.hn), c = u.next(); !c.done; c = u.next()) {
                var a = c.value;
                "function" == typeof a.patch &&
                  a.moduleExports &&
                  (this.Ct.debug(
                    "Applying instrumentation patch for nodejs module on instrumentation enabled",
                    { module: a.name, version: a.moduleVersion }
                  ),
                  a.patch(a.moduleExports, a.moduleVersion));
                try {
                  for (
                    var l = ((e = void 0), MA(a.files)), f = l.next();
                    !f.done;
                    f = l.next()
                  ) {
                    var d = f.value;
                    d.moduleExports &&
                      (this.Ct.debug(
                        "Applying instrumentation patch for nodejs module file on instrumentation enabled",
                        {
                          module: a.name,
                          version: a.moduleVersion,
                          fileName: d.name,
                        }
                      ),
                      d.patch(d.moduleExports, a.moduleVersion));
                  }
                } catch (t) {
                  e = { error: t };
                } finally {
                  try {
                    f && !f.done && (r = l.return) && r.call(l);
                  } finally {
                    if (e) throw e.error;
                  }
                }
              }
            } catch (n) {
              t = { error: n };
            } finally {
              try {
                c && !c.done && (n = u.return) && n.call(u);
              } finally {
                if (t) throw t.error;
              }
            }
          else {
            this.pn();
            var h = function (t) {
                var n = function (n, e, r) {
                    return s.En(t, n, e, r);
                  },
                  e = A.isAbsolute(t.name)
                    ? new JR([t.name], { internals: !0 }, n)
                    : p.fn.register(t.name, n);
                p.ln.push(e);
                var r = new LA([t.name], { internals: !1 }, function (n, e, r) {
                  return s.En(t, n, e, r);
                });
                p.ln.push(r);
              },
              p = this;
            try {
              for (var S = MA(this.hn), E = S.next(); !E.done; E = S.next()) {
                h(E.value);
              }
            } catch (t) {
              o = { error: t };
            } finally {
              try {
                E && !E.done && (i = S.return) && i.call(S);
              } finally {
                if (o) throw o.error;
              }
            }
          }
      }),
      (n.prototype.disable = function () {
        var t, n, e, r;
        if (this.dn) {
          this.dn = !1;
          try {
            for (var o = MA(this.hn), i = o.next(); !i.done; i = o.next()) {
              var s = i.value;
              "function" == typeof s.unpatch &&
                s.moduleExports &&
                (this.Ct.debug(
                  "Removing instrumentation patch for nodejs module on instrumentation disabled",
                  { module: s.name, version: s.moduleVersion }
                ),
                s.unpatch(s.moduleExports, s.moduleVersion));
              try {
                for (
                  var u = ((e = void 0), MA(s.files)), c = u.next();
                  !c.done;
                  c = u.next()
                ) {
                  var a = c.value;
                  a.moduleExports &&
                    (this.Ct.debug(
                      "Removing instrumentation patch for nodejs module file on instrumentation disabled",
                      {
                        module: s.name,
                        version: s.moduleVersion,
                        fileName: a.name,
                      }
                    ),
                    a.unpatch(a.moduleExports, s.moduleVersion));
                }
              } catch (t) {
                e = { error: t };
              } finally {
                try {
                  c && !c.done && (r = u.return) && r.call(u);
                } finally {
                  if (e) throw e.error;
                }
              }
            }
          } catch (n) {
            t = { error: n };
          } finally {
            try {
              i && !i.done && (n = o.return) && n.call(o);
            } finally {
              if (t) throw t.error;
            }
          }
        }
      }),
      (n.prototype.isEnabled = function () {
        return this.dn;
      }),
      n
    );
  })(by);
function ZA(t, n, e) {
  return void 0 === n
    ? t.includes("*")
    : t.some(function (t) {
        return Qv.satisfies(n, t, { includePrerelease: e });
      });
}
var PA = function (t, n, e, r, o) {
    (this.name = t),
      (this.supportedVersions = n),
      (this.patch = e),
      (this.unpatch = r),
      (this.files = o || []);
  },
  VA = function (t, e, r, o) {
    (this.supportedVersions = e),
      (this.patch = r),
      (this.unpatch = o),
      (this.name = n.normalize(t));
  },
  GA = function (t, n, e, r) {
    return new (e || (e = Promise))(function (o, i) {
      function s(t) {
        try {
          c(r.next(t));
        } catch (t) {
          i(t);
        }
      }
      function u(t) {
        try {
          c(r.throw(t));
        } catch (t) {
          i(t);
        }
      }
      function c(t) {
        var n;
        t.done
          ? o(t.value)
          : ((n = t.value),
            n instanceof e
              ? n
              : new e(function (t) {
                  t(n);
                })).then(s, u);
      }
      c((r = r.apply(t, n || [])).next());
    });
  },
  XA = function (t, n) {
    var e,
      r,
      o,
      i,
      s = {
        label: 0,
        sent: function () {
          if (1 & o[0]) throw o[1];
          return o[1];
        },
        trys: [],
        ops: [],
      };
    return (
      (i = { next: u(0), throw: u(1), return: u(2) }),
      "function" == typeof Symbol &&
        (i[Symbol.iterator] = function () {
          return this;
        }),
      i
    );
    function u(i) {
      return function (u) {
        return (function (i) {
          if (e) throw new TypeError("Generator is already executing.");
          for (; s; )
            try {
              if (
                ((e = 1),
                r &&
                  (o =
                    2 & i[0]
                      ? r.return
                      : i[0]
                        ? r.throw || ((o = r.return) && o.call(r), 0)
                        : r.next) &&
                  !(o = o.call(r, i[1])).done)
              )
                return o;
              switch (((r = 0), o && (i = [2 & i[0], o.value]), i[0])) {
                case 0:
                case 1:
                  o = i;
                  break;
                case 4:
                  return s.label++, { value: i[1], done: !1 };
                case 5:
                  s.label++, (r = i[1]), (i = [0]);
                  continue;
                case 7:
                  (i = s.ops.pop()), s.trys.pop();
                  continue;
                default:
                  if (
                    !((o = s.trys),
                    (o = o.length > 0 && o[o.length - 1]) ||
                      (6 !== i[0] && 2 !== i[0]))
                  ) {
                    s = 0;
                    continue;
                  }
                  if (3 === i[0] && (!o || (i[1] > o[0] && i[1] < o[3]))) {
                    s.label = i[1];
                    break;
                  }
                  if (6 === i[0] && s.label < o[1]) {
                    (s.label = o[1]), (o = i);
                    break;
                  }
                  if (o && s.label < o[2]) {
                    (s.label = o[2]), s.ops.push(i);
                    break;
                  }
                  o[2] && s.ops.pop(), s.trys.pop();
                  continue;
              }
              i = n.call(t, s);
            } catch (t) {
              (i = [6, t]), (r = 0);
            } finally {
              e = o = 0;
            }
          if (5 & i[0]) throw i[1];
          return { value: i[0] ? i[1] : void 0, done: !0 };
        })([i, u]);
      };
    }
  };
var UA = Object.freeze({
    __proto__: null,
    InstrumentationBase: wA,
    InstrumentationNodeModuleDefinition: PA,
    InstrumentationNodeModuleFile: VA,
    isWrapped: function (t) {
      return (
        "function" == typeof t &&
        "function" == typeof t.__original &&
        "function" == typeof t.__unwrap &&
        !0 === t.__wrapped
      );
    },
    registerInstrumentations: function (t) {
      var n = ly(t.instrumentations).instrumentations,
        e = t.tracerProvider || Qr.getTracerProvider(),
        r = t.meterProvider || Ur.getMeterProvider(),
        o = t.loggerProvider || ay.getLoggerProvider();
      return (
        (function (t, n, e, r) {
          for (var o = 0, i = t.length; o < i; o++) {
            var s = t[o];
            n && s.setTracerProvider(n),
              e && s.setMeterProvider(e),
              r && s.setLoggerProvider && s.setLoggerProvider(r),
              s.getConfig().enabled || s.enable();
          }
        })(n, e, r, o),
        function () {
          !(function (t) {
            t.forEach(function (t) {
              return t.disable();
            });
          })(n);
        }
      );
    },
    safeExecuteInTheMiddle: function (t, n, e) {
      var r, o;
      try {
        o = t();
      } catch (t) {
        r = t;
      } finally {
        if ((n(r, o), r && !e)) throw r;
        return o;
      }
    },
    safeExecuteInTheMiddleAsync: function (t, n, e) {
      return GA(this, void 0, void 0, function () {
        var r, o, i;
        return XA(this, function (s) {
          switch (s.label) {
            case 0:
              return s.trys.push([0, 2, 3, 4]), [4, t()];
            case 1:
              return (o = s.sent()), [3, 4];
            case 2:
              return (i = s.sent()), (r = i), [3, 4];
            case 3:
              if ((n(r, o), r && !e)) throw r;
              return [2, o];
            case 4:
              return [2];
          }
        });
      });
    },
  }),
  WA = Ht(UA);
Object.defineProperty(to, "__esModule", { value: !0 }),
  (to.HttpInstrumentation = void 0);
const YA = no,
  HA = R_,
  DA = Qv,
  jA = u,
  xA = $v,
  kA = ny,
  KA = WA,
  BA = R_,
  FA = l,
  JA = qv;
class zA extends KA.InstrumentationBase {
  constructor(t) {
    super("@opentelemetry/instrumentation-http", kA.VERSION, t),
      (this.mn = new WeakSet()),
      (this.Tn = this._n());
  }
  wt() {
    (this.bn = this.meter.createHistogram("http.server.duration", {
      description: "Measures the duration of inbound HTTP requests.",
      unit: "ms",
      valueType: YA.ValueType.DOUBLE,
    })),
      (this.vn = this.meter.createHistogram("http.client.duration", {
        description: "Measures the duration of outbound HTTP requests.",
        unit: "ms",
        valueType: YA.ValueType.DOUBLE,
      }));
  }
  yn() {
    return this.Nt;
  }
  setConfig(t) {
    super.setConfig(t), (this.Tn = this._n());
  }
  init() {
    return [this.Rn(), this.An()];
  }
  An() {
    return new KA.InstrumentationNodeModuleDefinition(
      "http",
      ["*"],
      (t) => (
        (0, KA.isWrapped)(t.request) && this.Rt(t, "request"),
        this.yt(t, "request", this.On("http")),
        (0, KA.isWrapped)(t.get) && this.Rt(t, "get"),
        this.yt(t, "get", this.gn(t.request)),
        (0, KA.isWrapped)(t.Server.prototype.emit) &&
          this.Rt(t.Server.prototype, "emit"),
        this.yt(t.Server.prototype, "emit", this.Nn("http")),
        t
      ),
      (t) => {
        void 0 !== t &&
          (this.Rt(t, "request"),
          this.Rt(t, "get"),
          this.Rt(t.Server.prototype, "emit"));
      }
    );
  }
  Rn() {
    return new KA.InstrumentationNodeModuleDefinition(
      "https",
      ["*"],
      (t) => (
        (0, KA.isWrapped)(t.request) && this.Rt(t, "request"),
        this.yt(t, "request", this.Cn("https")),
        (0, KA.isWrapped)(t.get) && this.Rt(t, "get"),
        this.yt(t, "get", this.Ln(t.request)),
        (0, KA.isWrapped)(t.Server.prototype.emit) &&
          this.Rt(t.Server.prototype, "emit"),
        this.yt(t.Server.prototype, "emit", this.Nn("https")),
        t
      ),
      (t) => {
        void 0 !== t &&
          (this.Rt(t, "request"),
          this.Rt(t, "get"),
          this.Rt(t.Server.prototype, "emit"));
      }
    );
  }
  Nn(t) {
    return (n) => this.In(t, n);
  }
  On(t) {
    return (n) => this.Mn(t, n);
  }
  gn(t) {
    return (n) =>
      function (n, ...e) {
        const r = t(n, ...e);
        return r.end(), r;
      };
  }
  Cn(t) {
    return (n) => {
      const e = this;
      return function (r, ...o) {
        var i;
        return (
          "https" === t &&
            "object" == typeof r &&
            "URL" !==
              (null === (i = null == r ? void 0 : r.constructor) || void 0 === i
                ? void 0
                : i.name) &&
            ((r = Object.assign({}, r)), e.wn(r)),
          e.On(t)(n)(r, ...o)
        );
      };
    };
  }
  wn(t) {
    (t.protocol = t.protocol || "https:"), (t.port = t.port || 443);
  }
  Ln(t) {
    return (n) => {
      const e = this;
      return function (r, ...o) {
        return e.gn(t)(n)(r, ...o);
      };
    };
  }
  Zn(t, n, e, r) {
    this.yn().requestHook && this.Pn(n, t);
    let o = !1;
    return (
      t.prependListener("response", (i) => {
        this.Ct.debug("outgoingRequest on response()"),
          t.listenerCount("response") <= 1 && i.resume();
        const s = xA.getOutgoingRequestAttributesOnResponse(i);
        n.setAttributes(s),
          (r = Object.assign(
            r,
            xA.getOutgoingRequestMetricAttributesOnResponse(s)
          )),
          this.yn().responseHook && this.Vn(n, i),
          this.Tn.client.captureRequestHeaders(n, (n) => t.getHeader(n)),
          this.Tn.client.captureResponseHeaders(n, (t) => i.headers[t]),
          YA.context.bind(YA.context.active(), i);
        const u = () => {
          if ((this.Ct.debug("outgoingRequest on end()"), o)) return;
          let s;
          (o = !0),
            (s =
              i.aborted && !i.complete
                ? { code: YA.SpanStatusCode.ERROR }
                : {
                    code: xA.parseResponseStatus(
                      YA.SpanKind.CLIENT,
                      i.statusCode
                    ),
                  }),
            n.setStatus(s),
            this.yn().applyCustomAttributesOnSpan &&
              (0, KA.safeExecuteInTheMiddle)(
                () => this.yn().applyCustomAttributesOnSpan(n, t, i),
                () => {},
                !0
              ),
            this.Gn(n, YA.SpanKind.CLIENT, e, r);
        };
        i.on("end", u),
          DA.lt(process.version, "16.0.0") && i.on("close", u),
          i.on(FA.errorMonitor, (t) => {
            this.Ct.debug("outgoingRequest on error()", t),
              o ||
                ((o = !0),
                xA.setSpanWithError(n, t),
                n.setStatus({
                  code: YA.SpanStatusCode.ERROR,
                  message: t.message,
                }),
                this.Gn(n, YA.SpanKind.CLIENT, e, r));
          });
      }),
      t.on("close", () => {
        this.Ct.debug("outgoingRequest on request close()"),
          t.aborted || o || ((o = !0), this.Gn(n, YA.SpanKind.CLIENT, e, r));
      }),
      t.on(FA.errorMonitor, (t) => {
        this.Ct.debug("outgoingRequest on request error()", t),
          o ||
            ((o = !0),
            xA.setSpanWithError(n, t),
            this.Gn(n, YA.SpanKind.CLIENT, e, r));
      }),
      this.Ct.debug("http.ClientRequest return request"),
      t
    );
  }
  In(t, n) {
    const e = this;
    return function (r, ...o) {
      if ("request" !== r) return n.apply(this, [r, ...o]);
      const i = o[0],
        s = o[1],
        u = (i.url && jA.parse(i.url).pathname) || "/",
        c = i.method || "GET";
      if (
        (e.Ct.debug(`${t} instrumentation incomingRequest`),
        xA.isIgnored(u, e.yn().ignoreIncomingPaths, (t) =>
          e.Ct.error("caught ignoreIncomingPaths error: ", t)
        ) ||
          (0, KA.safeExecuteInTheMiddle)(
            () => {
              var t, n;
              return null === (n = (t = e.yn()).ignoreIncomingRequestHook) ||
                void 0 === n
                ? void 0
                : n.call(t, i);
            },
            (t) => {
              null != t &&
                e.Ct.error("caught ignoreIncomingRequestHook error: ", t);
            },
            !0
          ))
      )
        return YA.context.with(
          (0, HA.suppressTracing)(YA.context.active()),
          () => (
            YA.context.bind(YA.context.active(), i),
            YA.context.bind(YA.context.active(), s),
            n.apply(this, [r, ...o])
          )
        );
      const a = i.headers,
        l = xA.getIncomingRequestAttributes(i, {
          component: t,
          serverName: e.yn().serverName,
          hookAttributes: e.Xn(i, e.yn().startIncomingSpanHook),
        }),
        f = { kind: YA.SpanKind.SERVER, attributes: l },
        d = (0, HA.hrTime)(),
        h = xA.getIncomingRequestMetricAttributes(l),
        p = YA.propagation.extract(YA.ROOT_CONTEXT, a),
        S = e.Un(c, f, p),
        E = { type: BA.RPCType.HTTP, span: S };
      return YA.context.with(
        (0, BA.setRPCMetadata)(YA.trace.setSpan(p, S), E),
        () => {
          YA.context.bind(YA.context.active(), i),
            YA.context.bind(YA.context.active(), s),
            e.yn().requestHook && e.Pn(S, i),
            e.yn().responseHook && e.Vn(S, s),
            e.Tn.server.captureRequestHeaders(S, (t) => i.headers[t]);
          let t = !1;
          return (
            s.on("close", () => {
              t || e.Wn(i, s, S, h, d);
            }),
            s.on(FA.errorMonitor, (n) => {
              (t = !0), e.Yn(S, h, d, n);
            }),
            (0, KA.safeExecuteInTheMiddle)(
              () => n.apply(this, [r, ...o]),
              (t) => {
                if (t)
                  throw (
                    (xA.setSpanWithError(S, t),
                    e.Gn(S, YA.SpanKind.SERVER, d, h),
                    t)
                  );
              }
            )
          );
        }
      );
    };
  }
  Mn(t, n) {
    const e = this;
    return function (r, ...o) {
      if (!xA.isValidOptionsType(r)) return n.apply(this, [r, ...o]);
      const i =
          "object" == typeof o[0] &&
          ("string" == typeof r || r instanceof jA.URL)
            ? o.shift()
            : void 0,
        {
          origin: s,
          pathname: u,
          method: c,
          optionsParsed: a,
        } = xA.getRequestInfo(r, i);
      if (
        "http" === t &&
        DA.lt(process.version, "9.0.0") &&
        "https:" === a.protocol
      )
        return n.apply(this, [a, ...o]);
      if (
        xA.isIgnored(s + u, e.yn().ignoreOutgoingUrls, (t) =>
          e.Ct.error("caught ignoreOutgoingUrls error: ", t)
        ) ||
        (0, KA.safeExecuteInTheMiddle)(
          () => {
            var t, n;
            return null === (n = (t = e.yn()).ignoreOutgoingRequestHook) ||
              void 0 === n
              ? void 0
              : n.call(t, a);
          },
          (t) => {
            null != t &&
              e.Ct.error("caught ignoreOutgoingRequestHook error: ", t);
          },
          !0
        )
      )
        return n.apply(this, [a, ...o]);
      const { hostname: l, port: f } = xA.extractHostnameAndPort(a),
        d = xA.getOutgoingRequestAttributes(a, {
          component: t,
          port: f,
          hostname: l,
          hookAttributes: e.Xn(a, e.yn().startOutgoingSpanHook),
        }),
        h = (0, HA.hrTime)(),
        p = xA.getOutgoingRequestMetricAttributes(d),
        S = { kind: YA.SpanKind.CLIENT, attributes: d },
        E = e.Un(c, S),
        m = YA.context.active(),
        T = YA.trace.setSpan(m, E);
      return (
        a.headers
          ? (a.headers = Object.assign({}, a.headers))
          : (a.headers = {}),
        YA.propagation.inject(T, a.headers),
        YA.context.with(T, () => {
          const r = o[o.length - 1];
          "function" == typeof r && (o[o.length - 1] = YA.context.bind(m, r));
          const i = (0, KA.safeExecuteInTheMiddle)(
            () => n.apply(this, [a, ...o]),
            (t) => {
              if (t)
                throw (
                  (xA.setSpanWithError(E, t),
                  e.Gn(E, YA.SpanKind.CLIENT, h, p),
                  t)
                );
            }
          );
          return (
            e.Ct.debug(`${t} instrumentation outgoingRequest`),
            YA.context.bind(m, i),
            e.Zn(i, E, h, p)
          );
        })
      );
    };
  }
  Wn(t, n, e, r, o) {
    const i = xA.getIncomingRequestAttributesOnResponse(t, n);
    (r = Object.assign(r, xA.getIncomingRequestMetricAttributesOnResponse(i))),
      this.Tn.server.captureResponseHeaders(e, (t) => n.getHeader(t)),
      e
        .setAttributes(i)
        .setStatus({
          code: xA.parseResponseStatus(YA.SpanKind.SERVER, n.statusCode),
        });
    const s = i[JA.SEMATTRS_HTTP_ROUTE];
    s && e.updateName(`${t.method || "GET"} ${s}`),
      this.yn().applyCustomAttributesOnSpan &&
        (0, KA.safeExecuteInTheMiddle)(
          () => this.yn().applyCustomAttributesOnSpan(e, t, n),
          () => {},
          !0
        ),
      this.Gn(e, YA.SpanKind.SERVER, o, r);
  }
  Yn(t, n, e, r) {
    xA.setSpanWithError(t, r), this.Gn(t, YA.SpanKind.SERVER, e, n);
  }
  Un(t, n, e = YA.context.active()) {
    const r =
      n.kind === YA.SpanKind.CLIENT
        ? this.yn().requireParentforOutgoingSpans
        : this.yn().requireParentforIncomingSpans;
    let o;
    const i = YA.trace.getSpan(e);
    return (
      (o =
        !0 === r && void 0 === i
          ? YA.trace.wrapSpanContext(YA.INVALID_SPAN_CONTEXT)
          : !0 === r && (null == i ? void 0 : i.spanContext().isRemote)
            ? i
            : this.tracer.startSpan(t, n, e)),
      this.mn.add(o),
      o
    );
  }
  Gn(t, n, e, r) {
    if (!this.mn.has(t)) return;
    t.end(), this.mn.delete(t);
    const o = (0, HA.hrTimeToMilliseconds)(
      (0, HA.hrTimeDuration)(e, (0, HA.hrTime)())
    );
    n === YA.SpanKind.SERVER
      ? this.bn.record(o, r)
      : n === YA.SpanKind.CLIENT && this.vn.record(o, r);
  }
  Vn(t, n) {
    (0, KA.safeExecuteInTheMiddle)(
      () => this.yn().responseHook(t, n),
      () => {},
      !0
    );
  }
  Pn(t, n) {
    (0, KA.safeExecuteInTheMiddle)(
      () => this.yn().requestHook(t, n),
      () => {},
      !0
    );
  }
  Xn(t, n) {
    if ("function" == typeof n)
      return (0, KA.safeExecuteInTheMiddle)(
        () => n(t),
        () => {},
        !0
      );
  }
  _n() {
    var t, n, e, r, o, i, s, u, c, a, l, f;
    const d = this.yn();
    return {
      client: {
        captureRequestHeaders: xA.headerCapture(
          "request",
          null !==
            (e =
              null ===
                (n =
                  null === (t = d.headersToSpanAttributes) || void 0 === t
                    ? void 0
                    : t.client) || void 0 === n
                ? void 0
                : n.requestHeaders) && void 0 !== e
            ? e
            : []
        ),
        captureResponseHeaders: xA.headerCapture(
          "response",
          null !==
            (i =
              null ===
                (o =
                  null === (r = d.headersToSpanAttributes) || void 0 === r
                    ? void 0
                    : r.client) || void 0 === o
                ? void 0
                : o.responseHeaders) && void 0 !== i
            ? i
            : []
        ),
      },
      server: {
        captureRequestHeaders: xA.headerCapture(
          "request",
          null !==
            (c =
              null ===
                (u =
                  null === (s = d.headersToSpanAttributes) || void 0 === s
                    ? void 0
                    : s.server) || void 0 === u
                ? void 0
                : u.requestHeaders) && void 0 !== c
            ? c
            : []
        ),
        captureResponseHeaders: xA.headerCapture(
          "response",
          null !==
            (f =
              null ===
                (l =
                  null === (a = d.headersToSpanAttributes) || void 0 === a
                    ? void 0
                    : a.server) || void 0 === l
                ? void 0
                : l.responseHeaders) && void 0 !== f
            ? f
            : []
        ),
      },
    };
  }
}
to.HttpInstrumentation = zA;
var QA = {};
function $A(t) {
  for (var n = {}, e = t.length, r = 0; r < e; r++) {
    var o = t[r];
    o && (n[String(o).toUpperCase().replace(/[-.]/g, "_")] = o);
  }
  return n;
}
Object.defineProperty(QA, "__esModule", { value: !0 }),
  (function (t) {
    var n =
        (Wt && Wt.__createBinding) ||
        (Object.create
          ? function (t, n, e, r) {
              void 0 === r && (r = e),
                Object.defineProperty(t, r, {
                  enumerable: !0,
                  get: function () {
                    return n[e];
                  },
                });
            }
          : function (t, n, e, r) {
              void 0 === r && (r = e), (t[r] = n[e]);
            }),
      e =
        (Wt && Wt.__exportStar) ||
        function (t, e) {
          for (var r in t)
            "default" === r ||
              Object.prototype.hasOwnProperty.call(e, r) ||
              n(e, t, r);
        };
    Object.defineProperty(t, "__esModule", { value: !0 }),
      e(to, t),
      e(QA, t),
      e($v, t);
  })(qr);
var qA = "aws.lambda.invoked_arn",
  tO = "db.system",
  nO = "db.connection_string",
  eO = "db.user",
  rO = "db.jdbc.driver_classname",
  oO = "db.name",
  iO = "db.statement",
  sO = "db.operation",
  uO = "db.mssql.instance_name",
  cO = "db.cassandra.keyspace",
  aO = "db.cassandra.page_size",
  lO = "db.cassandra.consistency_level",
  fO = "db.cassandra.table",
  dO = "db.cassandra.idempotence",
  hO = "db.cassandra.speculative_execution_count",
  pO = "db.cassandra.coordinator.id",
  SO = "db.cassandra.coordinator.dc",
  EO = "db.hbase.namespace",
  mO = "db.redis.database_index",
  TO = "db.mongodb.collection",
  _O = "db.sql.table",
  bO = "exception.type",
  vO = "exception.message",
  yO = "exception.stacktrace",
  RO = "exception.escaped",
  AO = "faas.trigger",
  OO = "faas.execution",
  gO = "faas.document.collection",
  NO = "faas.document.operation",
  CO = "faas.document.time",
  LO = "faas.document.name",
  IO = "faas.time",
  MO = "faas.cron",
  wO = "faas.coldstart",
  ZO = "faas.invoked_name",
  PO = "faas.invoked_provider",
  VO = "faas.invoked_region",
  GO = "net.transport",
  XO = "net.peer.ip",
  UO = "net.peer.port",
  WO = "net.peer.name",
  YO = "net.host.ip",
  HO = "net.host.port",
  DO = "net.host.name",
  jO = "net.host.connection.type",
  xO = "net.host.connection.subtype",
  kO = "net.host.carrier.name",
  KO = "net.host.carrier.mcc",
  BO = "net.host.carrier.mnc",
  FO = "net.host.carrier.icc",
  JO = "peer.service",
  zO = "enduser.id",
  QO = "enduser.role",
  $O = "enduser.scope",
  qO = "thread.id",
  tg = "thread.name",
  ng = "code.function",
  eg = "code.namespace",
  rg = "code.filepath",
  og = "code.lineno",
  ig = "http.method",
  sg = "http.url",
  ug = "http.target",
  cg = "http.host",
  ag = "http.scheme",
  lg = "http.status_code",
  fg = "http.flavor",
  dg = "http.user_agent",
  hg = "http.request_content_length",
  pg = "http.request_content_length_uncompressed",
  Sg = "http.response_content_length",
  Eg = "http.response_content_length_uncompressed",
  mg = "http.server_name",
  Tg = "http.route",
  _g = "http.client_ip",
  bg = "aws.dynamodb.table_names",
  vg = "aws.dynamodb.consumed_capacity",
  yg = "aws.dynamodb.item_collection_metrics",
  Rg = "aws.dynamodb.provisioned_read_capacity",
  Ag = "aws.dynamodb.provisioned_write_capacity",
  Og = "aws.dynamodb.consistent_read",
  gg = "aws.dynamodb.projection",
  Ng = "aws.dynamodb.limit",
  Cg = "aws.dynamodb.attributes_to_get",
  Lg = "aws.dynamodb.index_name",
  Ig = "aws.dynamodb.select",
  Mg = "aws.dynamodb.global_secondary_indexes",
  wg = "aws.dynamodb.local_secondary_indexes",
  Zg = "aws.dynamodb.exclusive_start_table",
  Pg = "aws.dynamodb.table_count",
  Vg = "aws.dynamodb.scan_forward",
  Gg = "aws.dynamodb.segment",
  Xg = "aws.dynamodb.total_segments",
  Ug = "aws.dynamodb.count",
  Wg = "aws.dynamodb.scanned_count",
  Yg = "aws.dynamodb.attribute_definitions",
  Hg = "aws.dynamodb.global_secondary_index_updates",
  Dg = "messaging.system",
  jg = "messaging.destination",
  xg = "messaging.destination_kind",
  kg = "messaging.temp_destination",
  Kg = "messaging.protocol",
  Bg = "messaging.protocol_version",
  Fg = "messaging.url",
  Jg = "messaging.message_id",
  zg = "messaging.conversation_id",
  Qg = "messaging.message_payload_size_bytes",
  $g = "messaging.message_payload_compressed_size_bytes",
  qg = "messaging.operation",
  tN = "messaging.consumer_id",
  nN = "messaging.rabbitmq.routing_key",
  eN = "messaging.kafka.message_key",
  rN = "messaging.kafka.consumer_group",
  oN = "messaging.kafka.client_id",
  iN = "messaging.kafka.partition",
  sN = "messaging.kafka.tombstone",
  uN = "rpc.system",
  cN = "rpc.service",
  aN = "rpc.method",
  lN = "rpc.grpc.status_code",
  fN = "rpc.jsonrpc.version",
  dN = "rpc.jsonrpc.request_id",
  hN = "rpc.jsonrpc.error_code",
  pN = "rpc.jsonrpc.error_message",
  SN = "message.type",
  EN = "message.id",
  mN = "message.compressed_size",
  TN = "message.uncompressed_size",
  _N = qA,
  bN = tO,
  vN = nO,
  yN = eO,
  RN = rO,
  AN = oO,
  ON = iO,
  gN = sO,
  NN = uO,
  CN = cO,
  LN = aO,
  IN = lO,
  MN = fO,
  wN = dO,
  ZN = hO,
  PN = pO,
  VN = SO,
  GN = EO,
  XN = mO,
  UN = TO,
  WN = _O,
  YN = bO,
  HN = vO,
  DN = yO,
  jN = RO,
  xN = AO,
  kN = OO,
  KN = gO,
  BN = NO,
  FN = CO,
  JN = LO,
  zN = IO,
  QN = MO,
  $N = wO,
  qN = ZO,
  tC = PO,
  nC = VO,
  eC = GO,
  rC = XO,
  oC = UO,
  iC = WO,
  sC = YO,
  uC = HO,
  cC = DO,
  aC = jO,
  lC = xO,
  fC = kO,
  dC = KO,
  hC = BO,
  pC = FO,
  SC = JO,
  EC = zO,
  mC = QO,
  TC = $O,
  _C = qO,
  bC = tg,
  vC = ng,
  yC = eg,
  RC = rg,
  AC = og,
  OC = ig,
  gC = sg,
  NC = ug,
  CC = cg,
  LC = ag,
  IC = lg,
  MC = fg,
  wC = dg,
  ZC = hg,
  PC = pg,
  VC = Sg,
  GC = Eg,
  XC = mg,
  UC = Tg,
  WC = _g,
  YC = bg,
  HC = vg,
  DC = yg,
  jC = Rg,
  xC = Ag,
  kC = Og,
  KC = gg,
  BC = Ng,
  FC = Cg,
  JC = Lg,
  zC = Ig,
  QC = Mg,
  $C = wg,
  qC = Zg,
  tL = Pg,
  nL = Vg,
  eL = Gg,
  rL = Xg,
  oL = Ug,
  iL = Wg,
  sL = Yg,
  uL = Hg,
  cL = Dg,
  aL = jg,
  lL = xg,
  fL = kg,
  dL = Kg,
  hL = Bg,
  pL = Fg,
  SL = Jg,
  EL = zg,
  mL = Qg,
  TL = $g,
  _L = qg,
  bL = tN,
  vL = nN,
  yL = eN,
  RL = rN,
  AL = oN,
  OL = iN,
  gL = sN,
  NL = uN,
  CL = cN,
  LL = aN,
  IL = lN,
  ML = fN,
  wL = dN,
  ZL = hN,
  PL = pN,
  VL = SN,
  GL = EN,
  XL = mN,
  UL = TN,
  WL = $A([
    qA,
    tO,
    nO,
    eO,
    rO,
    oO,
    iO,
    sO,
    uO,
    cO,
    aO,
    lO,
    fO,
    dO,
    hO,
    pO,
    SO,
    EO,
    mO,
    TO,
    _O,
    bO,
    vO,
    yO,
    RO,
    AO,
    OO,
    gO,
    NO,
    CO,
    LO,
    IO,
    MO,
    wO,
    ZO,
    PO,
    VO,
    GO,
    XO,
    UO,
    WO,
    YO,
    HO,
    DO,
    jO,
    xO,
    kO,
    KO,
    BO,
    FO,
    JO,
    zO,
    QO,
    $O,
    qO,
    tg,
    ng,
    eg,
    rg,
    og,
    ig,
    sg,
    ug,
    cg,
    ag,
    lg,
    fg,
    dg,
    hg,
    pg,
    Sg,
    Eg,
    mg,
    Tg,
    _g,
    bg,
    vg,
    yg,
    Rg,
    Ag,
    Og,
    gg,
    Ng,
    Cg,
    Lg,
    Ig,
    Mg,
    wg,
    Zg,
    Pg,
    Vg,
    Gg,
    Xg,
    Ug,
    Wg,
    Yg,
    Hg,
    Dg,
    jg,
    xg,
    kg,
    Kg,
    Bg,
    Fg,
    Jg,
    zg,
    Qg,
    $g,
    qg,
    tN,
    nN,
    eN,
    rN,
    oN,
    iN,
    sN,
    uN,
    cN,
    aN,
    lN,
    fN,
    dN,
    hN,
    pN,
    SN,
    EN,
    mN,
    TN,
  ]),
  YL = "other_sql",
  HL = "mssql",
  DL = "mysql",
  jL = "oracle",
  xL = "postgresql",
  kL = "redshift",
  KL = "hive",
  BL = "cloudscape",
  FL = "hsqldb",
  JL = "progress",
  zL = "maxdb",
  QL = "hanadb",
  $L = "ingres",
  qL = "firstsql",
  tI = "cache",
  nI = "adabas",
  eI = "firebird",
  rI = "derby",
  oI = "filemaker",
  iI = "informix",
  sI = "instantdb",
  uI = "interbase",
  cI = "mariadb",
  aI = "netezza",
  lI = "pervasive",
  fI = "pointbase",
  dI = "sqlite",
  hI = "sybase",
  pI = "teradata",
  SI = "vertica",
  EI = "coldfusion",
  mI = "cassandra",
  TI = "hbase",
  _I = "mongodb",
  bI = "redis",
  vI = "couchbase",
  yI = "couchdb",
  RI = "cosmosdb",
  AI = "dynamodb",
  OI = "neo4j",
  gI = "geode",
  NI = "elasticsearch",
  CI = "memcached",
  LI = "cockroachdb",
  II = YL,
  MI = HL,
  wI = DL,
  ZI = jL,
  PI = xL,
  VI = kL,
  GI = KL,
  XI = BL,
  UI = FL,
  WI = JL,
  YI = zL,
  HI = QL,
  DI = $L,
  jI = qL,
  xI = tI,
  kI = nI,
  KI = eI,
  BI = rI,
  FI = oI,
  JI = iI,
  zI = sI,
  QI = uI,
  $I = cI,
  qI = aI,
  tM = lI,
  nM = fI,
  eM = dI,
  rM = hI,
  oM = pI,
  iM = SI,
  sM = EI,
  uM = mI,
  cM = TI,
  aM = _I,
  lM = bI,
  fM = vI,
  dM = yI,
  hM = RI,
  pM = AI,
  SM = OI,
  EM = gI,
  mM = NI,
  TM = CI,
  _M = LI,
  bM = $A([
    YL,
    HL,
    DL,
    jL,
    "db2",
    xL,
    kL,
    KL,
    BL,
    FL,
    JL,
    zL,
    QL,
    $L,
    qL,
    "edb",
    tI,
    nI,
    eI,
    rI,
    oI,
    iI,
    sI,
    uI,
    cI,
    aI,
    lI,
    fI,
    dI,
    hI,
    pI,
    SI,
    "h2",
    EI,
    mI,
    TI,
    _I,
    bI,
    vI,
    yI,
    RI,
    AI,
    OI,
    gI,
    NI,
    CI,
    LI,
  ]),
  vM = "each_quorum",
  yM = "quorum",
  RM = "local_quorum",
  AM = "three",
  OM = "local_one",
  gM = "serial",
  NM = "local_serial",
  CM = vM,
  LM = yM,
  IM = RM,
  MM = AM,
  wM = OM,
  ZM = gM,
  PM = NM,
  VM = $A(["all", vM, yM, RM, "one", "two", AM, OM, "any", gM, NM]),
  GM = "datasource",
  XM = "http",
  UM = "pubsub",
  WM = "timer",
  YM = "other",
  HM = GM,
  DM = XM,
  jM = UM,
  xM = WM,
  kM = YM,
  KM = $A([GM, XM, UM, WM, YM]),
  BM = "insert",
  FM = "edit",
  JM = "delete",
  zM = BM,
  QM = FM,
  $M = JM,
  qM = $A([BM, FM, JM]),
  tw = "alibaba_cloud",
  nw = "azure",
  ew = tw,
  rw = nw,
  ow = $A([tw, "aws", nw, "gcp"]),
  iw = "ip_tcp",
  sw = "ip_udp",
  uw = "unix",
  cw = "pipe",
  aw = "inproc",
  lw = "other",
  fw = iw,
  dw = sw,
  hw = uw,
  pw = cw,
  Sw = aw,
  Ew = lw,
  mw = $A([iw, sw, "ip", uw, cw, aw, lw]),
  Tw = "wifi",
  _w = "wired",
  bw = "cell",
  vw = "unavailable",
  yw = "unknown",
  Rw = Tw,
  Aw = _w,
  Ow = bw,
  gw = vw,
  Nw = yw,
  Cw = $A([Tw, _w, bw, vw, yw]),
  Lw = "gprs",
  Iw = "edge",
  Mw = "umts",
  ww = "cdma",
  Zw = "evdo_0",
  Pw = "evdo_a",
  Vw = "cdma2000_1xrtt",
  Gw = "hsdpa",
  Xw = "hsupa",
  Uw = "hspa",
  Ww = "iden",
  Yw = "evdo_b",
  Hw = "ehrpd",
  Dw = "hspap",
  jw = "td_scdma",
  xw = "iwlan",
  kw = "nrnsa",
  Kw = "lte_ca",
  Bw = Lw,
  Fw = Iw,
  Jw = Mw,
  zw = ww,
  Qw = Zw,
  $w = Pw,
  qw = Vw,
  tZ = Gw,
  nZ = Xw,
  eZ = Uw,
  rZ = Ww,
  oZ = Yw,
  iZ = Hw,
  sZ = Dw,
  uZ = jw,
  cZ = xw,
  aZ = kw,
  lZ = Kw,
  fZ = $A([
    Lw,
    Iw,
    Mw,
    ww,
    Zw,
    Pw,
    Vw,
    Gw,
    Xw,
    Uw,
    Ww,
    Yw,
    "lte",
    Hw,
    Dw,
    "gsm",
    jw,
    xw,
    "nr",
    kw,
    Kw,
  ]),
  dZ = "SPDY",
  hZ = "QUIC",
  pZ = dZ,
  SZ = hZ,
  EZ = {
    HTTP_1_0: "1.0",
    HTTP_1_1: "1.1",
    HTTP_2_0: "2.0",
    SPDY: dZ,
    QUIC: hZ,
  },
  mZ = "queue",
  TZ = "topic",
  _Z = mZ,
  bZ = TZ,
  vZ = $A([mZ, TZ]),
  yZ = "receive",
  RZ = "process",
  AZ = yZ,
  OZ = RZ,
  gZ = $A([yZ, RZ]),
  NZ = {
    OK: 0,
    CANCELLED: 1,
    UNKNOWN: 2,
    INVALID_ARGUMENT: 3,
    DEADLINE_EXCEEDED: 4,
    NOT_FOUND: 5,
    ALREADY_EXISTS: 6,
    PERMISSION_DENIED: 7,
    RESOURCE_EXHAUSTED: 8,
    FAILED_PRECONDITION: 9,
    ABORTED: 10,
    OUT_OF_RANGE: 11,
    UNIMPLEMENTED: 12,
    INTERNAL: 13,
    UNAVAILABLE: 14,
    DATA_LOSS: 15,
    UNAUTHENTICATED: 16,
  },
  CZ = "SENT",
  LZ = "RECEIVED",
  IZ = CZ,
  MZ = LZ,
  wZ = $A([CZ, LZ]),
  ZZ = "cloud.provider",
  PZ = "cloud.account.id",
  VZ = "cloud.region",
  GZ = "cloud.availability_zone",
  XZ = "cloud.platform",
  UZ = "aws.ecs.container.arn",
  WZ = "aws.ecs.cluster.arn",
  YZ = "aws.ecs.launchtype",
  HZ = "aws.ecs.task.arn",
  DZ = "aws.ecs.task.family",
  jZ = "aws.ecs.task.revision",
  xZ = "aws.eks.cluster.arn",
  kZ = "aws.log.group.names",
  KZ = "aws.log.group.arns",
  BZ = "aws.log.stream.names",
  FZ = "aws.log.stream.arns",
  JZ = "container.name",
  zZ = "container.id",
  QZ = "container.runtime",
  $Z = "container.image.name",
  qZ = "container.image.tag",
  tP = "deployment.environment",
  nP = "device.id",
  eP = "device.model.identifier",
  rP = "device.model.name",
  oP = "faas.name",
  iP = "faas.id",
  sP = "faas.version",
  uP = "faas.instance",
  cP = "faas.max_memory",
  aP = "host.id",
  lP = "host.name",
  fP = "host.type",
  dP = "host.arch",
  hP = "host.image.name",
  pP = "host.image.id",
  SP = "host.image.version",
  EP = "k8s.cluster.name",
  mP = "k8s.node.name",
  TP = "k8s.node.uid",
  _P = "k8s.namespace.name",
  bP = "k8s.pod.uid",
  vP = "k8s.pod.name",
  yP = "k8s.container.name",
  RP = "k8s.replicaset.uid",
  AP = "k8s.replicaset.name",
  OP = "k8s.deployment.uid",
  gP = "k8s.deployment.name",
  NP = "k8s.statefulset.uid",
  CP = "k8s.statefulset.name",
  LP = "k8s.daemonset.uid",
  IP = "k8s.daemonset.name",
  MP = "k8s.job.uid",
  wP = "k8s.job.name",
  ZP = "k8s.cronjob.uid",
  PP = "k8s.cronjob.name",
  VP = "os.type",
  GP = "os.description",
  XP = "os.name",
  UP = "os.version",
  WP = "process.pid",
  YP = "process.executable.name",
  HP = "process.executable.path",
  DP = "process.command",
  jP = "process.command_line",
  xP = "process.command_args",
  kP = "process.owner",
  KP = "process.runtime.name",
  BP = "process.runtime.version",
  FP = "process.runtime.description",
  JP = "service.name",
  zP = "service.namespace",
  QP = "service.instance.id",
  $P = "service.version",
  qP = "telemetry.sdk.name",
  tV = "telemetry.sdk.language",
  nV = "telemetry.sdk.version",
  eV = "telemetry.auto.version",
  rV = "webengine.name",
  oV = "webengine.version",
  iV = "webengine.description",
  sV = ZZ,
  uV = PZ,
  cV = VZ,
  aV = GZ,
  lV = XZ,
  fV = UZ,
  dV = WZ,
  hV = YZ,
  pV = HZ,
  SV = DZ,
  EV = jZ,
  mV = xZ,
  TV = kZ,
  _V = KZ,
  bV = BZ,
  vV = FZ,
  yV = JZ,
  RV = zZ,
  AV = QZ,
  OV = $Z,
  gV = qZ,
  NV = tP,
  CV = nP,
  LV = eP,
  IV = rP,
  MV = oP,
  wV = iP,
  ZV = sP,
  PV = uP,
  VV = cP,
  GV = aP,
  XV = lP,
  UV = fP,
  WV = dP,
  YV = hP,
  HV = pP,
  DV = SP,
  jV = EP,
  xV = mP,
  kV = TP,
  KV = _P,
  BV = bP,
  FV = vP,
  JV = yP,
  zV = RP,
  QV = AP,
  $V = OP,
  qV = gP,
  tG = NP,
  nG = CP,
  eG = LP,
  rG = IP,
  oG = MP,
  iG = wP,
  sG = ZP,
  uG = PP,
  cG = VP,
  aG = GP,
  lG = XP,
  fG = UP,
  dG = WP,
  hG = YP,
  pG = HP,
  SG = DP,
  EG = jP,
  mG = xP,
  TG = kP,
  _G = KP,
  bG = BP,
  vG = FP,
  yG = JP,
  RG = zP,
  AG = QP,
  OG = $P,
  gG = qP,
  NG = tV,
  CG = nV,
  LG = eV,
  IG = rV,
  MG = oV,
  wG = iV,
  ZG = $A([
    ZZ,
    PZ,
    VZ,
    GZ,
    XZ,
    UZ,
    WZ,
    YZ,
    HZ,
    DZ,
    jZ,
    xZ,
    kZ,
    KZ,
    BZ,
    FZ,
    JZ,
    zZ,
    QZ,
    $Z,
    qZ,
    tP,
    nP,
    eP,
    rP,
    oP,
    iP,
    sP,
    uP,
    cP,
    aP,
    lP,
    fP,
    dP,
    hP,
    pP,
    SP,
    EP,
    mP,
    TP,
    _P,
    bP,
    vP,
    yP,
    RP,
    AP,
    OP,
    gP,
    NP,
    CP,
    LP,
    IP,
    MP,
    wP,
    ZP,
    PP,
    VP,
    GP,
    XP,
    UP,
    WP,
    YP,
    HP,
    DP,
    jP,
    xP,
    kP,
    KP,
    BP,
    FP,
    JP,
    zP,
    QP,
    $P,
    qP,
    tV,
    nV,
    eV,
    rV,
    oV,
    iV,
  ]),
  PG = "alibaba_cloud",
  VG = "azure",
  GG = PG,
  XG = VG,
  UG = $A([PG, "aws", VG, "gcp"]),
  WG = "alibaba_cloud_ecs",
  YG = "alibaba_cloud_fc",
  HG = "aws_ec2",
  DG = "aws_ecs",
  jG = "aws_eks",
  xG = "aws_lambda",
  kG = "aws_elastic_beanstalk",
  KG = "azure_vm",
  BG = "azure_container_instances",
  FG = "azure_aks",
  JG = "azure_functions",
  zG = "azure_app_service",
  QG = "gcp_compute_engine",
  $G = "gcp_cloud_run",
  qG = "gcp_kubernetes_engine",
  tX = "gcp_cloud_functions",
  nX = "gcp_app_engine",
  eX = WG,
  rX = YG,
  oX = HG,
  iX = DG,
  sX = jG,
  uX = xG,
  cX = kG,
  aX = KG,
  lX = BG,
  fX = FG,
  dX = JG,
  hX = zG,
  pX = QG,
  SX = $G,
  EX = qG,
  mX = tX,
  TX = nX,
  _X = $A([WG, YG, HG, DG, jG, xG, kG, KG, BG, FG, JG, zG, QG, $G, qG, tX, nX]),
  bX = "fargate",
  vX = bX,
  yX = $A(["ec2", bX]),
  RX = "amd64",
  AX = "arm32",
  OX = "arm64",
  gX = "ia64",
  NX = "ppc32",
  CX = "ppc64",
  LX = RX,
  IX = AX,
  MX = OX,
  wX = gX,
  ZX = NX,
  PX = CX,
  VX = $A([RX, AX, OX, gX, NX, CX, "x86"]),
  GX = "windows",
  XX = "linux",
  UX = "darwin",
  WX = "freebsd",
  YX = "netbsd",
  HX = "openbsd",
  DX = "dragonflybsd",
  jX = "hpux",
  xX = "solaris",
  kX = "z_os",
  KX = GX,
  BX = XX,
  FX = UX,
  JX = WX,
  zX = YX,
  QX = HX,
  $X = DX,
  qX = jX,
  tU = xX,
  nU = kX,
  eU = $A([GX, XX, UX, WX, YX, HX, DX, jX, "aix", xX, kX]),
  rU = "dotnet",
  oU = "erlang",
  iU = "java",
  sU = "nodejs",
  uU = "python",
  cU = "ruby",
  aU = "webjs",
  lU = rU,
  fU = oU,
  dU = iU,
  hU = sU,
  pU = uU,
  SU = cU,
  EU = aU,
  mU = $A(["cpp", rU, oU, "go", iU, sU, "php", uU, cU, aU]),
  TU = Object.freeze({
    __proto__: null,
    AWSECSLAUNCHTYPEVALUES_EC2: "ec2",
    AWSECSLAUNCHTYPEVALUES_FARGATE: vX,
    AwsEcsLaunchtypeValues: yX,
    CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS: eX,
    CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC: rX,
    CLOUDPLATFORMVALUES_AWS_EC2: oX,
    CLOUDPLATFORMVALUES_AWS_ECS: iX,
    CLOUDPLATFORMVALUES_AWS_EKS: sX,
    CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK: cX,
    CLOUDPLATFORMVALUES_AWS_LAMBDA: uX,
    CLOUDPLATFORMVALUES_AZURE_AKS: fX,
    CLOUDPLATFORMVALUES_AZURE_APP_SERVICE: hX,
    CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES: lX,
    CLOUDPLATFORMVALUES_AZURE_FUNCTIONS: dX,
    CLOUDPLATFORMVALUES_AZURE_VM: aX,
    CLOUDPLATFORMVALUES_GCP_APP_ENGINE: TX,
    CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS: mX,
    CLOUDPLATFORMVALUES_GCP_CLOUD_RUN: SX,
    CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE: pX,
    CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE: EX,
    CLOUDPROVIDERVALUES_ALIBABA_CLOUD: GG,
    CLOUDPROVIDERVALUES_AWS: "aws",
    CLOUDPROVIDERVALUES_AZURE: XG,
    CLOUDPROVIDERVALUES_GCP: "gcp",
    CloudPlatformValues: _X,
    CloudProviderValues: UG,
    DBCASSANDRACONSISTENCYLEVELVALUES_ALL: "all",
    DBCASSANDRACONSISTENCYLEVELVALUES_ANY: "any",
    DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM: CM,
    DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE: wM,
    DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM: IM,
    DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL: PM,
    DBCASSANDRACONSISTENCYLEVELVALUES_ONE: "one",
    DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM: LM,
    DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL: ZM,
    DBCASSANDRACONSISTENCYLEVELVALUES_THREE: MM,
    DBCASSANDRACONSISTENCYLEVELVALUES_TWO: "two",
    DBSYSTEMVALUES_ADABAS: kI,
    DBSYSTEMVALUES_CACHE: xI,
    DBSYSTEMVALUES_CASSANDRA: uM,
    DBSYSTEMVALUES_CLOUDSCAPE: XI,
    DBSYSTEMVALUES_COCKROACHDB: _M,
    DBSYSTEMVALUES_COLDFUSION: sM,
    DBSYSTEMVALUES_COSMOSDB: hM,
    DBSYSTEMVALUES_COUCHBASE: fM,
    DBSYSTEMVALUES_COUCHDB: dM,
    DBSYSTEMVALUES_DB2: "db2",
    DBSYSTEMVALUES_DERBY: BI,
    DBSYSTEMVALUES_DYNAMODB: pM,
    DBSYSTEMVALUES_EDB: "edb",
    DBSYSTEMVALUES_ELASTICSEARCH: mM,
    DBSYSTEMVALUES_FILEMAKER: FI,
    DBSYSTEMVALUES_FIREBIRD: KI,
    DBSYSTEMVALUES_FIRSTSQL: jI,
    DBSYSTEMVALUES_GEODE: EM,
    DBSYSTEMVALUES_H2: "h2",
    DBSYSTEMVALUES_HANADB: HI,
    DBSYSTEMVALUES_HBASE: cM,
    DBSYSTEMVALUES_HIVE: GI,
    DBSYSTEMVALUES_HSQLDB: UI,
    DBSYSTEMVALUES_INFORMIX: JI,
    DBSYSTEMVALUES_INGRES: DI,
    DBSYSTEMVALUES_INSTANTDB: zI,
    DBSYSTEMVALUES_INTERBASE: QI,
    DBSYSTEMVALUES_MARIADB: $I,
    DBSYSTEMVALUES_MAXDB: YI,
    DBSYSTEMVALUES_MEMCACHED: TM,
    DBSYSTEMVALUES_MONGODB: aM,
    DBSYSTEMVALUES_MSSQL: MI,
    DBSYSTEMVALUES_MYSQL: wI,
    DBSYSTEMVALUES_NEO4J: SM,
    DBSYSTEMVALUES_NETEZZA: qI,
    DBSYSTEMVALUES_ORACLE: ZI,
    DBSYSTEMVALUES_OTHER_SQL: II,
    DBSYSTEMVALUES_PERVASIVE: tM,
    DBSYSTEMVALUES_POINTBASE: nM,
    DBSYSTEMVALUES_POSTGRESQL: PI,
    DBSYSTEMVALUES_PROGRESS: WI,
    DBSYSTEMVALUES_REDIS: lM,
    DBSYSTEMVALUES_REDSHIFT: VI,
    DBSYSTEMVALUES_SQLITE: eM,
    DBSYSTEMVALUES_SYBASE: rM,
    DBSYSTEMVALUES_TERADATA: oM,
    DBSYSTEMVALUES_VERTICA: iM,
    DbCassandraConsistencyLevelValues: VM,
    DbSystemValues: bM,
    FAASDOCUMENTOPERATIONVALUES_DELETE: $M,
    FAASDOCUMENTOPERATIONVALUES_EDIT: QM,
    FAASDOCUMENTOPERATIONVALUES_INSERT: zM,
    FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD: ew,
    FAASINVOKEDPROVIDERVALUES_AWS: "aws",
    FAASINVOKEDPROVIDERVALUES_AZURE: rw,
    FAASINVOKEDPROVIDERVALUES_GCP: "gcp",
    FAASTRIGGERVALUES_DATASOURCE: HM,
    FAASTRIGGERVALUES_HTTP: DM,
    FAASTRIGGERVALUES_OTHER: kM,
    FAASTRIGGERVALUES_PUBSUB: jM,
    FAASTRIGGERVALUES_TIMER: xM,
    FaasDocumentOperationValues: qM,
    FaasInvokedProviderValues: ow,
    FaasTriggerValues: KM,
    HOSTARCHVALUES_AMD64: LX,
    HOSTARCHVALUES_ARM32: IX,
    HOSTARCHVALUES_ARM64: MX,
    HOSTARCHVALUES_IA64: wX,
    HOSTARCHVALUES_PPC32: ZX,
    HOSTARCHVALUES_PPC64: PX,
    HOSTARCHVALUES_X86: "x86",
    HTTPFLAVORVALUES_HTTP_1_0: "1.0",
    HTTPFLAVORVALUES_HTTP_1_1: "1.1",
    HTTPFLAVORVALUES_HTTP_2_0: "2.0",
    HTTPFLAVORVALUES_QUIC: SZ,
    HTTPFLAVORVALUES_SPDY: pZ,
    HostArchValues: VX,
    HttpFlavorValues: EZ,
    MESSAGETYPEVALUES_RECEIVED: MZ,
    MESSAGETYPEVALUES_SENT: IZ,
    MESSAGINGDESTINATIONKINDVALUES_QUEUE: _Z,
    MESSAGINGDESTINATIONKINDVALUES_TOPIC: bZ,
    MESSAGINGOPERATIONVALUES_PROCESS: OZ,
    MESSAGINGOPERATIONVALUES_RECEIVE: AZ,
    MessageTypeValues: wZ,
    MessagingDestinationKindValues: vZ,
    MessagingOperationValues: gZ,
    NETHOSTCONNECTIONSUBTYPEVALUES_CDMA: zw,
    NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT: qw,
    NETHOSTCONNECTIONSUBTYPEVALUES_EDGE: Fw,
    NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD: iZ,
    NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0: Qw,
    NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A: $w,
    NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B: oZ,
    NETHOSTCONNECTIONSUBTYPEVALUES_GPRS: Bw,
    NETHOSTCONNECTIONSUBTYPEVALUES_GSM: "gsm",
    NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA: tZ,
    NETHOSTCONNECTIONSUBTYPEVALUES_HSPA: eZ,
    NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP: sZ,
    NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA: nZ,
    NETHOSTCONNECTIONSUBTYPEVALUES_IDEN: rZ,
    NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN: cZ,
    NETHOSTCONNECTIONSUBTYPEVALUES_LTE: "lte",
    NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA: lZ,
    NETHOSTCONNECTIONSUBTYPEVALUES_NR: "nr",
    NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA: aZ,
    NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA: uZ,
    NETHOSTCONNECTIONSUBTYPEVALUES_UMTS: Jw,
    NETHOSTCONNECTIONTYPEVALUES_CELL: Ow,
    NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE: gw,
    NETHOSTCONNECTIONTYPEVALUES_UNKNOWN: Nw,
    NETHOSTCONNECTIONTYPEVALUES_WIFI: Rw,
    NETHOSTCONNECTIONTYPEVALUES_WIRED: Aw,
    NETTRANSPORTVALUES_INPROC: Sw,
    NETTRANSPORTVALUES_IP: "ip",
    NETTRANSPORTVALUES_IP_TCP: fw,
    NETTRANSPORTVALUES_IP_UDP: dw,
    NETTRANSPORTVALUES_OTHER: Ew,
    NETTRANSPORTVALUES_PIPE: pw,
    NETTRANSPORTVALUES_UNIX: hw,
    NetHostConnectionSubtypeValues: fZ,
    NetHostConnectionTypeValues: Cw,
    NetTransportValues: mw,
    OSTYPEVALUES_AIX: "aix",
    OSTYPEVALUES_DARWIN: FX,
    OSTYPEVALUES_DRAGONFLYBSD: $X,
    OSTYPEVALUES_FREEBSD: JX,
    OSTYPEVALUES_HPUX: qX,
    OSTYPEVALUES_LINUX: BX,
    OSTYPEVALUES_NETBSD: zX,
    OSTYPEVALUES_OPENBSD: QX,
    OSTYPEVALUES_SOLARIS: tU,
    OSTYPEVALUES_WINDOWS: KX,
    OSTYPEVALUES_Z_OS: nU,
    OsTypeValues: eU,
    RPCGRPCSTATUSCODEVALUES_ABORTED: 10,
    RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS: 6,
    RPCGRPCSTATUSCODEVALUES_CANCELLED: 1,
    RPCGRPCSTATUSCODEVALUES_DATA_LOSS: 15,
    RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED: 4,
    RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION: 9,
    RPCGRPCSTATUSCODEVALUES_INTERNAL: 13,
    RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT: 3,
    RPCGRPCSTATUSCODEVALUES_NOT_FOUND: 5,
    RPCGRPCSTATUSCODEVALUES_OK: 0,
    RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE: 11,
    RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED: 7,
    RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED: 8,
    RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED: 16,
    RPCGRPCSTATUSCODEVALUES_UNAVAILABLE: 14,
    RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED: 12,
    RPCGRPCSTATUSCODEVALUES_UNKNOWN: 2,
    RpcGrpcStatusCodeValues: NZ,
    SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET: FC,
    SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS: sL,
    SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ: kC,
    SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY: HC,
    SEMATTRS_AWS_DYNAMODB_COUNT: oL,
    SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE: qC,
    SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES: QC,
    SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES: uL,
    SEMATTRS_AWS_DYNAMODB_INDEX_NAME: JC,
    SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS: DC,
    SEMATTRS_AWS_DYNAMODB_LIMIT: BC,
    SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES: $C,
    SEMATTRS_AWS_DYNAMODB_PROJECTION: KC,
    SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY: jC,
    SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY: xC,
    SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT: iL,
    SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD: nL,
    SEMATTRS_AWS_DYNAMODB_SEGMENT: eL,
    SEMATTRS_AWS_DYNAMODB_SELECT: zC,
    SEMATTRS_AWS_DYNAMODB_TABLE_COUNT: tL,
    SEMATTRS_AWS_DYNAMODB_TABLE_NAMES: YC,
    SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS: rL,
    SEMATTRS_AWS_LAMBDA_INVOKED_ARN: _N,
    SEMATTRS_CODE_FILEPATH: RC,
    SEMATTRS_CODE_FUNCTION: vC,
    SEMATTRS_CODE_LINENO: AC,
    SEMATTRS_CODE_NAMESPACE: yC,
    SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL: IN,
    SEMATTRS_DB_CASSANDRA_COORDINATOR_DC: VN,
    SEMATTRS_DB_CASSANDRA_COORDINATOR_ID: PN,
    SEMATTRS_DB_CASSANDRA_IDEMPOTENCE: wN,
    SEMATTRS_DB_CASSANDRA_KEYSPACE: CN,
    SEMATTRS_DB_CASSANDRA_PAGE_SIZE: LN,
    SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT: ZN,
    SEMATTRS_DB_CASSANDRA_TABLE: MN,
    SEMATTRS_DB_CONNECTION_STRING: vN,
    SEMATTRS_DB_HBASE_NAMESPACE: GN,
    SEMATTRS_DB_JDBC_DRIVER_CLASSNAME: RN,
    SEMATTRS_DB_MONGODB_COLLECTION: UN,
    SEMATTRS_DB_MSSQL_INSTANCE_NAME: NN,
    SEMATTRS_DB_NAME: AN,
    SEMATTRS_DB_OPERATION: gN,
    SEMATTRS_DB_REDIS_DATABASE_INDEX: XN,
    SEMATTRS_DB_SQL_TABLE: WN,
    SEMATTRS_DB_STATEMENT: ON,
    SEMATTRS_DB_SYSTEM: bN,
    SEMATTRS_DB_USER: yN,
    SEMATTRS_ENDUSER_ID: EC,
    SEMATTRS_ENDUSER_ROLE: mC,
    SEMATTRS_ENDUSER_SCOPE: TC,
    SEMATTRS_EXCEPTION_ESCAPED: jN,
    SEMATTRS_EXCEPTION_MESSAGE: HN,
    SEMATTRS_EXCEPTION_STACKTRACE: DN,
    SEMATTRS_EXCEPTION_TYPE: YN,
    SEMATTRS_FAAS_COLDSTART: $N,
    SEMATTRS_FAAS_CRON: QN,
    SEMATTRS_FAAS_DOCUMENT_COLLECTION: KN,
    SEMATTRS_FAAS_DOCUMENT_NAME: JN,
    SEMATTRS_FAAS_DOCUMENT_OPERATION: BN,
    SEMATTRS_FAAS_DOCUMENT_TIME: FN,
    SEMATTRS_FAAS_EXECUTION: kN,
    SEMATTRS_FAAS_INVOKED_NAME: qN,
    SEMATTRS_FAAS_INVOKED_PROVIDER: tC,
    SEMATTRS_FAAS_INVOKED_REGION: nC,
    SEMATTRS_FAAS_TIME: zN,
    SEMATTRS_FAAS_TRIGGER: xN,
    SEMATTRS_HTTP_CLIENT_IP: WC,
    SEMATTRS_HTTP_FLAVOR: MC,
    SEMATTRS_HTTP_HOST: CC,
    SEMATTRS_HTTP_METHOD: OC,
    SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH: ZC,
    SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED: PC,
    SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH: VC,
    SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED: GC,
    SEMATTRS_HTTP_ROUTE: UC,
    SEMATTRS_HTTP_SCHEME: LC,
    SEMATTRS_HTTP_SERVER_NAME: XC,
    SEMATTRS_HTTP_STATUS_CODE: IC,
    SEMATTRS_HTTP_TARGET: NC,
    SEMATTRS_HTTP_URL: gC,
    SEMATTRS_HTTP_USER_AGENT: wC,
    SEMATTRS_MESSAGE_COMPRESSED_SIZE: XL,
    SEMATTRS_MESSAGE_ID: GL,
    SEMATTRS_MESSAGE_TYPE: VL,
    SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE: UL,
    SEMATTRS_MESSAGING_CONSUMER_ID: bL,
    SEMATTRS_MESSAGING_CONVERSATION_ID: EL,
    SEMATTRS_MESSAGING_DESTINATION: aL,
    SEMATTRS_MESSAGING_DESTINATION_KIND: lL,
    SEMATTRS_MESSAGING_KAFKA_CLIENT_ID: AL,
    SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP: RL,
    SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY: yL,
    SEMATTRS_MESSAGING_KAFKA_PARTITION: OL,
    SEMATTRS_MESSAGING_KAFKA_TOMBSTONE: gL,
    SEMATTRS_MESSAGING_MESSAGE_ID: SL,
    SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES: TL,
    SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES: mL,
    SEMATTRS_MESSAGING_OPERATION: _L,
    SEMATTRS_MESSAGING_PROTOCOL: dL,
    SEMATTRS_MESSAGING_PROTOCOL_VERSION: hL,
    SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY: vL,
    SEMATTRS_MESSAGING_SYSTEM: cL,
    SEMATTRS_MESSAGING_TEMP_DESTINATION: fL,
    SEMATTRS_MESSAGING_URL: pL,
    SEMATTRS_NET_HOST_CARRIER_ICC: pC,
    SEMATTRS_NET_HOST_CARRIER_MCC: dC,
    SEMATTRS_NET_HOST_CARRIER_MNC: hC,
    SEMATTRS_NET_HOST_CARRIER_NAME: fC,
    SEMATTRS_NET_HOST_CONNECTION_SUBTYPE: lC,
    SEMATTRS_NET_HOST_CONNECTION_TYPE: aC,
    SEMATTRS_NET_HOST_IP: sC,
    SEMATTRS_NET_HOST_NAME: cC,
    SEMATTRS_NET_HOST_PORT: uC,
    SEMATTRS_NET_PEER_IP: rC,
    SEMATTRS_NET_PEER_NAME: iC,
    SEMATTRS_NET_PEER_PORT: oC,
    SEMATTRS_NET_TRANSPORT: eC,
    SEMATTRS_PEER_SERVICE: SC,
    SEMATTRS_RPC_GRPC_STATUS_CODE: IL,
    SEMATTRS_RPC_JSONRPC_ERROR_CODE: ZL,
    SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE: PL,
    SEMATTRS_RPC_JSONRPC_REQUEST_ID: wL,
    SEMATTRS_RPC_JSONRPC_VERSION: ML,
    SEMATTRS_RPC_METHOD: LL,
    SEMATTRS_RPC_SERVICE: CL,
    SEMATTRS_RPC_SYSTEM: NL,
    SEMATTRS_THREAD_ID: _C,
    SEMATTRS_THREAD_NAME: bC,
    SEMRESATTRS_AWS_ECS_CLUSTER_ARN: dV,
    SEMRESATTRS_AWS_ECS_CONTAINER_ARN: fV,
    SEMRESATTRS_AWS_ECS_LAUNCHTYPE: hV,
    SEMRESATTRS_AWS_ECS_TASK_ARN: pV,
    SEMRESATTRS_AWS_ECS_TASK_FAMILY: SV,
    SEMRESATTRS_AWS_ECS_TASK_REVISION: EV,
    SEMRESATTRS_AWS_EKS_CLUSTER_ARN: mV,
    SEMRESATTRS_AWS_LOG_GROUP_ARNS: _V,
    SEMRESATTRS_AWS_LOG_GROUP_NAMES: TV,
    SEMRESATTRS_AWS_LOG_STREAM_ARNS: vV,
    SEMRESATTRS_AWS_LOG_STREAM_NAMES: bV,
    SEMRESATTRS_CLOUD_ACCOUNT_ID: uV,
    SEMRESATTRS_CLOUD_AVAILABILITY_ZONE: aV,
    SEMRESATTRS_CLOUD_PLATFORM: lV,
    SEMRESATTRS_CLOUD_PROVIDER: sV,
    SEMRESATTRS_CLOUD_REGION: cV,
    SEMRESATTRS_CONTAINER_ID: RV,
    SEMRESATTRS_CONTAINER_IMAGE_NAME: OV,
    SEMRESATTRS_CONTAINER_IMAGE_TAG: gV,
    SEMRESATTRS_CONTAINER_NAME: yV,
    SEMRESATTRS_CONTAINER_RUNTIME: AV,
    SEMRESATTRS_DEPLOYMENT_ENVIRONMENT: NV,
    SEMRESATTRS_DEVICE_ID: CV,
    SEMRESATTRS_DEVICE_MODEL_IDENTIFIER: LV,
    SEMRESATTRS_DEVICE_MODEL_NAME: IV,
    SEMRESATTRS_FAAS_ID: wV,
    SEMRESATTRS_FAAS_INSTANCE: PV,
    SEMRESATTRS_FAAS_MAX_MEMORY: VV,
    SEMRESATTRS_FAAS_NAME: MV,
    SEMRESATTRS_FAAS_VERSION: ZV,
    SEMRESATTRS_HOST_ARCH: WV,
    SEMRESATTRS_HOST_ID: GV,
    SEMRESATTRS_HOST_IMAGE_ID: HV,
    SEMRESATTRS_HOST_IMAGE_NAME: YV,
    SEMRESATTRS_HOST_IMAGE_VERSION: DV,
    SEMRESATTRS_HOST_NAME: XV,
    SEMRESATTRS_HOST_TYPE: UV,
    SEMRESATTRS_K8S_CLUSTER_NAME: jV,
    SEMRESATTRS_K8S_CONTAINER_NAME: JV,
    SEMRESATTRS_K8S_CRONJOB_NAME: uG,
    SEMRESATTRS_K8S_CRONJOB_UID: sG,
    SEMRESATTRS_K8S_DAEMONSET_NAME: rG,
    SEMRESATTRS_K8S_DAEMONSET_UID: eG,
    SEMRESATTRS_K8S_DEPLOYMENT_NAME: qV,
    SEMRESATTRS_K8S_DEPLOYMENT_UID: $V,
    SEMRESATTRS_K8S_JOB_NAME: iG,
    SEMRESATTRS_K8S_JOB_UID: oG,
    SEMRESATTRS_K8S_NAMESPACE_NAME: KV,
    SEMRESATTRS_K8S_NODE_NAME: xV,
    SEMRESATTRS_K8S_NODE_UID: kV,
    SEMRESATTRS_K8S_POD_NAME: FV,
    SEMRESATTRS_K8S_POD_UID: BV,
    SEMRESATTRS_K8S_REPLICASET_NAME: QV,
    SEMRESATTRS_K8S_REPLICASET_UID: zV,
    SEMRESATTRS_K8S_STATEFULSET_NAME: nG,
    SEMRESATTRS_K8S_STATEFULSET_UID: tG,
    SEMRESATTRS_OS_DESCRIPTION: aG,
    SEMRESATTRS_OS_NAME: lG,
    SEMRESATTRS_OS_TYPE: cG,
    SEMRESATTRS_OS_VERSION: fG,
    SEMRESATTRS_PROCESS_COMMAND: SG,
    SEMRESATTRS_PROCESS_COMMAND_ARGS: mG,
    SEMRESATTRS_PROCESS_COMMAND_LINE: EG,
    SEMRESATTRS_PROCESS_EXECUTABLE_NAME: hG,
    SEMRESATTRS_PROCESS_EXECUTABLE_PATH: pG,
    SEMRESATTRS_PROCESS_OWNER: TG,
    SEMRESATTRS_PROCESS_PID: dG,
    SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION: vG,
    SEMRESATTRS_PROCESS_RUNTIME_NAME: _G,
    SEMRESATTRS_PROCESS_RUNTIME_VERSION: bG,
    SEMRESATTRS_SERVICE_INSTANCE_ID: AG,
    SEMRESATTRS_SERVICE_NAME: yG,
    SEMRESATTRS_SERVICE_NAMESPACE: RG,
    SEMRESATTRS_SERVICE_VERSION: OG,
    SEMRESATTRS_TELEMETRY_AUTO_VERSION: LG,
    SEMRESATTRS_TELEMETRY_SDK_LANGUAGE: NG,
    SEMRESATTRS_TELEMETRY_SDK_NAME: gG,
    SEMRESATTRS_TELEMETRY_SDK_VERSION: CG,
    SEMRESATTRS_WEBENGINE_DESCRIPTION: wG,
    SEMRESATTRS_WEBENGINE_NAME: IG,
    SEMRESATTRS_WEBENGINE_VERSION: MG,
    SemanticAttributes: WL,
    SemanticResourceAttributes: ZG,
    TELEMETRYSDKLANGUAGEVALUES_CPP: "cpp",
    TELEMETRYSDKLANGUAGEVALUES_DOTNET: lU,
    TELEMETRYSDKLANGUAGEVALUES_ERLANG: fU,
    TELEMETRYSDKLANGUAGEVALUES_GO: "go",
    TELEMETRYSDKLANGUAGEVALUES_JAVA: dU,
    TELEMETRYSDKLANGUAGEVALUES_NODEJS: hU,
    TELEMETRYSDKLANGUAGEVALUES_PHP: "php",
    TELEMETRYSDKLANGUAGEVALUES_PYTHON: pU,
    TELEMETRYSDKLANGUAGEVALUES_RUBY: SU,
    TELEMETRYSDKLANGUAGEVALUES_WEBJS: EU,
    TelemetrySdkLanguageValues: mU,
  });
function _U() {
  return bU(Q), Q;
}
function bU(t) {
  return t.__SENTRY__ || (t.__SENTRY__ = { extensions: {} }), t.__SENTRY__;
}
function vU(t) {
  const n = Pt(),
    e = {
      sid: Dt(),
      init: !0,
      timestamp: n,
      started: n,
      duration: 0,
      status: "ok",
      errors: 0,
      ignoreDuration: !1,
      toJSON: () =>
        (function (t) {
          return Et({
            sid: `${t.sid}`,
            init: t.init,
            started: new Date(1e3 * t.started).toISOString(),
            timestamp: new Date(1e3 * t.timestamp).toISOString(),
            status: t.status,
            errors: t.errors,
            did:
              "number" == typeof t.did || "string" == typeof t.did
                ? `${t.did}`
                : void 0,
            duration: t.duration,
            abnormal_mechanism: t.abnormal_mechanism,
            attrs: {
              release: t.release,
              environment: t.environment,
              ip_address: t.ipAddress,
              user_agent: t.userAgent,
            },
          });
        })(e),
    };
  return t && yU(e, t), e;
}
function yU(t, n = {}) {
  if (
    (n.user &&
      (!t.ipAddress && n.user.ip_address && (t.ipAddress = n.user.ip_address),
      t.did || n.did || (t.did = n.user.id || n.user.email || n.user.username)),
    (t.timestamp = n.timestamp || Pt()),
    n.abnormal_mechanism && (t.abnormal_mechanism = n.abnormal_mechanism),
    n.ignoreDuration && (t.ignoreDuration = n.ignoreDuration),
    n.sid && (t.sid = 32 === n.sid.length ? n.sid : Dt()),
    void 0 !== n.init && (t.init = n.init),
    !t.did && n.did && (t.did = `${n.did}`),
    "number" == typeof n.started && (t.started = n.started),
    t.ignoreDuration)
  )
    t.duration = void 0;
  else if ("number" == typeof n.duration) t.duration = n.duration;
  else {
    const n = t.timestamp - t.started;
    t.duration = n >= 0 ? n : 0;
  }
  n.release && (t.release = n.release),
    n.environment && (t.environment = n.environment),
    !t.ipAddress && n.ipAddress && (t.ipAddress = n.ipAddress),
    !t.userAgent && n.userAgent && (t.userAgent = n.userAgent),
    "number" == typeof n.errors && (t.errors = n.errors),
    n.status && (t.status = n.status);
}
const RU = "_sentrySpan";
function AU(t, n) {
  n ? dt(t, RU, n) : delete t[RU];
}
function OU(t) {
  return t[RU];
}
class gU {
  constructor() {
    (this.Hn = !1),
      (this.Dn = []),
      (this.jn = []),
      (this.xn = []),
      (this.kn = []),
      (this.Kn = {}),
      (this.Bn = {}),
      (this.Fn = {}),
      (this.Jn = {}),
      (this.zn = {}),
      (this.Qn = CU());
  }
  clone() {
    const t = new gU();
    return (
      (t.xn = [...this.xn]),
      (t.Bn = { ...this.Bn }),
      (t.Fn = { ...this.Fn }),
      (t.Jn = { ...this.Jn }),
      (t.Kn = this.Kn),
      (t.$n = this.$n),
      (t.qn = this.qn),
      (t.te = this.te),
      (t.ne = this.ne),
      (t.jn = [...this.jn]),
      (t.ee = this.ee),
      (t.kn = [...this.kn]),
      (t.zn = { ...this.zn }),
      (t.Qn = { ...this.Qn }),
      (t.oe = this.oe),
      (t.ie = this.ie),
      AU(t, OU(this)),
      t
    );
  }
  setClient(t) {
    this.oe = t;
  }
  setLastEventId(t) {
    this.ie = t;
  }
  getClient() {
    return this.oe;
  }
  lastEventId() {
    return this.ie;
  }
  addScopeListener(t) {
    this.Dn.push(t);
  }
  addEventProcessor(t) {
    return this.jn.push(t), this;
  }
  setUser(t) {
    return (
      (this.Kn = t || {
        email: void 0,
        id: void 0,
        ip_address: void 0,
        username: void 0,
      }),
      this.qn && yU(this.qn, { user: t }),
      this.se(),
      this
    );
  }
  getUser() {
    return this.Kn;
  }
  getRequestSession() {
    return this.ee;
  }
  setRequestSession(t) {
    return (this.ee = t), this;
  }
  setTags(t) {
    return (this.Bn = { ...this.Bn, ...t }), this.se(), this;
  }
  setTag(t, n) {
    return (this.Bn = { ...this.Bn, [t]: n }), this.se(), this;
  }
  setExtras(t) {
    return (this.Fn = { ...this.Fn, ...t }), this.se(), this;
  }
  setExtra(t, n) {
    return (this.Fn = { ...this.Fn, [t]: n }), this.se(), this;
  }
  setFingerprint(t) {
    return (this.ne = t), this.se(), this;
  }
  setLevel(t) {
    return (this.$n = t), this.se(), this;
  }
  setTransactionName(t) {
    return (this.te = t), this.se(), this;
  }
  setContext(t, n) {
    return null === n ? delete this.Jn[t] : (this.Jn[t] = n), this.se(), this;
  }
  setSession(t) {
    return t ? (this.qn = t) : delete this.qn, this.se(), this;
  }
  getSession() {
    return this.qn;
  }
  update(t) {
    if (!t) return this;
    const n = "function" == typeof t ? t(this) : t,
      [e, r] =
        n instanceof NU
          ? [n.getScopeData(), n.getRequestSession()]
          : U(n)
            ? [t, t.requestSession]
            : [],
      {
        tags: o,
        extra: i,
        user: s,
        contexts: u,
        level: c,
        fingerprint: a = [],
        propagationContext: l,
      } = e || {};
    return (
      (this.Bn = { ...this.Bn, ...o }),
      (this.Fn = { ...this.Fn, ...i }),
      (this.Jn = { ...this.Jn, ...u }),
      s && Object.keys(s).length && (this.Kn = s),
      c && (this.$n = c),
      a.length && (this.ne = a),
      l && (this.Qn = l),
      r && (this.ee = r),
      this
    );
  }
  clear() {
    return (
      (this.xn = []),
      (this.Bn = {}),
      (this.Fn = {}),
      (this.Kn = {}),
      (this.Jn = {}),
      (this.$n = void 0),
      (this.te = void 0),
      (this.ne = void 0),
      (this.ee = void 0),
      (this.qn = void 0),
      AU(this, void 0),
      (this.kn = []),
      (this.Qn = CU()),
      this.se(),
      this
    );
  }
  addBreadcrumb(t, n) {
    const e = "number" == typeof n ? n : 100;
    if (e <= 0) return this;
    const r = { timestamp: Zt(), ...t },
      o = this.xn;
    return (
      o.push(r), (this.xn = o.length > e ? o.slice(-e) : o), this.se(), this
    );
  }
  getLastBreadcrumb() {
    return this.xn[this.xn.length - 1];
  }
  clearBreadcrumbs() {
    return (this.xn = []), this.se(), this;
  }
  addAttachment(t) {
    return this.kn.push(t), this;
  }
  clearAttachments() {
    return (this.kn = []), this;
  }
  getScopeData() {
    return {
      breadcrumbs: this.xn,
      attachments: this.kn,
      contexts: this.Jn,
      tags: this.Bn,
      extra: this.Fn,
      user: this.Kn,
      level: this.$n,
      fingerprint: this.ne || [],
      eventProcessors: this.jn,
      propagationContext: this.Qn,
      sdkProcessingMetadata: this.zn,
      transactionName: this.te,
      span: OU(this),
    };
  }
  setSDKProcessingMetadata(t) {
    return (this.zn = { ...this.zn, ...t }), this;
  }
  setPropagationContext(t) {
    return (this.Qn = t), this;
  }
  getPropagationContext() {
    return this.Qn;
  }
  captureException(t, n) {
    const e = n && n.event_id ? n.event_id : Dt();
    if (!this.oe)
      return (
        it.warn("No client configured on scope - will not capture exception!"),
        e
      );
    const r = new Error("Sentry syntheticException");
    return (
      this.oe.captureException(
        t,
        { originalException: t, syntheticException: r, ...n, event_id: e },
        this
      ),
      e
    );
  }
  captureMessage(t, n, e) {
    const r = e && e.event_id ? e.event_id : Dt();
    if (!this.oe)
      return (
        it.warn("No client configured on scope - will not capture message!"), r
      );
    const o = new Error(t);
    return (
      this.oe.captureMessage(
        t,
        n,
        { originalException: t, syntheticException: o, ...e, event_id: r },
        this
      ),
      r
    );
  }
  captureEvent(t, n) {
    const e = n && n.event_id ? n.event_id : Dt();
    return this.oe
      ? (this.oe.captureEvent(t, { ...n, event_id: e }, this), e)
      : (it.warn("No client configured on scope - will not capture event!"), e);
  }
  se() {
    this.Hn ||
      ((this.Hn = !0),
      this.Dn.forEach((t) => {
        t(this);
      }),
      (this.Hn = !1));
  }
}
const NU = gU;
function CU() {
  return { traceId: Dt(), spanId: Dt().substring(16) };
}
function LU() {
  return $("defaultCurrentScope", () => new NU());
}
function IU() {
  return $("defaultIsolationScope", () => new NU());
}
function MU() {
  return DU(_U()).getCurrentScope();
}
function wU() {
  return DU(_U()).getIsolationScope();
}
function ZU() {
  return $("globalScope", () => new NU());
}
function PU(...t) {
  const n = DU(_U());
  if (2 === t.length) {
    const [e, r] = t;
    return e ? n.withSetScope(e, r) : n.withScope(r);
  }
  return n.withScope(t[0]);
}
function VU(...t) {
  const n = DU(_U());
  if (2 === t.length) {
    const [e, r] = t;
    return e ? n.withSetIsolationScope(e, r) : n.withIsolationScope(r);
  }
  return n.withIsolationScope(t[0]);
}
function GU() {
  return MU().getClient();
}
class XU {
  constructor(t, n) {
    let e, r;
    (e = t || new NU()),
      (r = n || new NU()),
      (this.ue = [{ scope: e }]),
      (this.ce = r);
  }
  withScope(t) {
    const n = this.ae();
    let e;
    try {
      e = t(n);
    } catch (t) {
      throw (this.le(), t);
    }
    return W(e)
      ? e.then(
          (t) => (this.le(), t),
          (t) => {
            throw (this.le(), t);
          }
        )
      : (this.le(), e);
  }
  getClient() {
    return this.getStackTop().client;
  }
  getScope() {
    return this.getStackTop().scope;
  }
  getIsolationScope() {
    return this.ce;
  }
  getStack() {
    return this.ue;
  }
  getStackTop() {
    return this.ue[this.ue.length - 1];
  }
  ae() {
    const t = this.getScope().clone();
    return this.getStack().push({ client: this.getClient(), scope: t }), t;
  }
  le() {
    return !(this.getStack().length <= 1) && !!this.getStack().pop();
  }
}
function UU() {
  const t = bU(_U());
  return t.hub || (t.hub = new XU(LU(), IU())), t.hub;
}
function WU(t) {
  return UU().withScope(t);
}
function YU(t, n) {
  const e = UU();
  return e.withScope(() => ((e.getStackTop().scope = t), n(t)));
}
function HU(t) {
  return UU().withScope(() => t(UU().getIsolationScope()));
}
function DU(t) {
  const n = bU(t);
  return n.acs
    ? n.acs
    : {
        withIsolationScope: HU,
        withScope: WU,
        withSetScope: YU,
        withSetIsolationScope: (t, n) => HU(n),
        getCurrentScope: () => UU().getScope(),
        getIsolationScope: () => UU().getIsolationScope(),
      };
}
let jU;
function xU(t) {
  return jU ? jU.get(t) : void 0;
}
function kU(t) {
  const n = xU(t);
  if (!n) return;
  const e = {};
  for (const [, [t, r]] of n) e[t] || (e[t] = []), e[t].push(Et(r));
  return e;
}
const KU = "sentry.source",
  BU = "sentry.sample_rate",
  FU = "sentry.op",
  JU = "sentry.origin",
  zU = "sentry.measurement_unit",
  QU = "sentry.measurement_value",
  $U = "cache.key",
  qU = 0,
  tW = 1,
  nW = 2;
function eW(t) {
  if (t < 400 && t >= 100) return { code: tW };
  if (t >= 400 && t < 500)
    switch (t) {
      case 401:
        return { code: nW, message: "unauthenticated" };
      case 403:
        return { code: nW, message: "permission_denied" };
      case 404:
        return { code: nW, message: "not_found" };
      case 409:
        return { code: nW, message: "already_exists" };
      case 413:
        return { code: nW, message: "failed_precondition" };
      case 429:
        return { code: nW, message: "resource_exhausted" };
      case 499:
        return { code: nW, message: "cancelled" };
      default:
        return { code: nW, message: "invalid_argument" };
    }
  if (t >= 500 && t < 600)
    switch (t) {
      case 501:
        return { code: nW, message: "unimplemented" };
      case 503:
        return { code: nW, message: "unavailable" };
      case 504:
        return { code: nW, message: "deadline_exceeded" };
      default:
        return { code: nW, message: "internal_error" };
    }
  return { code: nW, message: "unknown_error" };
}
const rW = "production",
  oW = "_frozenDsc";
function iW(t, n) {
  dt(t, oW, n);
}
function sW(t, n) {
  const e = n.getOptions(),
    { publicKey: r } = n.getDsn() || {},
    o = Et({
      environment: e.environment || rW,
      release: e.release,
      public_key: r,
      trace_id: t,
    });
  return n.emit("createDsc", o), o;
}
function uW(t) {
  const n = GU();
  if (!n) return {};
  const e = sW(hW(t).trace_id || "", n),
    r = bW(t);
  if (!r) return e;
  const o = r[oW];
  if (o) return o;
  const i = hW(r),
    s = i.data || {},
    u = s[BU];
  null != u && (e.sample_rate = `${u}`);
  const c = s[KU];
  return (
    c && "url" !== c && (e.transaction = i.description),
    (e.sampled = String(pW(r))),
    n.emit("createDsc", e),
    e
  );
}
const cW = 1;
function aW(t) {
  const { spanId: n, traceId: e } = t.spanContext(),
    { data: r, op: o, parent_span_id: i, status: s, origin: u } = hW(t);
  return Et({
    parent_span_id: i,
    span_id: n,
    trace_id: e,
    data: r,
    op: o,
    status: s,
    origin: u,
  });
}
function lW(t) {
  const { spanId: n, traceId: e } = t.spanContext(),
    { parent_span_id: r } = hW(t);
  return Et({ parent_span_id: r, span_id: n, trace_id: e });
}
function fW(t) {
  return "number" == typeof t
    ? dW(t)
    : Array.isArray(t)
      ? t[0] + t[1] / 1e9
      : t instanceof Date
        ? dW(t.getTime())
        : Pt();
}
function dW(t) {
  return t > 9999999999 ? t / 1e3 : t;
}
function hW(t) {
  if (
    (function (t) {
      return "function" == typeof t.getSpanJSON;
    })(t)
  )
    return t.getSpanJSON();
  try {
    const { spanId: n, traceId: e } = t.spanContext();
    if (
      (function (t) {
        const n = t;
        return !!(
          n.attributes &&
          n.startTime &&
          n.name &&
          n.endTime &&
          n.status
        );
      })(t)
    ) {
      const {
        attributes: r,
        startTime: o,
        name: i,
        endTime: s,
        parentSpanId: u,
        status: c,
      } = t;
      return Et({
        span_id: n,
        trace_id: e,
        data: r,
        description: i,
        parent_span_id: u,
        start_timestamp: fW(o),
        timestamp: fW(s) || void 0,
        status: SW(c),
        op: r[FU],
        origin: r[JU],
        fe: kU(t),
      });
    }
    return { span_id: n, trace_id: e };
  } catch (t) {
    return {};
  }
}
function pW(t) {
  const { traceFlags: n } = t.spanContext();
  return n === cW;
}
function SW(t) {
  if (t && t.code !== qU)
    return t.code === tW ? "ok" : t.message || "unknown_error";
}
const EW = "_sentryChildSpans",
  mW = "_sentryRootSpan";
function TW(t, n) {
  const e = t[mW] || t;
  dt(n, mW, e),
    t[EW] && t[EW].size < 1e3 ? t[EW].add(n) : dt(t, EW, new Set([n]));
}
function _W(t) {
  const n = new Set();
  return (
    (function t(e) {
      if (!n.has(e) && pW(e)) {
        n.add(e);
        const r = e[EW] ? Array.from(e[EW]) : [];
        for (const n of r) t(n);
      }
    })(t),
    Array.from(n)
  );
}
function bW(t) {
  return t[mW] || t;
}
function vW() {
  const t = DU(_U());
  return t.getActiveSpan ? t.getActiveSpan() : OU(MU());
}
function yW(t, n, e, r, o, i) {
  const s = vW();
  s &&
    (function (t, n, e, r, o, i, s) {
      const u = xU(t) || new Map(),
        c = `${n}:${e}@${o}`,
        a = u.get(s);
      if (a) {
        const [, t] = a;
        u.set(s, [
          c,
          {
            min: Math.min(t.min, r),
            max: Math.max(t.max, r),
            count: (t.count += 1),
            sum: (t.sum += r),
            tags: t.tags,
          },
        ]);
      } else u.set(s, [c, { min: r, max: r, count: 1, sum: r, tags: i }]);
      jU || (jU = new WeakMap()), jU.set(t, u);
    })(s, t, n, e, r, o, i);
}
let RW = !1;
function AW() {
  RW ||
    ((RW = !0),
    (function (t) {
      const n = "error";
      Nt(n, t), Ct(n, Gt);
    })(OW),
    (function (t) {
      const n = "unhandledrejection";
      Nt(n, t), Ct(n, Ut);
    })(OW));
}
function OW() {
  const t = vW(),
    n = t && bW(t);
  if (n) {
    const t = "internal_error";
    n.setStatus({ code: nW, message: t });
  }
}
OW.tag = "sentry_tracingErrorCallback";
const gW = "_sentryScope",
  NW = "_sentryIsolationScope";
function CW(t, n, e) {
  t && (dt(t, NW, e), dt(t, gW, n));
}
function LW(t) {
  return { scope: t[gW], isolationScope: t[NW] };
}
function IW(t) {
  if ("boolean" == typeof __SENTRY_TRACING__ && !__SENTRY_TRACING__) return !1;
  const n =
    t ||
    (function () {
      const t = GU();
      return t && t.getOptions();
    })();
  return (
    !!n && (n.enableTracing || "tracesSampleRate" in n || "tracesSampler" in n)
  );
}
class MW {
  constructor(t = {}) {
    (this.de = t.traceId || Dt()), (this.he = t.spanId || Dt().substring(16));
  }
  spanContext() {
    return { spanId: this.he, traceId: this.de, traceFlags: 0 };
  }
  end(t) {}
  setAttribute(t, n) {
    return this;
  }
  setAttributes(t) {
    return this;
  }
  setStatus(t) {
    return this;
  }
  updateName(t) {
    return this;
  }
  isRecording() {
    return !1;
  }
  addEvent(t, n, e) {
    return this;
  }
}
function wW(t, n, e = () => {}) {
  let r;
  try {
    r = t();
  } catch (t) {
    throw (n(t), e(), t);
  }
  return (function (t, n, e) {
    if (W(t))
      return t.then(
        (t) => (e(), t),
        (t) => {
          throw (n(t), e(), t);
        }
      );
    return e(), t;
  })(r, n, e);
}
function ZW(t) {
  if ("boolean" == typeof t) return Number(t);
  const n = "string" == typeof t ? parseFloat(t) : t;
  return "number" != typeof n || isNaN(n) || n < 0 || n > 1 ? void 0 : n;
}
function PW(t, n) {
  if (!IW(t)) return [!1];
  let e;
  e =
    "function" == typeof t.tracesSampler
      ? t.tracesSampler(n)
      : void 0 !== n.parentSampled
        ? n.parentSampled
        : void 0 !== t.tracesSampleRate
          ? t.tracesSampleRate
          : 1;
  const r = ZW(e);
  if (void 0 === r) return [!1];
  if (!r) return [!1, r];
  return Math.random() < r ? [!0, r] : [!1, r];
}
function VW(t, n, e, r) {
  const o = Wn(e),
    i = t.type && "replay_event" !== t.type ? t.type : "event";
  !(function (t, n) {
    n &&
      ((t.sdk = t.sdk || {}),
      (t.sdk.name = t.sdk.name || n.name),
      (t.sdk.version = t.sdk.version || n.version),
      (t.sdk.integrations = [
        ...(t.sdk.integrations || []),
        ...(n.integrations || []),
      ]),
      (t.sdk.packages = [...(t.sdk.packages || []), ...(n.packages || [])]));
  })(t, e && e.sdk);
  const s = (function (t, n, e, r) {
    const o =
      t.sdkProcessingMetadata && t.sdkProcessingMetadata.dynamicSamplingContext;
    return {
      event_id: t.event_id,
      sent_at: new Date().toISOString(),
      ...(n && { sdk: n }),
      ...(!!e && r && { dsn: ut(r) }),
      ...(o && { trace: Et({ ...o }) }),
    };
  })(t, o, r, n);
  delete t.sdkProcessingMetadata;
  return In(s, [[{ type: i }, t]]);
}
function GW(t) {
  if (!t || 0 === t.length) return;
  const n = {};
  return (
    t.forEach((t) => {
      const e = t.attributes || {},
        r = e[zU],
        o = e[QU];
      "string" == typeof r &&
        "number" == typeof o &&
        (n[t.name] = { value: o, unit: r });
    }),
    n
  );
}
class XW {
  constructor(t = {}) {
    (this.de = t.traceId || Dt()),
      (this.he = t.spanId || Dt().substring(16)),
      (this.pe = t.startTimestamp || Pt()),
      (this.Se = {}),
      this.setAttributes({ [JU]: "manual", [FU]: t.op, ...t.attributes }),
      (this.Ee = t.name),
      t.parentSpanId && (this.me = t.parentSpanId),
      "sampled" in t && (this.Te = t.sampled),
      t.endTimestamp && (this._e = t.endTimestamp),
      (this.u = []),
      (this.be = t.isStandalone),
      this._e && this.ve();
  }
  spanContext() {
    const { he: t, de: n, Te: e } = this;
    return { spanId: t, traceId: n, traceFlags: e ? cW : 0 };
  }
  setAttribute(t, n) {
    void 0 === n ? delete this.Se[t] : (this.Se[t] = n);
  }
  setAttributes(t) {
    Object.keys(t).forEach((n) => this.setAttribute(n, t[n]));
  }
  updateStartTime(t) {
    this.pe = fW(t);
  }
  setStatus(t) {
    return (this.ye = t), this;
  }
  updateName(t) {
    return (this.Ee = t), this;
  }
  end(t) {
    this._e || ((this._e = fW(t)), this.ve());
  }
  getSpanJSON() {
    return Et({
      data: this.Se,
      description: this.Ee,
      op: this.Se[FU],
      parent_span_id: this.me,
      span_id: this.he,
      start_timestamp: this.pe,
      status: SW(this.ye),
      timestamp: this._e,
      trace_id: this.de,
      origin: this.Se[JU],
      fe: kU(this),
      profile_id: this.Se["sentry.profile_id"],
      exclusive_time: this.Se["sentry.exclusive_time"],
      measurements: GW(this.u),
      is_segment: (this.be && bW(this) === this) || void 0,
      segment_id: this.be ? bW(this).spanContext().spanId : void 0,
    });
  }
  isRecording() {
    return !this._e && !!this.Te;
  }
  addEvent(t, n, e) {
    const r = UW(n) ? n : e || Pt(),
      o = UW(n) ? {} : n || {},
      i = { name: t, time: fW(r), attributes: o };
    return this.u.push(i), this;
  }
  isStandaloneSpan() {
    return !!this.be;
  }
  ve() {
    const t = GU();
    t && t.emit("spanEnd", this);
    if (!(this.be || this === bW(this))) return;
    if (this.be)
      return void (function (t) {
        const n = GU();
        if (!n) return;
        const e = t[1];
        if (!e || 0 === e.length)
          return void n.recordDroppedEvent("before_send", "span");
        const r = n.getTransport();
        r && r.send(t).then(null, (t) => {});
      })(
        (function (t, n) {
          const e = uW(t[0]),
            r = {
              sent_at: new Date().toISOString(),
              ...((function (t) {
                return !!t.trace_id && !!t.public_key;
              })(e) && { trace: e }),
            },
            o = n && n.getOptions().beforeSendSpan,
            i = o ? (t) => o(hW(t)) : (t) => hW(t),
            s = [];
          for (const n of t) {
            const t = i(n);
            t && s.push(Vn(t));
          }
          return In(r, s);
        })([this], t)
      );
    const n = this.Re();
    if (n) {
      (LW(this).scope || MU()).captureEvent(n);
    }
  }
  Re() {
    if (!WW(hW(this))) return;
    this.Ee || (this.Ee = "<unlabeled transaction>");
    const { scope: t, isolationScope: n } = LW(this),
      e = (t || MU()).getClient() || GU();
    if (!0 !== this.Te)
      return void (e && e.recordDroppedEvent("sample_rate", "transaction"));
    const r = _W(this)
        .filter(
          (t) =>
            t !== this &&
            !(function (t) {
              return t instanceof XW && t.isStandaloneSpan();
            })(t)
        )
        .map((t) => hW(t))
        .filter(WW),
      o = this.Se[KU],
      i = {
        contexts: { trace: aW(this) },
        spans: r,
        start_timestamp: this.pe,
        timestamp: this._e,
        transaction: this.Ee,
        type: "transaction",
        sdkProcessingMetadata: {
          capturedSpanScope: t,
          capturedSpanIsolationScope: n,
          ...Et({ dynamicSamplingContext: uW(this) }),
        },
        fe: kU(this),
        ...(o && { transaction_info: { source: o } }),
      },
      s = GW(this.u);
    return s && Object.keys(s).length && (i.measurements = s), i;
  }
}
function UW(t) {
  return (t && "number" == typeof t) || t instanceof Date || Array.isArray(t);
}
function WW(t) {
  return !!(t.start_timestamp && t.timestamp && t.span_id && t.trace_id);
}
const YW = "__SENTRY_SUPPRESS_TRACING__";
function HW(t, n) {
  const e = kW();
  if (e.startSpanManual) return e.startSpanManual(t, n);
  const r = xW(t);
  return PU(t.scope, (e) => {
    const o = BW(e),
      i =
        t.onlyIfParent && !o
          ? new MW()
          : jW({
              parentSpan: o,
              spanContext: r,
              forceTransaction: t.forceTransaction,
              scope: e,
            });
    function s() {
      i.end();
    }
    return (
      AU(e, i),
      wW(
        () => n(i, s),
        () => {
          const { status: t } = hW(i);
          !i.isRecording() ||
            (t && "ok" !== t) ||
            i.setStatus({ code: nW, message: "internal_error" });
        }
      )
    );
  });
}
const DW = ({ sentryTrace: t, baggage: n }, e) =>
  PU((r) => {
    const o = Cn(t, n);
    return r.setPropagationContext(o), e();
  });
function jW({ parentSpan: t, spanContext: n, forceTransaction: e, scope: r }) {
  if (!IW()) return new MW();
  const o = wU();
  let i;
  if (t && !e)
    (i = (function (t, n, e) {
      const { spanId: r, traceId: o } = t.spanContext(),
        i = !n.getScopeData().sdkProcessingMetadata[YW] && pW(t),
        s = i
          ? new XW({ ...e, parentSpanId: r, traceId: o, sampled: i })
          : new MW({ traceId: o });
      TW(t, s);
      const u = GU();
      u && (u.emit("spanStart", s), e.endTimestamp && u.emit("spanEnd", s));
      return s;
    })(t, r, n)),
      TW(t, i);
  else if (t) {
    const e = uW(t),
      { traceId: o, spanId: s } = t.spanContext(),
      u = pW(t);
    (i = KW({ traceId: o, parentSpanId: s, ...n }, r, u)), iW(i, e);
  } else {
    const {
      traceId: t,
      dsc: e,
      parentSpanId: s,
      sampled: u,
    } = { ...o.getPropagationContext(), ...r.getPropagationContext() };
    (i = KW({ traceId: t, parentSpanId: s, ...n }, r, u)), e && iW(i, e);
  }
  return CW(i, r, o), i;
}
function xW(t) {
  const n = { isStandalone: (t.experimental || {}).standalone, ...t };
  if (t.startTime) {
    const e = { ...n };
    return (e.startTimestamp = fW(t.startTime)), delete e.startTime, e;
  }
  return n;
}
function kW() {
  return DU(_U());
}
function KW(t, n, e) {
  const r = GU(),
    o = (r && r.getOptions()) || {},
    { name: i = "", attributes: s } = t,
    [u, c] = n.getScopeData().sdkProcessingMetadata[YW]
      ? [!1]
      : PW(o, {
          name: i,
          parentSampled: e,
          attributes: s,
          transactionContext: { name: i, parentSampled: e },
        }),
    a = new XW({
      ...t,
      attributes: { [KU]: "custom", ...t.attributes },
      sampled: u,
    });
  return void 0 !== c && a.setAttribute(BU, c), r && r.emit("spanStart", a), a;
}
function BW(t) {
  const n = OU(t);
  if (!n) return;
  const e = GU();
  return (e ? e.getOptions() : {}).parentSpanIsAlwaysRootSpan ? bW(n) : n;
}
function FW(t, n, e, r = 0) {
  return new on((o, i) => {
    const s = t[r];
    if (null === n || "function" != typeof s) o(n);
    else {
      const u = s({ ...n }, e);
      W(u)
        ? u.then((n) => FW(t, n, e, r + 1).then(o)).then(null, i)
        : FW(t, u, e, r + 1)
            .then(o)
            .then(null, i);
    }
  });
}
function JW(t, n) {
  const {
    fingerprint: e,
    span: r,
    breadcrumbs: o,
    sdkProcessingMetadata: i,
  } = n;
  !(function (t, n) {
    const {
        extra: e,
        tags: r,
        user: o,
        contexts: i,
        level: s,
        transactionName: u,
      } = n,
      c = Et(e);
    c && Object.keys(c).length && (t.extra = { ...c, ...t.extra });
    const a = Et(r);
    a && Object.keys(a).length && (t.tags = { ...a, ...t.tags });
    const l = Et(o);
    l && Object.keys(l).length && (t.user = { ...l, ...t.user });
    const f = Et(i);
    f && Object.keys(f).length && (t.contexts = { ...f, ...t.contexts });
    s && (t.level = s);
    u && "transaction" !== t.type && (t.transaction = u);
  })(t, n),
    r &&
      (function (t, n) {
        (t.contexts = { trace: lW(n), ...t.contexts }),
          (t.sdkProcessingMetadata = {
            dynamicSamplingContext: uW(n),
            ...t.sdkProcessingMetadata,
          });
        const e = bW(n),
          r = hW(e).description;
        r && !t.transaction && "transaction" === t.type && (t.transaction = r);
      })(t, r),
    (function (t, n) {
      (t.fingerprint = t.fingerprint ? Bt(t.fingerprint) : []),
        n && (t.fingerprint = t.fingerprint.concat(n));
      t.fingerprint && !t.fingerprint.length && delete t.fingerprint;
    })(t, e),
    (function (t, n) {
      const e = [...(t.breadcrumbs || []), ...n];
      t.breadcrumbs = e.length ? e : void 0;
    })(t, o),
    (function (t, n) {
      t.sdkProcessingMetadata = { ...t.sdkProcessingMetadata, ...n };
    })(t, i);
}
function zW(t, n) {
  const {
    extra: e,
    tags: r,
    user: o,
    contexts: i,
    level: s,
    sdkProcessingMetadata: u,
    breadcrumbs: c,
    fingerprint: a,
    eventProcessors: l,
    attachments: f,
    propagationContext: d,
    transactionName: h,
    span: p,
  } = n;
  QW(t, "extra", e),
    QW(t, "tags", r),
    QW(t, "user", o),
    QW(t, "contexts", i),
    QW(t, "sdkProcessingMetadata", u),
    s && (t.level = s),
    h && (t.transactionName = h),
    p && (t.span = p),
    c.length && (t.breadcrumbs = [...t.breadcrumbs, ...c]),
    a.length && (t.fingerprint = [...t.fingerprint, ...a]),
    l.length && (t.eventProcessors = [...t.eventProcessors, ...l]),
    f.length && (t.attachments = [...t.attachments, ...f]),
    (t.propagationContext = { ...t.propagationContext, ...d });
}
function QW(t, n, e) {
  if (e && Object.keys(e).length) {
    t[n] = { ...t[n] };
    for (const r in e)
      Object.prototype.hasOwnProperty.call(e, r) && (t[n][r] = e[r]);
  }
}
function $W(t, n, e, r, o, i) {
  const { normalizeDepth: s = 3, normalizeMaxBreadth: u = 1e3 } = t,
    c = {
      ...n,
      event_id: n.event_id || e.event_id || Dt(),
      timestamp: n.timestamp || Zt(),
    },
    a = e.integrations || t.integrations.map((t) => t.name);
  !(function (t, n) {
    const { environment: e, release: r, dist: o, maxValueLength: i = 250 } = n;
    "environment" in t || (t.environment = "environment" in n ? e : rW);
    void 0 === t.release && void 0 !== r && (t.release = r);
    void 0 === t.dist && void 0 !== o && (t.dist = o);
    t.message && (t.message = D(t.message, i));
    const s = t.exception && t.exception.values && t.exception.values[0];
    s && s.value && (s.value = D(s.value, i));
    const u = t.request;
    u && u.url && (u.url = D(u.url, i));
  })(c, t),
    (function (t, n) {
      n.length > 0 &&
        ((t.sdk = t.sdk || {}),
        (t.sdk.integrations = [...(t.sdk.integrations || []), ...n]));
    })(c, a),
    void 0 === n.type &&
      (function (t, n) {
        const e = Q._sentryDebugIds;
        if (!e) return;
        let r;
        const o = qW.get(n);
        o ? (r = o) : ((r = new Map()), qW.set(n, r));
        const i = Object.keys(e).reduce((t, o) => {
          let i;
          const s = r.get(o);
          s ? (i = s) : ((i = n(o)), r.set(o, i));
          for (let n = i.length - 1; n >= 0; n--) {
            const r = i[n];
            if (r.filename) {
              t[r.filename] = e[o];
              break;
            }
          }
          return t;
        }, {});
        try {
          t.exception.values.forEach((t) => {
            t.stacktrace.frames.forEach((t) => {
              t.filename && (t.debug_id = i[t.filename]);
            });
          });
        } catch (t) {}
      })(c, t.stackParser);
  const l = (function (t, n) {
    if (!n) return t;
    const e = t ? t.clone() : new NU();
    return e.update(n), e;
  })(r, e.captureContext);
  e.mechanism && jt(c, e.mechanism);
  const f = o ? o.getEventProcessors() : [],
    d = ZU().getScopeData();
  if (i) {
    zW(d, i.getScopeData());
  }
  if (l) {
    zW(d, l.getScopeData());
  }
  const h = [...(e.attachments || []), ...d.attachments];
  h.length && (e.attachments = h), JW(c, d);
  return FW([...f, ...d.eventProcessors], c, e).then(
    (t) => (
      t &&
        (function (t) {
          const n = {};
          try {
            t.exception.values.forEach((t) => {
              t.stacktrace.frames.forEach((t) => {
                t.debug_id &&
                  (t.abs_path
                    ? (n[t.abs_path] = t.debug_id)
                    : t.filename && (n[t.filename] = t.debug_id),
                  delete t.debug_id);
              });
            });
          } catch (t) {}
          if (0 === Object.keys(n).length) return;
          (t.debug_meta = t.debug_meta || {}),
            (t.debug_meta.images = t.debug_meta.images || []);
          const e = t.debug_meta.images;
          Object.keys(n).forEach((t) => {
            e.push({ type: "sourcemap", code_file: t, debug_id: n[t] });
          });
        })(t),
      "number" == typeof s && s > 0
        ? (function (t, n, e) {
            if (!t) return null;
            const r = {
              ...t,
              ...(t.breadcrumbs && {
                breadcrumbs: t.breadcrumbs.map((t) => ({
                  ...t,
                  ...(t.data && { data: Ft(t.data, n, e) }),
                })),
              }),
              ...(t.user && { user: Ft(t.user, n, e) }),
              ...(t.contexts && { contexts: Ft(t.contexts, n, e) }),
              ...(t.extra && { extra: Ft(t.extra, n, e) }),
            };
            t.contexts &&
              t.contexts.trace &&
              r.contexts &&
              ((r.contexts.trace = t.contexts.trace),
              t.contexts.trace.data &&
                (r.contexts.trace.data = Ft(t.contexts.trace.data, n, e)));
            t.spans &&
              (r.spans = t.spans.map((t) => ({
                ...t,
                ...(t.data && { data: Ft(t.data, n, e) }),
              })));
            return r;
          })(t, s, u)
        : t
    )
  );
}
const qW = new WeakMap();
function tY(t) {
  if (t)
    return (function (t) {
      return t instanceof NU || "function" == typeof t;
    })(t) ||
      (function (t) {
        return Object.keys(t).some((t) => nY.includes(t));
      })(t)
      ? { captureContext: t }
      : t;
}
const nY = [
  "user",
  "level",
  "extra",
  "contexts",
  "tags",
  "fingerprint",
  "requestSession",
  "propagationContext",
];
function captureException(t, n) {
  return MU().captureException(t, tY(n));
}
function captureMessage(t, n) {
  const e = "string" == typeof n ? n : void 0,
    r = "string" != typeof n ? { captureContext: n } : void 0;
  return MU().captureMessage(t, e, r);
}
function eY(t, n) {
  return MU().captureEvent(t, n);
}
function rY(t, n) {
  wU().setContext(t, n);
}
function oY(t) {
  wU().setExtras(t);
}
function iY(t, n) {
  wU().setExtra(t, n);
}
function sY(t) {
  wU().setTags(t);
}
function uY(t, n) {
  wU().setTag(t, n);
}
function cY(t) {
  wU().setUser(t);
}
function aY(t, n) {
  const e = MU(),
    r = GU();
  if (r) {
    if (r.captureCheckIn) return r.captureCheckIn(t, n, e);
  } else;
  return Dt();
}
function lY(t, n, e) {
  const r = aY({ monitorSlug: t, status: "in_progress" }, e),
    o = Pt();
  function i(n) {
    aY({ monitorSlug: t, status: n, checkInId: r, duration: Pt() - o });
  }
  return VU(() => {
    let t;
    try {
      t = n();
    } catch (t) {
      throw (i("error"), t);
    }
    return (
      W(t)
        ? Promise.resolve(t).then(
            () => {
              i("ok");
            },
            () => {
              i("error");
            }
          )
        : i("ok"),
      t
    );
  });
}
async function fY(t) {
  const n = GU();
  return n ? n.flush(t) : Promise.resolve(!1);
}
function dY() {
  const t = GU();
  return !!t && !1 !== t.getOptions().enabled && !!t.getTransport();
}
function hY(t) {
  const n = GU(),
    e = wU(),
    r = MU(),
    { release: o, environment: i = rW } = (n && n.getOptions()) || {},
    { userAgent: s } = Q.navigator || {},
    u = vU({
      release: o,
      environment: i,
      user: r.getUser() || e.getUser(),
      ...(s && { userAgent: s }),
      ...t,
    }),
    c = e.getSession();
  return (
    c && "ok" === c.status && yU(c, { status: "exited" }),
    pY(),
    e.setSession(u),
    r.setSession(u),
    u
  );
}
function pY() {
  const t = wU(),
    n = MU(),
    e = n.getSession() || t.getSession();
  e &&
    (function (t, n) {
      let e = {};
      n ? (e = { status: n }) : "ok" === t.status && (e = { status: "exited" }),
        yU(t, e);
    })(e),
    SY(),
    t.setSession(),
    n.setSession();
}
function SY() {
  const t = wU(),
    n = MU(),
    e = GU(),
    r = n.getSession() || t.getSession();
  r && e && e.captureSession(r);
}
class EY {
  constructor(t, n) {
    (this.oe = t),
      (this.flushTimeout = 60),
      (this.Ae = {}),
      (this.Oe = !0),
      (this.ge = setInterval(() => this.flush(), 1e3 * this.flushTimeout)),
      this.ge.unref && this.ge.unref(),
      (this.Ne = n);
  }
  flush() {
    const t = this.getSessionAggregates();
    0 !== t.aggregates.length && ((this.Ae = {}), this.oe.sendSession(t));
  }
  getSessionAggregates() {
    const t = Object.keys(this.Ae).map((t) => this.Ae[parseInt(t)]);
    return Et({ attrs: this.Ne, aggregates: t });
  }
  close() {
    clearInterval(this.ge), (this.Oe = !1), this.flush();
  }
  incrementSessionStatusCount() {
    if (!this.Oe) return;
    const t = wU(),
      n = t.getRequestSession();
    n &&
      n.status &&
      (this.Ce(n.status, new Date()), t.setRequestSession(void 0));
  }
  Ce(t, n) {
    const e = new Date(n).setSeconds(0, 0);
    this.Ae[e] = this.Ae[e] || {};
    const r = this.Ae[e];
    switch ((r.started || (r.started = new Date(e).toISOString()), t)) {
      case "errored":
        return (r.errored = (r.errored || 0) + 1), r.errored;
      case "ok":
        return (r.exited = (r.exited || 0) + 1), r.exited;
      default:
        return (r.crashed = (r.crashed || 0) + 1), r.crashed;
    }
  }
}
const mY = "7";
function TY(t, n) {
  return (
    (e = {
      sentry_key: t.publicKey,
      sentry_version: mY,
      ...(n && { sentry_client: `${n.name}/${n.version}` }),
    }),
    Object.keys(e)
      .map((t) => `${encodeURIComponent(t)}=${encodeURIComponent(e[t])}`)
      .join("&")
  );
  var e;
}
const _Y = [];
function bY(t) {
  const n = t.defaultIntegrations || [],
    e = t.integrations;
  let r;
  n.forEach((t) => {
    t.isDefaultInstance = !0;
  }),
    (r = Array.isArray(e)
      ? [...n, ...e]
      : "function" == typeof e
        ? Bt(e(n))
        : n);
  const o = (function (t) {
      const n = {};
      return (
        t.forEach((t) => {
          const { name: e } = t,
            r = n[e];
          (r && !r.isDefaultInstance && t.isDefaultInstance) || (n[e] = t);
        }),
        Object.keys(n).map((t) => n[t])
      );
    })(r),
    i = (function (t, n) {
      for (let e = 0; e < t.length; e++) if (!0 === n(t[e])) return e;
      return -1;
    })(o, (t) => "Debug" === t.name);
  if (-1 !== i) {
    const [t] = o.splice(i, 1);
    o.push(t);
  }
  return o;
}
function vY(t, n) {
  for (const e of n) e && e.afterAllSetup && e.afterAllSetup(t);
}
function yY(t, n, e) {
  if (!e[n.name]) {
    if (
      ((e[n.name] = n),
      -1 === _Y.indexOf(n.name) &&
        "function" == typeof n.setupOnce &&
        (n.setupOnce(), _Y.push(n.name)),
      n.setup && "function" == typeof n.setup && n.setup(t),
      "function" == typeof n.preprocessEvent)
    ) {
      const e = n.preprocessEvent.bind(n);
      t.on("preprocessEvent", (n, r) => e(n, r, t));
    }
    if ("function" == typeof n.processEvent) {
      const e = n.processEvent.bind(n),
        r = Object.assign((n, r) => e(n, r, t), { id: n.name });
      t.addEventProcessor(r);
    }
  }
}
class RY {
  constructor(t) {
    if (
      ((this.Le = t),
      (this._integrations = {}),
      (this.Ie = 0),
      (this.Me = {}),
      (this.ln = {}),
      (this.jn = []),
      t.dsn && (this.we = at(t.dsn)),
      this.we)
    ) {
      const o =
        ((n = this.we),
        (e = t.tunnel),
        (r = t.Ze ? t.Ze.sdk : void 0),
        e ||
          `${(function (t) {
            return `${(function (t) {
              const n = t.protocol ? `${t.protocol}:` : "",
                e = t.port ? `:${t.port}` : "";
              return `${n}//${t.host}${e}${t.path ? `/${t.path}` : ""}/api/`;
            })(t)}${t.projectId}/envelope/`;
          })(n)}?${TY(n, r)}`);
      this.Pe = t.transport({
        tunnel: this.Le.tunnel,
        recordDroppedEvent: this.recordDroppedEvent.bind(this),
        ...t.transportOptions,
        url: o,
      });
    }
    var n, e, r;
  }
  captureException(t, n, e) {
    const r = Dt();
    if (Kt(t)) return r;
    const o = { event_id: r, ...n };
    return (
      this.Ve(this.eventFromException(t, o).then((t) => this.Ge(t, o, e))),
      o.event_id
    );
  }
  captureMessage(t, n, e, r) {
    const o = { event_id: Dt(), ...e },
      i = X(t) ? t : String(t),
      s =
        null === (u = t) ||
        X(u) ||
        ("object" != typeof u && "function" != typeof u)
          ? this.eventFromMessage(i, n, o)
          : this.eventFromException(t, o);
    var u;
    return this.Ve(s.then((t) => this.Ge(t, o, r))), o.event_id;
  }
  captureEvent(t, n, e) {
    const r = Dt();
    if (n && n.originalException && Kt(n.originalException)) return r;
    const o = { event_id: r, ...n },
      i = (t.sdkProcessingMetadata || {}).capturedSpanScope;
    return this.Ve(this.Ge(t, o, i || e)), o.event_id;
  }
  captureSession(t) {
    "string" != typeof t.release || (this.sendSession(t), yU(t, { init: !1 }));
  }
  getDsn() {
    return this.we;
  }
  getOptions() {
    return this.Le;
  }
  getSdkMetadata() {
    return this.Le.Ze;
  }
  getTransport() {
    return this.Pe;
  }
  flush(t) {
    const n = this.Pe;
    return n
      ? (this.emit("flush"),
        this.Xe(t).then((e) => n.flush(t).then((t) => e && t)))
      : en(!0);
  }
  close(t) {
    return this.flush(t).then(
      (t) => ((this.getOptions().enabled = !1), this.emit("close"), t)
    );
  }
  getEventProcessors() {
    return this.jn;
  }
  addEventProcessor(t) {
    this.jn.push(t);
  }
  init() {
    this.Oe() && this.Ue();
  }
  getIntegrationByName(t) {
    return this._integrations[t];
  }
  addIntegration(t) {
    const n = this._integrations[t.name];
    yY(this, t, this._integrations), n || vY(this, [t]);
  }
  sendEvent(t, n = {}) {
    this.emit("beforeSendEvent", t, n);
    let e = VW(t, this.we, this.Le.Ze, this.Le.tunnel);
    for (const t of n.attachments || []) e = Mn(e, Gn(t));
    const r = this.sendEnvelope(e);
    r && r.then((n) => this.emit("afterSendEvent", t, n), null);
  }
  sendSession(t) {
    const n = (function (t, n, e, r) {
      const o = Wn(e);
      return In(
        {
          sent_at: new Date().toISOString(),
          ...(o && { sdk: o }),
          ...(!!r && n && { dsn: ut(n) }),
        },
        [
          "aggregates" in t
            ? [{ type: "sessions" }, t]
            : [{ type: "session" }, t.toJSON()],
        ]
      );
    })(t, this.we, this.Le.Ze, this.Le.tunnel);
    this.sendEnvelope(n);
  }
  recordDroppedEvent(t, n, e) {
    if (this.Le.sendClientReports) {
      const e = `${t}:${n}`;
      this.Me[e] = this.Me[e] + 1 || 1;
    }
  }
  on(t, n) {
    this.ln[t] || (this.ln[t] = []), this.ln[t].push(n);
  }
  emit(t, ...n) {
    this.ln[t] && this.ln[t].forEach((t) => t(...n));
  }
  sendEnvelope(t) {
    return (
      this.emit("beforeEnvelope", t),
      this.Oe() && this.Pe ? this.Pe.send(t).then(null, (t) => t) : en({})
    );
  }
  Ue() {
    const { integrations: t } = this.Le;
    (this._integrations = (function (t, n) {
      const e = {};
      return (
        n.forEach((n) => {
          n && yY(t, n, e);
        }),
        e
      );
    })(this, t)),
      vY(this, t);
  }
  We(t, n) {
    let e = !1,
      r = !1;
    const o = n.exception && n.exception.values;
    if (o) {
      r = !0;
      for (const t of o) {
        const n = t.mechanism;
        if (n && !1 === n.handled) {
          e = !0;
          break;
        }
      }
    }
    const i = "ok" === t.status;
    ((i && 0 === t.errors) || (i && e)) &&
      (yU(t, {
        ...(e && { status: "crashed" }),
        errors: t.errors || Number(r || e),
      }),
      this.captureSession(t));
  }
  Xe(t) {
    return new on((n) => {
      let e = 0;
      const r = setInterval(() => {
        0 == this.Ie
          ? (clearInterval(r), n(!0))
          : ((e += 1), t && e >= t && (clearInterval(r), n(!1)));
      }, 1);
    });
  }
  Oe() {
    return !1 !== this.getOptions().enabled && void 0 !== this.Pe;
  }
  Ye(t, n, e, r = wU()) {
    const o = this.getOptions(),
      i = Object.keys(this._integrations);
    return (
      !n.integrations && i.length > 0 && (n.integrations = i),
      this.emit("preprocessEvent", t, n),
      t.type || r.setLastEventId(t.event_id || n.event_id),
      $W(o, t, n, e, this, r).then((t) => {
        if (null === t) return t;
        const n = {
          ...r.getPropagationContext(),
          ...(e ? e.getPropagationContext() : void 0),
        };
        if (!(t.contexts && t.contexts.trace) && n) {
          const { traceId: e, spanId: r, parentSpanId: o, dsc: i } = n;
          t.contexts = {
            trace: Et({ trace_id: e, span_id: r, parent_span_id: o }),
            ...t.contexts,
          };
          const s = i || sW(e, this);
          t.sdkProcessingMetadata = {
            dynamicSamplingContext: s,
            ...t.sdkProcessingMetadata,
          };
        }
        return t;
      })
    );
  }
  Ge(t, n = {}, e) {
    return this.He(t, n, e).then(
      (t) => t.event_id,
      (t) => {}
    );
  }
  He(t, n, e) {
    const r = this.getOptions(),
      { sampleRate: o } = r,
      i = OY(t),
      s = AY(t),
      u = t.type || "error",
      c = `before send for type \`${u}\``,
      a = void 0 === o ? void 0 : ZW(o);
    if (s && "number" == typeof a && Math.random() > a)
      return (
        this.recordDroppedEvent("sample_rate", "error", t),
        rn(
          new lt(
            `Discarding event because it's not included in the random sample (sampling rate = ${o})`,
            "log"
          )
        )
      );
    const l = "replay_event" === u ? "replay" : u,
      f = (t.sdkProcessingMetadata || {}).capturedSpanIsolationScope;
    return this.Ye(t, n, e, f)
      .then((e) => {
        if (null === e)
          throw (
            (this.recordDroppedEvent("event_processor", l, t),
            new lt(
              "An event processor returned `null`, will not send event.",
              "log"
            ))
          );
        if (n.data && !0 === n.data.__sentry__) return e;
        const o = (function (t, n, e) {
          const {
            beforeSend: r,
            beforeSendTransaction: o,
            beforeSendSpan: i,
          } = t;
          if (AY(n) && r) return r(n, e);
          if (OY(n)) {
            if (n.spans && i) {
              const t = [];
              for (const e of n.spans) {
                const n = i(e);
                n && t.push(n);
              }
              n.spans = t;
            }
            if (o) return o(n, e);
          }
          return n;
        })(r, e, n);
        return (function (t, n) {
          const e = `${n} must return \`null\` or a valid event.`;
          if (W(t))
            return t.then(
              (t) => {
                if (!U(t) && null !== t) throw new lt(e);
                return t;
              },
              (t) => {
                throw new lt(`${n} rejected with ${t}`);
              }
            );
          if (!U(t) && null !== t) throw new lt(e);
          return t;
        })(o, c);
      })
      .then((r) => {
        if (null === r)
          throw (
            (this.recordDroppedEvent("before_send", l, t),
            new lt(`${c} returned \`null\`, will not send event.`, "log"))
          );
        const o = e && e.getSession();
        !i && o && this.We(o, r);
        const s = r.transaction_info;
        if (i && s && r.transaction !== t.transaction) {
          const t = "custom";
          r.transaction_info = { ...s, source: t };
        }
        return this.sendEvent(r, n), r;
      })
      .then(null, (t) => {
        if (t instanceof lt) throw t;
        throw (
          (this.captureException(t, {
            data: { __sentry__: !0 },
            originalException: t,
          }),
          new lt(
            `Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\nReason: ${t}`
          ))
        );
      });
  }
  Ve(t) {
    this.Ie++,
      t.then(
        (t) => (this.Ie--, t),
        (t) => (this.Ie--, t)
      );
  }
  De() {
    const t = this.Me;
    return (
      (this.Me = {}),
      Object.keys(t).map((n) => {
        const [e, r] = n.split(":");
        return { reason: e, category: r, quantity: t[n] };
      })
    );
  }
}
function AY(t) {
  return void 0 === t.type;
}
function OY(t) {
  return "transaction" === t.type;
}
class gY extends RY {
  constructor(t) {
    AW(), super(t);
  }
  eventFromException(t, n) {
    return en(
      (function (t, n, e, r) {
        const o = (r && r.data && r.data.mechanism) || {
            handled: !0,
            type: "generic",
          },
          [i, s] = kn(t, o, e, r),
          u = { exception: { values: [jn(n, i)] } };
        return (
          s && (u.extra = s),
          (function (t, n, e) {
            const r = (t.exception = t.exception || {}),
              o = (r.values = r.values || []),
              i = (o[0] = o[0] || {});
            i.value || (i.value = n || ""), i.type || (i.type = e || "Error");
          })(u, void 0, void 0),
          jt(u, o),
          { ...u, event_id: r && r.event_id }
        );
      })(this, this.Le.stackParser, t, n)
    );
  }
  eventFromMessage(t, n = "info", e) {
    return en(
      (function (t, n, e = "info", r, o) {
        const i = { event_id: r && r.event_id, level: e };
        if (o && r && r.syntheticException) {
          const e = Dn(t, r.syntheticException);
          e.length &&
            (i.exception = {
              values: [{ value: n, stacktrace: { frames: e } }],
            });
        }
        if (X(n)) {
          const {
            __sentry_template_string__: t,
            __sentry_template_values__: e,
          } = n;
          return (i.logentry = { message: t, params: e }), i;
        }
        return (i.message = n), i;
      })(this.Le.stackParser, t, n, e, this.Le.attachStacktrace)
    );
  }
  captureException(t, n, e) {
    if (this.Le.autoSessionTracking && this.je) {
      const t = wU().getRequestSession();
      t && "ok" === t.status && (t.status = "errored");
    }
    return super.captureException(t, n, e);
  }
  captureEvent(t, n, e) {
    if (this.Le.autoSessionTracking && this.je) {
      if (
        "exception" === (t.type || "exception") &&
        t.exception &&
        t.exception.values &&
        t.exception.values.length > 0
      ) {
        const t = wU().getRequestSession();
        t && "ok" === t.status && (t.status = "errored");
      }
    }
    return super.captureEvent(t, n, e);
  }
  close(t) {
    return this.je && this.je.close(), super.close(t);
  }
  initSessionFlusher() {
    const { release: t, environment: n } = this.Le;
    t && (this.je = new EY(this, { release: t, environment: n }));
  }
  captureCheckIn(t, n, e) {
    const r = "checkInId" in t && t.checkInId ? t.checkInId : Dt();
    if (!this.Oe()) return r;
    const o = this.getOptions(),
      { release: i, environment: s, tunnel: u } = o,
      c = {
        check_in_id: r,
        monitor_slug: t.monitorSlug,
        status: t.status,
        release: i,
        environment: s,
      };
    "duration" in t && (c.duration = t.duration),
      n &&
        (c.monitor_config = {
          schedule: n.schedule,
          checkin_margin: n.checkinMargin,
          max_runtime: n.maxRuntime,
          timezone: n.timezone,
        });
    const [a, l] = this.xe(e);
    l && (c.contexts = { trace: l });
    const f = (function (t, n, e, r, o) {
      const i = { sent_at: new Date().toISOString() };
      e && e.sdk && (i.sdk = { name: e.sdk.name, version: e.sdk.version }),
        r && o && (i.dsn = ut(o)),
        n && (i.trace = Et(n));
      const s = (function (t) {
        return [{ type: "check_in" }, t];
      })(t);
      return In(i, [s]);
    })(c, a, this.getSdkMetadata(), u, this.getDsn());
    return this.sendEnvelope(f), r;
  }
  ke() {
    this.je && this.je.incrementSessionStatusCount();
  }
  Ye(t, n, e, r) {
    return (
      this.Le.platform && (t.platform = t.platform || this.Le.platform),
      this.Le.runtime &&
        (t.contexts = {
          ...t.contexts,
          runtime: (t.contexts || {}).runtime || this.Le.runtime,
        }),
      this.Le.serverName &&
        (t.server_name = t.server_name || this.Le.serverName),
      super.Ye(t, n, e, r)
    );
  }
  xe(t) {
    if (!t) return [void 0, void 0];
    const n = OU(t);
    if (n) {
      const t = bW(n);
      return [uW(t), lW(t)];
    }
    const {
        traceId: e,
        spanId: r,
        parentSpanId: o,
        dsc: i,
      } = t.getPropagationContext(),
      s = { trace_id: e, span_id: r, parent_span_id: o };
    return i ? [i, s] : [sW(e, this), s];
  }
}
const NY = 64;
function CY(t, n, e = sn(t.bufferSize || NY)) {
  let r = {};
  return {
    send: function (o) {
      const i = [];
      if (
        (wn(o, (n, e) => {
          const o = Un(e);
          if (
            (function (t, n, e = Date.now()) {
              return (
                (function (t, n) {
                  return t[n] || t.all || 0;
                })(t, n) > e
              );
            })(r, o)
          ) {
            const r = LY(n, e);
            t.recordDroppedEvent("ratelimit_backoff", o, r);
          } else i.push(n);
        }),
        0 === i.length)
      )
        return en({});
      const s = In(o[0], i),
        u = (n) => {
          wn(s, (e, r) => {
            const o = LY(e, r);
            t.recordDroppedEvent(n, Un(r), o);
          });
        };
      return e
        .add(() =>
          n({ body: Pn(s) }).then(
            (t) => ((r = Hn(r, t)), t),
            (t) => {
              throw (u("network_error"), t);
            }
          )
        )
        .then(
          (t) => t,
          (t) => {
            if (t instanceof lt) return u("queue_overflow"), en({});
            throw t;
          }
        );
    },
    flush: (t) => e.drain(t),
  };
}
function LY(t, n) {
  if ("event" === n || "transaction" === n)
    return Array.isArray(t) ? t[1] : void 0;
}
const IY = "8.2.1";
function MY(t, n) {
  const e = n && n.getDsn(),
    r = n && n.getOptions().tunnel;
  return (
    (function (t, n) {
      return !!n && t.includes(n.host);
    })(t, e) ||
    (function (t, n) {
      if (!n) return !1;
      return wY(t) === wY(n);
    })(t, r)
  );
}
function wY(t) {
  return "/" === t[t.length - 1] ? t.slice(0, -1) : t;
}
const ZY = 100;
function PY(t, n) {
  const e = GU(),
    r = wU();
  if (!e) return;
  const { beforeBreadcrumb: o = null, maxBreadcrumbs: i = ZY } = e.getOptions();
  if (i <= 0) return;
  const s = { timestamp: Zt(), ...t },
    u = o ? ot(() => o(s, n)) : s;
  null !== u &&
    (e.emit && e.emit("beforeAddBreadcrumb", u, n), r.addBreadcrumb(u, i));
}
let VY;
const GY = new WeakMap(),
  XY = () => ({
    name: "FunctionToString",
    setupOnce() {
      VY = Function.prototype.toString;
      try {
        Function.prototype.toString = function (...t) {
          const n = (function (t) {
              return t.__sentry_original__;
            })(this),
            e = GY.has(GU()) && void 0 !== n ? n : this;
          return VY.apply(e, t);
        };
      } catch (t) {}
    },
    setup(t) {
      GY.set(t, !0);
    },
  }),
  UY = [
    /^Script error\.?$/,
    /^Javascript error: Script error\.? on line 0$/,
    /^ResizeObserver loop completed with undelivered notifications.$/,
    /^Cannot redefine property: googletag$/,
  ],
  WY = (t = {}) => ({
    name: "InboundFilters",
    processEvent(n, e, r) {
      const o = r.getOptions(),
        i = (function (t = {}, n = {}) {
          return {
            allowUrls: [...(t.allowUrls || []), ...(n.allowUrls || [])],
            denyUrls: [...(t.denyUrls || []), ...(n.denyUrls || [])],
            ignoreErrors: [
              ...(t.ignoreErrors || []),
              ...(n.ignoreErrors || []),
              ...(t.disableErrorDefaults ? [] : UY),
            ],
            ignoreTransactions: [
              ...(t.ignoreTransactions || []),
              ...(n.ignoreTransactions || []),
            ],
            ignoreInternal: void 0 === t.ignoreInternal || t.ignoreInternal,
          };
        })(t, o);
      return (function (t, n) {
        if (
          n.ignoreInternal &&
          (function (t) {
            try {
              return "SentryError" === t.exception.values[0].type;
            } catch (t) {}
            return !1;
          })(t)
        )
          return !0;
        if (
          (function (t, n) {
            if (t.type || !n || !n.length) return !1;
            return (function (t) {
              const n = [];
              t.message && n.push(t.message);
              let e;
              try {
                e = t.exception.values[t.exception.values.length - 1];
              } catch (t) {}
              e &&
                e.value &&
                (n.push(e.value), e.type && n.push(`${e.type}: ${e.value}`));
              return n;
            })(t).some((t) => K(t, n));
          })(t, n.ignoreErrors)
        )
          return !0;
        if (
          (function (t, n) {
            if ("transaction" !== t.type || !n || !n.length) return !1;
            const e = t.transaction;
            return !!e && K(e, n);
          })(t, n.ignoreTransactions)
        )
          return !0;
        if (
          (function (t, n) {
            if (!n || !n.length) return !1;
            const e = YY(t);
            return !!e && K(e, n);
          })(t, n.denyUrls)
        )
          return !0;
        if (
          !(function (t, n) {
            if (!n || !n.length) return !0;
            const e = YY(t);
            return !e || K(e, n);
          })(t, n.allowUrls)
        )
          return !0;
        return !1;
      })(n, i)
        ? null
        : n;
    },
  });
function YY(t) {
  try {
    let n;
    try {
      n = t.exception.values[0].stacktrace.frames;
    } catch (t) {}
    return n
      ? (function (t = []) {
          for (let n = t.length - 1; n >= 0; n--) {
            const e = t[n];
            if (
              e &&
              "<anonymous>" !== e.filename &&
              "[native code]" !== e.filename
            )
              return e.filename || null;
          }
          return null;
        })(n)
      : null;
  } catch (t) {
    return null;
  }
}
const HY = (t = {}) => {
    const n = t.limit || 5,
      e = t.key || "cause";
    return {
      name: "LinkedErrors",
      preprocessEvent(t, r, o) {
        const i = o.getOptions();
        B(jn, i.stackParser, i.maxValueLength, e, n, t, r);
      },
    };
  },
  DY = {
    include: {
      cookies: !0,
      data: !0,
      headers: !0,
      ip: !1,
      query_string: !0,
      url: !0,
      user: { id: !0, username: !0, email: !0 },
    },
    transactionNamingScheme: "methodPath",
  },
  jY = (t = {}) => {
    const n = {
      ...DY,
      ...t,
      include: {
        ...DY.include,
        ...t.include,
        user:
          t.include && "boolean" == typeof t.include.user
            ? t.include.user
            : { ...DY.include.user, ...(t.include || {}).user },
      },
    };
    return {
      name: "RequestData",
      processEvent(t) {
        const { sdkProcessingMetadata: e = {} } = t,
          r = e.request;
        if (!r) return t;
        return Sn(
          t,
          r,
          (function (t) {
            const {
                transactionNamingScheme: n,
                include: { ip: e, user: r, ...o },
              } = t,
              i = ["method"];
            for (const [t, n] of Object.entries(o)) n && i.push(t);
            let s;
            if (void 0 === r) s = !0;
            else if ("boolean" == typeof r) s = r;
            else {
              const t = [];
              for (const [n, e] of Object.entries(r)) e && t.push(n);
              s = t;
            }
            return {
              include: {
                ip: e,
                user: s,
                request: 0 !== i.length ? i : void 0,
                transaction: n,
              },
            };
          })(n)
        );
      },
    };
  };
const xY = (t = {}) => {
  const n = t.levels || et;
  return {
    name: "CaptureConsole",
    setup(t) {
      "console" in Q &&
        It(({ args: e, level: r }) => {
          GU() === t &&
            n.includes(r) &&
            (function (t, n) {
              const e = { level: mn(n), extra: { arguments: t } };
              PU((r) => {
                if (
                  (r.addEventProcessor(
                    (t) => (
                      (t.logger = "console"),
                      jt(t, { handled: !1, type: "console" }),
                      t
                    )
                  ),
                  "assert" === n)
                ) {
                  if (!t[0]) {
                    const n = `Assertion failed: ${
                      x(t.slice(1), " ") || "console.assert"
                    }`;
                    r.setExtra("arguments", t.slice(1)), captureMessage(n, e);
                  }
                  return;
                }
                const o = t.find((t) => t instanceof Error);
                if (o) return void captureException(o, e);
                captureMessage(x(t, " "), e);
              });
            })(e, r);
        });
    },
  };
};
const kY = (t = {}) => {
    const n = { debugger: !1, stringify: !1, ...t };
    return {
      name: "Debug",
      setup(t) {
        t.on("beforeSendEvent", (t, e) => {
          n.debugger,
            ot(() => {
              n.stringify
                ? (console.log(JSON.stringify(t, null, 2)),
                  e &&
                    Object.keys(e).length &&
                    console.log(JSON.stringify(e, null, 2)))
                : (console.log(t),
                  e && Object.keys(e).length && console.log(e));
            });
        });
      },
    };
  },
  KY = () => {
    let t;
    return {
      name: "Dedupe",
      processEvent(n) {
        if (n.type) return n;
        try {
          if (
            (function (t, n) {
              if (!n) return !1;
              if (
                (function (t, n) {
                  const e = t.message,
                    r = n.message;
                  if (!e && !r) return !1;
                  if ((e && !r) || (!e && r)) return !1;
                  if (e !== r) return !1;
                  if (!FY(t, n)) return !1;
                  if (!BY(t, n)) return !1;
                  return !0;
                })(t, n)
              )
                return !0;
              if (
                (function (t, n) {
                  const e = JY(n),
                    r = JY(t);
                  if (!e || !r) return !1;
                  if (e.type !== r.type || e.value !== r.value) return !1;
                  if (!FY(t, n)) return !1;
                  if (!BY(t, n)) return !1;
                  return !0;
                })(t, n)
              )
                return !0;
              return !1;
            })(n, t)
          )
            return null;
        } catch (t) {}
        return (t = n);
      },
    };
  };
function BY(t, n) {
  let e = zY(t),
    r = zY(n);
  if (!e && !r) return !0;
  if ((e && !r) || (!e && r)) return !1;
  if (r.length !== e.length) return !1;
  for (let t = 0; t < r.length; t++) {
    const n = r[t],
      o = e[t];
    if (
      n.filename !== o.filename ||
      n.lineno !== o.lineno ||
      n.colno !== o.colno ||
      n.function !== o.function
    )
      return !1;
  }
  return !0;
}
function FY(t, n) {
  let e = t.fingerprint,
    r = n.fingerprint;
  if (!e && !r) return !0;
  if ((e && !r) || (!e && r)) return !1;
  try {
    return !(e.join("") !== r.join(""));
  } catch (t) {
    return !1;
  }
}
function JY(t) {
  return t.exception && t.exception.values && t.exception.values[0];
}
function zY(t) {
  const n = t.exception;
  if (n)
    try {
      return n.values[0].stacktrace.frames;
    } catch (t) {
      return;
    }
}
const QY = (t = {}) => {
  const { depth: n = 3, captureErrorCause: e = !0 } = t;
  return {
    name: "ExtraErrorData",
    processEvent: (t, r) =>
      (function (t, n = {}, e, r) {
        if (!n.originalException || !P(n.originalException)) return t;
        const o =
            n.originalException.name || n.originalException.constructor.name,
          i = (function (t, n) {
            try {
              const e = [
                  "name",
                  "message",
                  "stack",
                  "line",
                  "column",
                  "fileName",
                  "lineNumber",
                  "columnNumber",
                  "toJSON",
                ],
                r = {};
              for (const n of Object.keys(t)) {
                if (-1 !== e.indexOf(n)) continue;
                const o = t[n];
                r[n] = P(o) ? o.toString() : o;
              }
              if (
                (n &&
                  void 0 !== t.cause &&
                  (r.cause = P(t.cause) ? t.cause.toString() : t.cause),
                "function" == typeof t.toJSON)
              ) {
                const n = t.toJSON();
                for (const t of Object.keys(n)) {
                  const e = n[t];
                  r[t] = P(e) ? e.toString() : e;
                }
              }
              return r;
            } catch (t) {}
            return null;
          })(n.originalException, r);
        if (i) {
          const n = { ...t.contexts },
            r = Ft(i, e);
          return (
            U(r) && (dt(r, "__sentry_skip_normalization__", !0), (n[o] = r)),
            { ...t, contexts: n }
          );
        }
        return t;
      })(t, r, n, e),
  };
};
const $Y = (t = {}) => {
  const n = t.root,
    e = t.prefix || "app:///",
    r = "window" in Q && void 0 !== Q.window,
    o =
      t.iteratee ||
      (function ({ isBrowser: t, root: n, prefix: e }) {
        return (r) => {
          if (!r.filename) return r;
          const o =
              /^[a-zA-Z]:\\/.test(r.filename) ||
              (r.filename.includes("\\") && !r.filename.includes("/")),
            i = /^\//.test(r.filename);
          if (t) {
            if (n) {
              const t = r.filename;
              0 === t.indexOf(n) && (r.filename = t.replace(n, e));
            }
          } else if (o || i) {
            const t = o
                ? r.filename.replace(/^[a-zA-Z]:/, "").replace(/\\/g, "/")
                : r.filename,
              i = n
                ? (function (t, n) {
                    (t = qt(t).slice(1)), (n = qt(n).slice(1));
                    const e = tn(t.split("/")),
                      r = tn(n.split("/")),
                      o = Math.min(e.length, r.length);
                    let i = o;
                    for (let t = 0; t < o; t++)
                      if (e[t] !== r[t]) {
                        i = t;
                        break;
                      }
                    let s = [];
                    for (let t = i; t < e.length; t++) s.push("..");
                    return (s = s.concat(r.slice(i))), s.join("/");
                  })(n, t)
                : (function (t, n) {
                    let e = $t(t)[2];
                    return (
                      n &&
                        e.slice(-1 * n.length) === n &&
                        (e = e.slice(0, e.length - n.length)),
                      e
                    );
                  })(t);
            r.filename = `${e}${i}`;
          }
          return r;
        };
      })({ isBrowser: r, root: n, prefix: e });
  return {
    name: "RewriteFrames",
    processEvent(t) {
      let n = t;
      return (
        t.exception &&
          Array.isArray(t.exception.values) &&
          (n = (function (t) {
            try {
              return {
                ...t,
                exception: {
                  ...t.exception,
                  values: t.exception.values.map((t) => {
                    return {
                      ...t,
                      ...(t.stacktrace && {
                        stacktrace:
                          ((n = t.stacktrace),
                          {
                            ...n,
                            frames: n && n.frames && n.frames.map((t) => o(t)),
                          }),
                      }),
                    };
                    var n;
                  }),
                },
              };
            } catch (n) {
              return t;
            }
          })(n)),
        n
      );
    },
  };
};
const qY = () => {
  const t = 1e3 * Pt();
  return {
    name: "SessionTiming",
    processEvent(n) {
      const e = 1e3 * Pt();
      return {
        ...n,
        extra: {
          ...n.extra,
          "session:start": t,
          "session:duration": e - t,
          "session:end": e,
        },
      };
    },
  };
};
function tH(t) {
  return {
    ...t,
    path: "path" in t && Array.isArray(t.path) ? t.path.join(".") : void 0,
    keys: "keys" in t ? JSON.stringify(t.keys) : void 0,
    unionErrors: "unionErrors" in t ? JSON.stringify(t.unionErrors) : void 0,
  };
}
function nH(t) {
  const n = new Set();
  for (const e of t.issues) e.path && n.add(e.path[0]);
  return `Failed to validate keys: ${D(Array.from(n).join(", "), 100)}`;
}
function eH(t, n, e) {
  return n.exception &&
    n.exception.values &&
    e &&
    e.originalException &&
    P((r = e.originalException)) &&
    "ZodError" === r.name &&
    Array.isArray(r.errors) &&
    0 !== e.originalException.issues.length
    ? {
        ...n,
        exception: {
          ...n.exception,
          values: [
            { ...n.exception.values[0], value: nH(e.originalException) },
            ...n.exception.values.slice(1),
          ],
        },
        extra: {
          ...n.extra,
          "zoderror.issues": e.originalException.errors.slice(0, t).map(tH),
        },
      }
    : n;
  var r;
}
const rH = (t = {}) => {
    const n = t.limit || 10;
    return { name: "ZodErrors", processEvent: (t, e) => eH(n, t, e) };
  },
  oH = 1e4;
function iH(t, n) {
  const e = $("globalMetricsAggregators", () => new WeakMap()),
    r = e.get(t);
  if (r) return r;
  const o = new n(t);
  return (
    t.on("flush", () => o.flush()),
    t.on("close", () => o.close()),
    e.set(t, o),
    o
  );
}
function sH(t, n, e, r, o = {}) {
  const i = o.client || GU();
  if (!i) return;
  const s = vW(),
    u = s ? bW(s) : void 0,
    { unit: c, tags: a, timestamp: l } = o,
    { release: f, environment: d } = i.getOptions(),
    h = {};
  f && (h.release = f),
    d && (h.environment = d),
    u && (h.transaction = hW(u).description || "");
  iH(i, t).add(n, e, r, c, { ...h, ...a }, l);
}
const uH = {
  increment: function (t, n, e = 1, r) {
    sH(t, "c", n, e, r);
  },
  distribution: function (t, n, e, r) {
    sH(t, "d", n, e, r);
  },
  set: function (t, n, e, r) {
    sH(t, "s", n, e, r);
  },
  gauge: function (t, n, e, r) {
    sH(t, "g", n, e, r);
  },
  getMetricsAggregatorForClient: iH,
};
function cH(t) {
  return t.replace(/[^\w\-./]+/gi, "");
}
const aH = [
  ["\n", "\\n"],
  ["\r", "\\r"],
  ["\t", "\\t"],
  ["\\", "\\\\"],
  ["|", "\\u{7c}"],
  [",", "\\u{2c}"],
];
function lH(t) {
  return [...t].reduce(
    (t, n) =>
      t +
      (function (t) {
        for (const [n, e] of aH) if (t === n) return e;
        return t;
      })(n),
    ""
  );
}
function fH(t, n) {
  it.log(`Flushing aggregated metrics, number of metrics: ${n.length}`);
  const e = (function (t, n, e, r) {
    const o = { sent_at: new Date().toISOString() };
    e && e.sdk && (o.sdk = { name: e.sdk.name, version: e.sdk.version });
    r && n && (o.dsn = ut(n));
    const i = (function (t) {
      const n = (function (t) {
        let n = "";
        for (const e of t) {
          const t = Object.entries(e.tags),
            r =
              t.length > 0
                ? `|#${t.map(([t, n]) => `${t}:${n}`).join(",")}`
                : "";
          n += `${e.name}@${e.unit}:${e.metric}|${e.metricType}${r}|T${e.timestamp}\n`;
        }
        return n;
      })(t);
      return [{ type: "statsd", length: n.length }, n];
    })(t);
    return In(o, [i]);
  })(n, t.getDsn(), t.getSdkMetadata(), t.getOptions().tunnel);
  t.sendEnvelope(e);
}
const dH = {
  c: class {
    constructor(t) {
      this._ = t;
    }
    get weight() {
      return 1;
    }
    add(t) {
      this._ += t;
    }
    toString() {
      return `${this._}`;
    }
  },
  g: class {
    constructor(t) {
      (this.Ke = t), (this.Be = t), (this.Fe = t), (this.Je = t), (this.ze = 1);
    }
    get weight() {
      return 5;
    }
    add(t) {
      (this.Ke = t),
        t < this.Be && (this.Be = t),
        t > this.Fe && (this.Fe = t),
        (this.Je += t),
        this.ze++;
    }
    toString() {
      return `${this.Ke}:${this.Be}:${this.Fe}:${this.Je}:${this.ze}`;
    }
  },
  d: class {
    constructor(t) {
      this._ = [t];
    }
    get weight() {
      return this._.length;
    }
    add(t) {
      this._.push(t);
    }
    toString() {
      return this._.join(":");
    }
  },
  s: class {
    constructor(t) {
      (this.first = t), (this._ = new Set([t]));
    }
    get weight() {
      return this._.size;
    }
    add(t) {
      this._.add(t);
    }
    toString() {
      return Array.from(this._)
        .map((t) =>
          "string" == typeof t
            ? (function (t) {
                let n = 0;
                for (let e = 0; e < t.length; e++)
                  (n = (n << 5) - n + t.charCodeAt(e)), (n &= n);
                return n >>> 0;
              })(t)
            : t
        )
        .join(":");
    }
  },
};
class hH {
  constructor(t) {
    (this.oe = t),
      (this.Qe = new Map()),
      (this.$e = 0),
      (this.qe = setInterval(() => this.tr(), oH)),
      this.qe.unref && this.qe.unref(),
      (this.nr = Math.floor((Math.random() * oH) / 1e3)),
      (this.er = !1);
  }
  add(t, n, e, r = "none", o = {}, i = Pt()) {
    const s = Math.floor(i),
      u = n.replace(/[^\w\-.]+/gi, "_");
    const c = (function (t) {
        const n = {};
        for (const e in t)
          Object.prototype.hasOwnProperty.call(t, e) &&
            (n[cH(e)] = lH(String(t[e])));
        return n;
      })(o),
      a = (function (t) {
        return t.replace(/[^\w]+/gi, "_");
      })(r),
      l = (function (t, n, e, r) {
        return `${t}${n}${e}${Object.entries(Et(r)).sort((t, n) =>
          t[0].localeCompare(n[0])
        )}`;
      })(t, u, a, c);
    let f = this.Qe.get(l);
    const d = f && "s" === t ? f.metric.weight : 0;
    f
      ? (f.metric.add(e), f.timestamp < s && (f.timestamp = s))
      : ((f = {
          metric: new dH[t](e),
          timestamp: s,
          metricType: t,
          name: u,
          unit: a,
          tags: c,
        }),
        this.Qe.set(l, f));
    yW(t, u, "string" == typeof e ? f.metric.weight - d : e, a, o, l),
      (this.$e += f.metric.weight),
      this.$e >= 1e4 && this.flush();
  }
  flush() {
    (this.er = !0), this.tr();
  }
  close() {
    (this.er = !0), clearInterval(this.qe), this.tr();
  }
  tr() {
    if (this.er)
      return (
        (this.er = !1), (this.$e = 0), this.rr(this.Qe), void this.Qe.clear()
      );
    const t = Math.floor(Pt()) - 10 - this.nr,
      n = new Map();
    for (const [e, r] of this.Qe)
      r.timestamp <= t && (n.set(e, r), (this.$e -= r.metric.weight));
    for (const [t] of n) this.Qe.delete(t);
    this.rr(n);
  }
  rr(t) {
    if (t.size > 0) {
      const n = Array.from(t).map(([, t]) => t);
      fH(this.oe, n);
    }
  }
}
const pH = {
    increment: function (t, n = 1, e) {
      uH.increment(hH, t, n, e);
    },
    distribution: function (t, n, e) {
      uH.distribution(hH, t, n, e);
    },
    set: function (t, n, e) {
      uH.set(hH, t, n, e);
    },
    gauge: function (t, n, e) {
      uH.gauge(hH, t, n, e);
    },
    getMetricsAggregatorForClient: function (t) {
      return uH.getMetricsAggregatorForClient(t, hH);
    },
  },
  SH = { mechanism: { handled: !1, data: { function: "trpcMiddleware" } } };
const EH = function () {
  return {
    bindClient(t) {
      MU().setClient(t);
    },
    withScope: PU,
    getClient: () => GU(),
    getScope: MU,
    getIsolationScope: wU,
    captureException: (t, n) => MU().captureException(t, n),
    captureMessage: (t, n, e) => MU().captureMessage(t, n, e),
    captureEvent: eY,
    addBreadcrumb: PY,
    setUser: cY,
    setTags: sY,
    setTag: uY,
    setExtra: iY,
    setExtras: oY,
    setContext: rY,
    getIntegration(t) {
      const n = GU();
      return (n && n.getIntegrationByName(t.id)) || null;
    },
    startSession: hY,
    endSession: pY,
    captureSession(t) {
      if (t) return pY();
      !(function () {
        const t = MU(),
          n = GU(),
          e = t.getSession();
        n && e && n.captureSession(e);
      })();
    },
  };
};
var mH = ve("OpenTelemetry SDK Context Key SUPPRESS_TRACING");
function TH(t) {
  return t.setValue(mH, !0);
}
function _H(t) {
  return !0 === t.getValue(mH);
}
var bH = "baggage",
  vH = function (t, n) {
    var e = "function" == typeof Symbol && t[Symbol.iterator];
    if (!e) return t;
    var r,
      o,
      i = e.call(t),
      s = [];
    try {
      for (; (void 0 === n || n-- > 0) && !(r = i.next()).done; )
        s.push(r.value);
    } catch (t) {
      o = { error: t };
    } finally {
      try {
        r && !r.done && (e = i.return) && e.call(i);
      } finally {
        if (o) throw o.error;
      }
    }
    return s;
  };
var yH = (function () {
    function t() {}
    return (
      (t.prototype.inject = function (t, n, e) {
        var r = Fr.getBaggage(t);
        if (r && !_H(t)) {
          var o = (function (t) {
              return t.getAllEntries().map(function (t) {
                var n = vH(t, 2),
                  e = n[0],
                  r = n[1],
                  o = encodeURIComponent(e) + "=" + encodeURIComponent(r.value);
                return (
                  void 0 !== r.metadata && (o += ";" + r.metadata.toString()), o
                );
              });
            })(r)
              .filter(function (t) {
                return t.length <= 4096;
              })
              .slice(0, 180),
            i = (function (t) {
              return t.reduce(function (t, n) {
                var e = t + ("" !== t ? "," : "") + n;
                return e.length > 8192 ? t : e;
              }, "");
            })(o);
          i.length > 0 && e.set(n, bH, i);
        }
      }),
      (t.prototype.extract = function (t, n, e) {
        var r = e.get(n, bH),
          o = Array.isArray(r) ? r.join(",") : r;
        if (!o) return t;
        var i = {};
        return 0 === o.length
          ? t
          : (o.split(",").forEach(function (t) {
              var n = (function (t) {
                var n = t.split(";");
                if (!(n.length <= 0)) {
                  var e = n.shift();
                  if (e) {
                    var r = e.indexOf("=");
                    if (!(r <= 0)) {
                      var o,
                        i = decodeURIComponent(e.substring(0, r).trim()),
                        s = decodeURIComponent(e.substring(r + 1).trim());
                      return (
                        n.length > 0 && (o = be(n.join(";"))),
                        { key: i, value: s, metadata: o }
                      );
                    }
                  }
                }
              })(t);
              if (n) {
                var e = { value: n.value };
                n.metadata && (e.metadata = n.metadata), (i[n.key] = e);
              }
            }),
            0 === Object.entries(i).length
              ? t
              : Fr.setBaggage(t, Fr.createBaggage(i)));
      }),
      (t.prototype.fields = function () {
        return [bH];
      }),
      t
    );
  })(),
  RH = "[_0-9a-z-*/]",
  AH = new RegExp(
    "^(?:" +
      ("[a-z]" + RH + "{0,255}") +
      "|" +
      ("[a-z0-9]" + RH + "{0,240}@[a-z]" + RH + "{0,13}") +
      ")$"
  ),
  OH = /^[ -~]{0,255}[!-~]$/,
  gH = /,|=/;
var NH = (function () {
    function t(t) {
      (this.U = new Map()), t && this.W(t);
    }
    return (
      (t.prototype.set = function (t, n) {
        var e = this.Y();
        return e.U.has(t) && e.U.delete(t), e.U.set(t, n), e;
      }),
      (t.prototype.unset = function (t) {
        var n = this.Y();
        return n.U.delete(t), n;
      }),
      (t.prototype.get = function (t) {
        return this.U.get(t);
      }),
      (t.prototype.serialize = function () {
        var t = this;
        return this.H()
          .reduce(function (n, e) {
            return n.push(e + "=" + t.get(e)), n;
          }, [])
          .join(",");
      }),
      (t.prototype.W = function (t) {
        t.length > 512 ||
          ((this.U = t
            .split(",")
            .reverse()
            .reduce(function (t, n) {
              var e = n.trim(),
                r = e.indexOf("=");
              if (-1 !== r) {
                var o = e.slice(0, r),
                  i = e.slice(r + 1, n.length);
                (function (t) {
                  return AH.test(t);
                })(o) &&
                  (function (t) {
                    return OH.test(t) && !gH.test(t);
                  })(i) &&
                  t.set(o, i);
              }
              return t;
            }, new Map())),
          this.U.size > 32 &&
            (this.U = new Map(
              Array.from(this.U.entries()).reverse().slice(0, 32)
            )));
      }),
      (t.prototype.H = function () {
        return Array.from(this.U.keys()).reverse();
      }),
      (t.prototype.Y = function () {
        var n = new t();
        return (n.U = new Map(this.U)), n;
      }),
      t
    );
  })(),
  CH = ve("OpenTelemetry SDK Context Key SUPPRESS_TRACING");
function LH(t) {
  return t.setValue(CH, !0);
}
function IH(t) {
  return !0 === t.getValue(CH);
}
var MH = "=",
  wH = ";",
  ZH = ",",
  PH = "baggage",
  VH = function (t, n) {
    var e = "function" == typeof Symbol && t[Symbol.iterator];
    if (!e) return t;
    var r,
      o,
      i = e.call(t),
      s = [];
    try {
      for (; (void 0 === n || n-- > 0) && !(r = i.next()).done; )
        s.push(r.value);
    } catch (t) {
      o = { error: t };
    } finally {
      try {
        r && !r.done && (e = i.return) && e.call(i);
      } finally {
        if (o) throw o.error;
      }
    }
    return s;
  };
function GH(t) {
  return t.reduce(function (t, n) {
    var e = "" + t + ("" !== t ? ZH : "") + n;
    return e.length > 8192 ? t : e;
  }, "");
}
function XH(t) {
  return t.getAllEntries().map(function (t) {
    var n = VH(t, 2),
      e = n[0],
      r = n[1],
      o = encodeURIComponent(e) + "=" + encodeURIComponent(r.value);
    return void 0 !== r.metadata && (o += wH + r.metadata.toString()), o;
  });
}
function UH(t) {
  var n = t.split(wH);
  if (!(n.length <= 0)) {
    var e = n.shift();
    if (e) {
      var r = e.indexOf(MH);
      if (!(r <= 0)) {
        var o,
          i = decodeURIComponent(e.substring(0, r).trim()),
          s = decodeURIComponent(e.substring(r + 1).trim());
        return (
          n.length > 0 && (o = be(n.join(wH))),
          { key: i, value: s, metadata: o }
        );
      }
    }
  }
}
var WH = Object.freeze({
    __proto__: null,
    getKeyPairs: XH,
    parseKeyPairsIntoRecord: function (t) {
      return "string" != typeof t || 0 === t.length
        ? {}
        : t
            .split(ZH)
            .map(function (t) {
              return UH(t);
            })
            .filter(function (t) {
              return void 0 !== t && t.value.length > 0;
            })
            .reduce(function (t, n) {
              return (t[n.key] = n.value), t;
            }, {});
    },
    parsePairKeyValue: UH,
    serializeKeyPairs: GH,
  }),
  YH = (function () {
    function t() {}
    return (
      (t.prototype.inject = function (t, n, e) {
        var r = Fr.getBaggage(t);
        if (r && !IH(t)) {
          var o = GH(
            XH(r)
              .filter(function (t) {
                return t.length <= 4096;
              })
              .slice(0, 180)
          );
          o.length > 0 && e.set(n, PH, o);
        }
      }),
      (t.prototype.extract = function (t, n, e) {
        var r = e.get(n, PH),
          o = Array.isArray(r) ? r.join(ZH) : r;
        if (!o) return t;
        var i = {};
        return 0 === o.length
          ? t
          : (o.split(ZH).forEach(function (t) {
              var n = UH(t);
              if (n) {
                var e = { value: n.value };
                n.metadata && (e.metadata = n.metadata), (i[n.key] = e);
              }
            }),
            0 === Object.entries(i).length
              ? t
              : Fr.setBaggage(t, Fr.createBaggage(i)));
      }),
      (t.prototype.fields = function () {
        return [PH];
      }),
      t
    );
  })(),
  HH = (function () {
    function t(t, n) {
      (this.B = n), (this.F = t.now()), (this.J = n.now());
    }
    return (
      (t.prototype.now = function () {
        var t = this.B.now() - this.J;
        return this.F + t;
      }),
      t
    );
  })(),
  DH = function (t) {
    var n = "function" == typeof Symbol && Symbol.iterator,
      e = n && t[n],
      r = 0;
    if (e) return e.call(t);
    if (t && "number" == typeof t.length)
      return {
        next: function () {
          return (
            t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t }
          );
        },
      };
    throw new TypeError(
      n ? "Object is not iterable." : "Symbol.iterator is not defined."
    );
  },
  jH = function (t, n) {
    var e = "function" == typeof Symbol && t[Symbol.iterator];
    if (!e) return t;
    var r,
      o,
      i = e.call(t),
      s = [];
    try {
      for (; (void 0 === n || n-- > 0) && !(r = i.next()).done; )
        s.push(r.value);
    } catch (t) {
      o = { error: t };
    } finally {
      try {
        r && !r.done && (e = i.return) && e.call(i);
      } finally {
        if (o) throw o.error;
      }
    }
    return s;
  };
function xH(t) {
  var n,
    e,
    r = {};
  if ("object" != typeof t || null == t) return r;
  try {
    for (var o = DH(Object.entries(t)), i = o.next(); !i.done; i = o.next()) {
      var s = jH(i.value, 2),
        u = s[0],
        c = s[1];
      kH(u)
        ? KH(c)
          ? Array.isArray(c)
            ? (r[u] = c.slice())
            : (r[u] = c)
          : Pr.warn("Invalid attribute value set for key: " + u)
        : Pr.warn("Invalid attribute key: " + u);
    }
  } catch (t) {
    n = { error: t };
  } finally {
    try {
      i && !i.done && (e = o.return) && e.call(o);
    } finally {
      if (n) throw n.error;
    }
  }
  return r;
}
function kH(t) {
  return "string" == typeof t && t.length > 0;
}
function KH(t) {
  return (
    null == t ||
    (Array.isArray(t)
      ? (function (t) {
          var n, e, r;
          try {
            for (var o = DH(t), i = o.next(); !i.done; i = o.next()) {
              var s = i.value;
              if (null != s) {
                if (!r) {
                  if (BH(s)) {
                    r = typeof s;
                    continue;
                  }
                  return !1;
                }
                if (typeof s !== r) return !1;
              }
            }
          } catch (t) {
            n = { error: t };
          } finally {
            try {
              i && !i.done && (e = o.return) && e.call(o);
            } finally {
              if (n) throw n.error;
            }
          }
          return !0;
        })(t)
      : BH(t))
  );
}
function BH(t) {
  switch (typeof t) {
    case "number":
    case "boolean":
    case "string":
      return !0;
  }
  return !1;
}
function FH() {
  return function (t) {
    Pr.error(
      (function (t) {
        return "string" == typeof t
          ? t
          : JSON.stringify(
              (function (t) {
                var n = {},
                  e = t;
                for (; null !== e; )
                  Object.getOwnPropertyNames(e).forEach(function (t) {
                    if (!n[t]) {
                      var r = e[t];
                      r && (n[t] = String(r));
                    }
                  }),
                    (e = Object.getPrototypeOf(e));
                return n;
              })(t)
            );
      })(t)
    );
  };
}
var JH,
  zH = FH();
function QH(t) {
  try {
    zH(t);
  } catch (t) {}
}
!(function (t) {
  (t.AlwaysOff = "always_off"),
    (t.AlwaysOn = "always_on"),
    (t.ParentBasedAlwaysOff = "parentbased_always_off"),
    (t.ParentBasedAlwaysOn = "parentbased_always_on"),
    (t.ParentBasedTraceIdRatio = "parentbased_traceidratio"),
    (t.TraceIdRatio = "traceidratio");
})(JH || (JH = {}));
var $H =
    "object" == typeof globalThis
      ? globalThis
      : "object" == typeof self
        ? self
        : "object" == typeof window
          ? window
          : "object" == typeof global
            ? global
            : {},
  qH = ",",
  tD = ["OTEL_SDK_DISABLED"];
function nD(t) {
  return tD.indexOf(t) > -1;
}
var eD = [
  "OTEL_BSP_EXPORT_TIMEOUT",
  "OTEL_BSP_MAX_EXPORT_BATCH_SIZE",
  "OTEL_BSP_MAX_QUEUE_SIZE",
  "OTEL_BSP_SCHEDULE_DELAY",
  "OTEL_BLRP_EXPORT_TIMEOUT",
  "OTEL_BLRP_MAX_EXPORT_BATCH_SIZE",
  "OTEL_BLRP_MAX_QUEUE_SIZE",
  "OTEL_BLRP_SCHEDULE_DELAY",
  "OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT",
  "OTEL_ATTRIBUTE_COUNT_LIMIT",
  "OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT",
  "OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT",
  "OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT",
  "OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT",
  "OTEL_SPAN_EVENT_COUNT_LIMIT",
  "OTEL_SPAN_LINK_COUNT_LIMIT",
  "OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT",
  "OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT",
  "OTEL_EXPORTER_OTLP_TIMEOUT",
  "OTEL_EXPORTER_OTLP_TRACES_TIMEOUT",
  "OTEL_EXPORTER_OTLP_METRICS_TIMEOUT",
  "OTEL_EXPORTER_OTLP_LOGS_TIMEOUT",
  "OTEL_EXPORTER_JAEGER_AGENT_PORT",
];
function rD(t) {
  return eD.indexOf(t) > -1;
}
var oD = ["OTEL_NO_PATCH_MODULES", "OTEL_PROPAGATORS"];
function iD(t) {
  return oD.indexOf(t) > -1;
}
var sD = 1 / 0,
  uD = 128,
  cD = {
    OTEL_SDK_DISABLED: !1,
    CONTAINER_NAME: "",
    ECS_CONTAINER_METADATA_URI_V4: "",
    ECS_CONTAINER_METADATA_URI: "",
    HOSTNAME: "",
    KUBERNETES_SERVICE_HOST: "",
    NAMESPACE: "",
    OTEL_BSP_EXPORT_TIMEOUT: 3e4,
    OTEL_BSP_MAX_EXPORT_BATCH_SIZE: 512,
    OTEL_BSP_MAX_QUEUE_SIZE: 2048,
    OTEL_BSP_SCHEDULE_DELAY: 5e3,
    OTEL_BLRP_EXPORT_TIMEOUT: 3e4,
    OTEL_BLRP_MAX_EXPORT_BATCH_SIZE: 512,
    OTEL_BLRP_MAX_QUEUE_SIZE: 2048,
    OTEL_BLRP_SCHEDULE_DELAY: 5e3,
    OTEL_EXPORTER_JAEGER_AGENT_HOST: "",
    OTEL_EXPORTER_JAEGER_AGENT_PORT: 6832,
    OTEL_EXPORTER_JAEGER_ENDPOINT: "",
    OTEL_EXPORTER_JAEGER_PASSWORD: "",
    OTEL_EXPORTER_JAEGER_USER: "",
    OTEL_EXPORTER_OTLP_ENDPOINT: "",
    OTEL_EXPORTER_OTLP_TRACES_ENDPOINT: "",
    OTEL_EXPORTER_OTLP_METRICS_ENDPOINT: "",
    OTEL_EXPORTER_OTLP_LOGS_ENDPOINT: "",
    OTEL_EXPORTER_OTLP_HEADERS: "",
    OTEL_EXPORTER_OTLP_TRACES_HEADERS: "",
    OTEL_EXPORTER_OTLP_METRICS_HEADERS: "",
    OTEL_EXPORTER_OTLP_LOGS_HEADERS: "",
    OTEL_EXPORTER_OTLP_TIMEOUT: 1e4,
    OTEL_EXPORTER_OTLP_TRACES_TIMEOUT: 1e4,
    OTEL_EXPORTER_OTLP_METRICS_TIMEOUT: 1e4,
    OTEL_EXPORTER_OTLP_LOGS_TIMEOUT: 1e4,
    OTEL_EXPORTER_ZIPKIN_ENDPOINT: "http://localhost:9411/api/v2/spans",
    OTEL_LOG_LEVEL: se.INFO,
    OTEL_NO_PATCH_MODULES: [],
    OTEL_PROPAGATORS: ["tracecontext", "baggage"],
    OTEL_RESOURCE_ATTRIBUTES: "",
    OTEL_SERVICE_NAME: "",
    OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT: sD,
    OTEL_ATTRIBUTE_COUNT_LIMIT: uD,
    OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT: sD,
    OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT: uD,
    OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT: sD,
    OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT: uD,
    OTEL_SPAN_EVENT_COUNT_LIMIT: 128,
    OTEL_SPAN_LINK_COUNT_LIMIT: 128,
    OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT: 128,
    OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT: 128,
    OTEL_TRACES_EXPORTER: "",
    OTEL_TRACES_SAMPLER: JH.ParentBasedAlwaysOn,
    OTEL_TRACES_SAMPLER_ARG: "",
    OTEL_LOGS_EXPORTER: "",
    OTEL_EXPORTER_OTLP_INSECURE: "",
    OTEL_EXPORTER_OTLP_TRACES_INSECURE: "",
    OTEL_EXPORTER_OTLP_METRICS_INSECURE: "",
    OTEL_EXPORTER_OTLP_LOGS_INSECURE: "",
    OTEL_EXPORTER_OTLP_CERTIFICATE: "",
    OTEL_EXPORTER_OTLP_TRACES_CERTIFICATE: "",
    OTEL_EXPORTER_OTLP_METRICS_CERTIFICATE: "",
    OTEL_EXPORTER_OTLP_LOGS_CERTIFICATE: "",
    OTEL_EXPORTER_OTLP_COMPRESSION: "",
    OTEL_EXPORTER_OTLP_TRACES_COMPRESSION: "",
    OTEL_EXPORTER_OTLP_METRICS_COMPRESSION: "",
    OTEL_EXPORTER_OTLP_LOGS_COMPRESSION: "",
    OTEL_EXPORTER_OTLP_CLIENT_KEY: "",
    OTEL_EXPORTER_OTLP_TRACES_CLIENT_KEY: "",
    OTEL_EXPORTER_OTLP_METRICS_CLIENT_KEY: "",
    OTEL_EXPORTER_OTLP_LOGS_CLIENT_KEY: "",
    OTEL_EXPORTER_OTLP_CLIENT_CERTIFICATE: "",
    OTEL_EXPORTER_OTLP_TRACES_CLIENT_CERTIFICATE: "",
    OTEL_EXPORTER_OTLP_METRICS_CLIENT_CERTIFICATE: "",
    OTEL_EXPORTER_OTLP_LOGS_CLIENT_CERTIFICATE: "",
    OTEL_EXPORTER_OTLP_PROTOCOL: "http/protobuf",
    OTEL_EXPORTER_OTLP_TRACES_PROTOCOL: "http/protobuf",
    OTEL_EXPORTER_OTLP_METRICS_PROTOCOL: "http/protobuf",
    OTEL_EXPORTER_OTLP_LOGS_PROTOCOL: "http/protobuf",
    OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE: "cumulative",
  };
function aD(t, n, e) {
  if (void 0 !== e[t]) {
    var r = String(e[t]);
    n[t] = "true" === r.toLowerCase();
  }
}
function lD(t, n, e, r, o) {
  if (
    (void 0 === r && (r = -1 / 0), void 0 === o && (o = 1 / 0), void 0 !== e[t])
  ) {
    var i = Number(e[t]);
    isNaN(i) || (n[t] = i < r ? r : i > o ? o : i);
  }
}
function fD(t, n, e, r) {
  void 0 === r && (r = qH);
  var o = e[t];
  "string" == typeof o &&
    (n[t] = o.split(r).map(function (t) {
      return t.trim();
    }));
}
var dD = {
  ALL: se.ALL,
  VERBOSE: se.VERBOSE,
  DEBUG: se.DEBUG,
  INFO: se.INFO,
  WARN: se.WARN,
  ERROR: se.ERROR,
  NONE: se.NONE,
};
function hD(t, n, e) {
  var r = e[t];
  if ("string" == typeof r) {
    var o = dD[r.toUpperCase()];
    null != o && (n[t] = o);
  }
}
function pD(t) {
  var n = {};
  for (var e in cD) {
    var r = e;
    if ("OTEL_LOG_LEVEL" === r) hD(r, n, t);
    else if (nD(r)) aD(r, n, t);
    else if (rD(r)) lD(r, n, t);
    else if (iD(r)) fD(r, n, t);
    else {
      var o = t[r];
      null != o && (n[r] = String(o));
    }
  }
  return n;
}
function SD() {
  return "undefined" != typeof process && process && process.env
    ? pD(process.env)
    : pD($H);
}
function ED() {
  var t = pD(process.env);
  return Object.assign({}, cD, t);
}
var mD = "object" == typeof globalThis ? globalThis : global;
function TD(t) {
  return t >= 48 && t <= 57 ? t - 48 : t >= 97 && t <= 102 ? t - 87 : t - 55;
}
function _D(t) {
  for (
    var n = new Uint8Array(t.length / 2), e = 0, r = 0;
    r < t.length;
    r += 2
  ) {
    var o = TD(t.charCodeAt(r)),
      i = TD(t.charCodeAt(r + 1));
    n[e++] = (o << 4) | i;
  }
  return n;
}
var bD = function () {
    (this.generateTraceId = yD(16)), (this.generateSpanId = yD(8));
  },
  vD = Buffer.allocUnsafe(16);
function yD(t) {
  return function () {
    for (var n = 0; n < t / 4; n++)
      vD.writeUInt32BE((Math.random() * Math.pow(2, 32)) >>> 0, 4 * n);
    for (n = 0; n < t && !(vD[n] > 0); n++) n === t - 1 && (vD[t - 1] = 1);
    return vD.toString("hex", 0, t);
  };
}
var RD,
  AD = t.performance,
  OD = "1.23.0",
  gD =
    (((RD = {})[ZG.TELEMETRY_SDK_NAME] = "opentelemetry"),
    (RD[ZG.PROCESS_RUNTIME_NAME] = "node"),
    (RD[ZG.TELEMETRY_SDK_LANGUAGE] = mU.NODEJS),
    (RD[ZG.TELEMETRY_SDK_VERSION] = OD),
    RD);
function ND(t) {
  t.unref();
}
var CD,
  LD = Math.pow(10, 6),
  ID = Math.pow(10, 9);
function MD(t) {
  var n = t / 1e3;
  return [Math.trunc(n), Math.round((t % 1e3) * LD)];
}
function wD() {
  var t = AD.timeOrigin;
  if ("number" != typeof t) {
    var n = AD;
    t = n.timing && n.timing.fetchStart;
  }
  return t;
}
function ZD(t) {
  return UD(MD(wD()), MD("number" == typeof t ? t : AD.now()));
}
function PD(t, n) {
  var e = n[0] - t[0],
    r = n[1] - t[1];
  return r < 0 && ((e -= 1), (r += ID)), [e, r];
}
function VD(t) {
  return 1e6 * t[0] + t[1] / 1e3;
}
function GD(t) {
  return (
    Array.isArray(t) &&
    2 === t.length &&
    "number" == typeof t[0] &&
    "number" == typeof t[1]
  );
}
function XD(t) {
  return GD(t) || "number" == typeof t || t instanceof Date;
}
function UD(t, n) {
  var e = [t[0] + n[0], t[1] + n[1]];
  return e[1] >= ID && ((e[1] -= ID), (e[0] += 1)), e;
}
!(function (t) {
  (t[(t.SUCCESS = 0)] = "SUCCESS"), (t[(t.FAILED = 1)] = "FAILED");
})(CD || (CD = {}));
var WD = function (t) {
    var n = "function" == typeof Symbol && Symbol.iterator,
      e = n && t[n],
      r = 0;
    if (e) return e.call(t);
    if (t && "number" == typeof t.length)
      return {
        next: function () {
          return (
            t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t }
          );
        },
      };
    throw new TypeError(
      n ? "Object is not iterable." : "Symbol.iterator is not defined."
    );
  },
  YD = (function () {
    function t(t) {
      var n;
      void 0 === t && (t = {}),
        (this.tt = null !== (n = t.propagators) && void 0 !== n ? n : []),
        (this.nt = Array.from(
          new Set(
            this.tt
              .map(function (t) {
                return "function" == typeof t.fields ? t.fields() : [];
              })
              .reduce(function (t, n) {
                return t.concat(n);
              }, [])
          )
        ));
    }
    return (
      (t.prototype.inject = function (t, n, e) {
        var r, o;
        try {
          for (var i = WD(this.tt), s = i.next(); !s.done; s = i.next()) {
            var u = s.value;
            try {
              u.inject(t, n, e);
            } catch (t) {
              Pr.warn(
                "Failed to inject with " +
                  u.constructor.name +
                  ". Err: " +
                  t.message
              );
            }
          }
        } catch (t) {
          r = { error: t };
        } finally {
          try {
            s && !s.done && (o = i.return) && o.call(i);
          } finally {
            if (r) throw r.error;
          }
        }
      }),
      (t.prototype.extract = function (t, n, e) {
        return this.tt.reduce(function (t, r) {
          try {
            return r.extract(t, n, e);
          } catch (t) {
            Pr.warn(
              "Failed to inject with " +
                r.constructor.name +
                ". Err: " +
                t.message
            );
          }
          return t;
        }, t);
      }),
      (t.prototype.fields = function () {
        return this.nt.slice();
      }),
      t
    );
  })(),
  HD = "[_0-9a-z-*/]",
  DD = new RegExp(
    "^(?:" +
      ("[a-z]" + HD + "{0,255}") +
      "|" +
      ("[a-z0-9]" + HD + "{0,240}@[a-z]" + HD + "{0,13}") +
      ")$"
  ),
  jD = /^[ -~]{0,255}[!-~]$/,
  xD = /,|=/;
var kD = (function () {
    function t(t) {
      (this.U = new Map()), t && this.W(t);
    }
    return (
      (t.prototype.set = function (t, n) {
        var e = this.Y();
        return e.U.has(t) && e.U.delete(t), e.U.set(t, n), e;
      }),
      (t.prototype.unset = function (t) {
        var n = this.Y();
        return n.U.delete(t), n;
      }),
      (t.prototype.get = function (t) {
        return this.U.get(t);
      }),
      (t.prototype.serialize = function () {
        var t = this;
        return this.H()
          .reduce(function (n, e) {
            return n.push(e + "=" + t.get(e)), n;
          }, [])
          .join(",");
      }),
      (t.prototype.W = function (t) {
        t.length > 512 ||
          ((this.U = t
            .split(",")
            .reverse()
            .reduce(function (t, n) {
              var e = n.trim(),
                r = e.indexOf("=");
              if (-1 !== r) {
                var o = e.slice(0, r),
                  i = e.slice(r + 1, n.length);
                (function (t) {
                  return DD.test(t);
                })(o) &&
                  (function (t) {
                    return jD.test(t) && !xD.test(t);
                  })(i) &&
                  t.set(o, i);
              }
              return t;
            }, new Map())),
          this.U.size > 32 &&
            (this.U = new Map(
              Array.from(this.U.entries()).reverse().slice(0, 32)
            )));
      }),
      (t.prototype.H = function () {
        return Array.from(this.U.keys()).reverse();
      }),
      (t.prototype.Y = function () {
        var n = new t();
        return (n.U = new Map(this.U)), n;
      }),
      t
    );
  })(),
  KD = "traceparent",
  BD = "tracestate",
  FD = new RegExp(
    "^\\s?((?!ff)[\\da-f]{2})-((?![0]{32})[\\da-f]{32})-((?![0]{16})[\\da-f]{16})-([\\da-f]{2})(-.*)?\\s?$"
  );
function JD(t) {
  var n = FD.exec(t);
  return n
    ? "00" === n[1] && n[5]
      ? null
      : { traceId: n[2], spanId: n[3], traceFlags: parseInt(n[4], 16) }
    : null;
}
var zD,
  QD = (function () {
    function t() {}
    return (
      (t.prototype.inject = function (t, n, e) {
        var r = Qr.getSpanContext(t);
        if (r && !IH(t) && mr(r)) {
          var o =
            "00-" +
            r.traceId +
            "-" +
            r.spanId +
            "-0" +
            Number(r.traceFlags || ke.NONE).toString(16);
          e.set(n, KD, o),
            r.traceState && e.set(n, BD, r.traceState.serialize());
        }
      }),
      (t.prototype.extract = function (t, n, e) {
        var r = e.get(n, KD);
        if (!r) return t;
        var o = Array.isArray(r) ? r[0] : r;
        if ("string" != typeof o) return t;
        var i = JD(o);
        if (!i) return t;
        i.isRemote = !0;
        var s = e.get(n, BD);
        if (s) {
          var u = Array.isArray(s) ? s.join(",") : s;
          i.traceState = new kD("string" == typeof u ? u : void 0);
        }
        return Qr.setSpanContext(t, i);
      }),
      (t.prototype.fields = function () {
        return [KD, BD];
      }),
      t
    );
  })(),
  $D = ve("OpenTelemetry SDK Context Key RPC_METADATA");
!(function (t) {
  t.HTTP = "http";
})(zD || (zD = {}));
var qD = (function () {
    function t() {}
    return (
      (t.prototype.shouldSample = function () {
        return { decision: vr.NOT_RECORD };
      }),
      (t.prototype.toString = function () {
        return "AlwaysOffSampler";
      }),
      t
    );
  })(),
  tj = (function () {
    function t() {}
    return (
      (t.prototype.shouldSample = function () {
        return { decision: vr.RECORD_AND_SAMPLED };
      }),
      (t.prototype.toString = function () {
        return "AlwaysOnSampler";
      }),
      t
    );
  })(),
  nj = (function () {
    function t(t) {
      var n, e, r, o;
      (this.et = t.root),
        this.et ||
          (QH(
            new Error("ParentBasedSampler must have a root sampler configured")
          ),
          (this.et = new tj())),
        (this.rt =
          null !== (n = t.remoteParentSampled) && void 0 !== n ? n : new tj()),
        (this.ot =
          null !== (e = t.remoteParentNotSampled) && void 0 !== e
            ? e
            : new qD()),
        (this.it =
          null !== (r = t.localParentSampled) && void 0 !== r ? r : new tj()),
        (this.st =
          null !== (o = t.localParentNotSampled) && void 0 !== o
            ? o
            : new qD());
    }
    return (
      (t.prototype.shouldSample = function (t, n, e, r, o, i) {
        var s = Qr.getSpanContext(t);
        return s && mr(s)
          ? s.isRemote
            ? s.traceFlags & ke.SAMPLED
              ? this.rt.shouldSample(t, n, e, r, o, i)
              : this.ot.shouldSample(t, n, e, r, o, i)
            : s.traceFlags & ke.SAMPLED
              ? this.it.shouldSample(t, n, e, r, o, i)
              : this.st.shouldSample(t, n, e, r, o, i)
          : this.et.shouldSample(t, n, e, r, o, i);
      }),
      (t.prototype.toString = function () {
        return (
          "ParentBased{root=" +
          this.et.toString() +
          ", remoteParentSampled=" +
          this.rt.toString() +
          ", remoteParentNotSampled=" +
          this.ot.toString() +
          ", localParentSampled=" +
          this.it.toString() +
          ", localParentNotSampled=" +
          this.st.toString() +
          "}"
        );
      }),
      t
    );
  })(),
  ej = (function () {
    function t(t) {
      void 0 === t && (t = 0),
        (this.ut = t),
        (this.ut = this.ct(t)),
        (this.ft = Math.floor(4294967295 * this.ut));
    }
    return (
      (t.prototype.shouldSample = function (t, n) {
        return {
          decision:
            Sr(n) && this.dt(n) < this.ft
              ? vr.RECORD_AND_SAMPLED
              : vr.NOT_RECORD,
        };
      }),
      (t.prototype.toString = function () {
        return "TraceIdRatioBased{" + this.ut + "}";
      }),
      (t.prototype.ct = function (t) {
        return "number" != typeof t || isNaN(t)
          ? 0
          : t >= 1
            ? 1
            : t <= 0
              ? 0
              : t;
      }),
      (t.prototype.dt = function (t) {
        for (var n = 0, e = 0; e < t.length / 8; e++) {
          var r = 8 * e;
          n = (n ^ parseInt(t.slice(r, r + 8), 16)) >>> 0;
        }
        return n;
      }),
      t
    );
  })(),
  rj = "[object Object]",
  oj = "[object Null]",
  ij = "[object Undefined]",
  sj = Function.prototype.toString,
  uj = sj.call(Object),
  cj = (function (t, n) {
    return function (e) {
      return t(n(e));
    };
  })(Object.getPrototypeOf, Object),
  aj = Object.prototype,
  lj = aj.hasOwnProperty,
  fj = Symbol ? Symbol.toStringTag : void 0,
  dj = aj.toString;
function hj(t) {
  if (
    !(function (t) {
      return null != t && "object" == typeof t;
    })(t) ||
    (function (t) {
      if (null == t) return void 0 === t ? ij : oj;
      return fj && fj in Object(t)
        ? (function (t) {
            var n = lj.call(t, fj),
              e = t[fj],
              r = !1;
            try {
              (t[fj] = void 0), (r = !0);
            } catch (t) {}
            var o = dj.call(t);
            r && (n ? (t[fj] = e) : delete t[fj]);
            return o;
          })(t)
        : (function (t) {
            return dj.call(t);
          })(t);
    })(t) !== rj
  )
    return !1;
  var n = cj(t);
  if (null === n) return !0;
  var e = lj.call(n, "constructor") && n.constructor;
  return "function" == typeof e && e instanceof e && sj.call(e) === uj;
}
var pj = 20;
function Sj() {
  for (var t = [], n = 0; n < arguments.length; n++) t[n] = arguments[n];
  for (var e = t.shift(), r = new WeakMap(); t.length > 0; )
    e = mj(e, t.shift(), 0, r);
  return e;
}
function Ej(t) {
  return _j(t) ? t.slice() : t;
}
function mj(t, n, e, r) {
  var o;
  if ((void 0 === e && (e = 0), !(e > pj))) {
    if ((e++, yj(t) || yj(n) || bj(n))) o = Ej(n);
    else if (_j(t)) {
      if (((o = t.slice()), _j(n)))
        for (var i = 0, s = n.length; i < s; i++) o.push(Ej(n[i]));
      else if (vj(n))
        for (i = 0, s = (u = Object.keys(n)).length; i < s; i++) {
          o[(c = u[i])] = Ej(n[c]);
        }
    } else if (vj(t))
      if (vj(n)) {
        if (
          !(function (t, n) {
            if (!hj(t) || !hj(n)) return !1;
            return !0;
          })(t, n)
        )
          return n;
        o = Object.assign({}, t);
        var u;
        for (i = 0, s = (u = Object.keys(n)).length; i < s; i++) {
          var c,
            a = n[(c = u[i])];
          if (yj(a)) void 0 === a ? delete o[c] : (o[c] = a);
          else {
            var l = o[c],
              f = a;
            if (Tj(t, c, r) || Tj(n, c, r)) delete o[c];
            else {
              if (vj(l) && vj(f)) {
                var d = r.get(l) || [],
                  h = r.get(f) || [];
                d.push({ obj: t, key: c }),
                  h.push({ obj: n, key: c }),
                  r.set(l, d),
                  r.set(f, h);
              }
              o[c] = mj(o[c], a, e, r);
            }
          }
        }
      } else o = n;
    return o;
  }
}
function Tj(t, n, e) {
  for (var r = e.get(t[n]) || [], o = 0, i = r.length; o < i; o++) {
    var s = r[o];
    if (s.key === n && s.obj === t) return !0;
  }
  return !1;
}
function _j(t) {
  return Array.isArray(t);
}
function bj(t) {
  return "function" == typeof t;
}
function vj(t) {
  return !yj(t) && !_j(t) && !bj(t) && "object" == typeof t;
}
function yj(t) {
  return (
    "string" == typeof t ||
    "number" == typeof t ||
    "boolean" == typeof t ||
    void 0 === t ||
    t instanceof Date ||
    t instanceof RegExp ||
    null === t
  );
}
var Rj = (function () {
    var t = function (n, e) {
      return (
        (t =
          Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array &&
            function (t, n) {
              t.__proto__ = n;
            }) ||
          function (t, n) {
            for (var e in n)
              Object.prototype.hasOwnProperty.call(n, e) && (t[e] = n[e]);
          }),
        t(n, e)
      );
    };
    return function (n, e) {
      if ("function" != typeof e && null !== e)
        throw new TypeError(
          "Class extends value " + String(e) + " is not a constructor or null"
        );
      function r() {
        this.constructor = n;
      }
      t(n, e),
        (n.prototype =
          null === e
            ? Object.create(e)
            : ((r.prototype = e.prototype), new r()));
    };
  })(),
  Aj = (function (t) {
    function n(e) {
      var r = t.call(this, e) || this;
      return Object.setPrototypeOf(r, n.prototype), r;
    }
    return Rj(n, t), n;
  })(Error);
var Oj = function (t) {
  var n = "function" == typeof Symbol && Symbol.iterator,
    e = n && t[n],
    r = 0;
  if (e) return e.call(t);
  if (t && "number" == typeof t.length)
    return {
      next: function () {
        return (
          t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t }
        );
      },
    };
  throw new TypeError(
    n ? "Object is not iterable." : "Symbol.iterator is not defined."
  );
};
function gj(t, n) {
  return "string" == typeof n ? t === n : !!t.match(n);
}
var Nj = (function () {
    function t() {
      var t = this;
      this.ht = new Promise(function (n, e) {
        (t.p = n), (t.S = e);
      });
    }
    return (
      Object.defineProperty(t.prototype, "promise", {
        get: function () {
          return this.ht;
        },
        enumerable: !1,
        configurable: !0,
      }),
      (t.prototype.resolve = function (t) {
        this.p(t);
      }),
      (t.prototype.reject = function (t) {
        this.S(t);
      }),
      t
    );
  })(),
  Cj = function (t, n) {
    var e = "function" == typeof Symbol && t[Symbol.iterator];
    if (!e) return t;
    var r,
      o,
      i = e.call(t),
      s = [];
    try {
      for (; (void 0 === n || n-- > 0) && !(r = i.next()).done; )
        s.push(r.value);
    } catch (t) {
      o = { error: t };
    } finally {
      try {
        r && !r.done && (e = i.return) && e.call(i);
      } finally {
        if (o) throw o.error;
      }
    }
    return s;
  },
  Lj = function (t, n, e) {
    if (e || 2 === arguments.length)
      for (var r, o = 0, i = n.length; o < i; o++)
        (!r && o in n) ||
          (r || (r = Array.prototype.slice.call(n, 0, o)), (r[o] = n[o]));
    return t.concat(r || Array.prototype.slice.call(n));
  },
  Ij = (function () {
    function t(t, n) {
      (this.St = t), (this.Et = n), (this.Tt = !1), (this._t = new Nj());
    }
    return (
      Object.defineProperty(t.prototype, "isCalled", {
        get: function () {
          return this.Tt;
        },
        enumerable: !1,
        configurable: !0,
      }),
      Object.defineProperty(t.prototype, "promise", {
        get: function () {
          return this._t.promise;
        },
        enumerable: !1,
        configurable: !0,
      }),
      (t.prototype.call = function () {
        for (var t, n = this, e = [], r = 0; r < arguments.length; r++)
          e[r] = arguments[r];
        if (!this.Tt) {
          this.Tt = !0;
          try {
            Promise.resolve(
              (t = this.St).call.apply(t, Lj([this.Et], Cj(e), !1))
            ).then(
              function (t) {
                return n._t.resolve(t);
              },
              function (t) {
                return n._t.reject(t);
              }
            );
          } catch (t) {
            this._t.reject(t);
          }
        }
        return this._t.promise;
      }),
      t
    );
  })();
var Mj,
  wj = {
    bt: function (t, n) {
      return new Promise(function (e) {
        Zr.with(LH(Zr.active()), function () {
          t.export(n, function (t) {
            e(t);
          });
        });
      });
    },
  },
  Zj = Object.freeze({
    __proto__: null,
    AlwaysOffSampler: qD,
    AlwaysOnSampler: tj,
    AnchoredClock: HH,
    BindOnceFuture: Ij,
    CompositePropagator: YD,
    DEFAULT_ATTRIBUTE_COUNT_LIMIT: uD,
    DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT: sD,
    DEFAULT_ENVIRONMENT: cD,
    DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT: 128,
    DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT: 128,
    get ExportResultCode() {
      return CD;
    },
    ParentBasedSampler: nj,
    get RPCType() {
      return zD;
    },
    RandomIdGenerator: bD,
    SDK_INFO: gD,
    TRACE_PARENT_HEADER: KD,
    TRACE_STATE_HEADER: BD,
    TimeoutError: Aj,
    TraceIdRatioBasedSampler: ej,
    TraceState: kD,
    get TracesSamplerValues() {
      return JH;
    },
    VERSION: OD,
    W3CBaggagePropagator: YH,
    W3CTraceContextPropagator: QD,
    vt: mD,
    addHrTimes: UD,
    baggageUtils: WH,
    callWithTimeout: function (t, n) {
      var e,
        r = new Promise(function (t, r) {
          e = setTimeout(function () {
            r(new Aj("Operation timed out."));
          }, n);
        });
      return Promise.race([t, r]).then(
        function (t) {
          return clearTimeout(e), t;
        },
        function (t) {
          throw (clearTimeout(e), t);
        }
      );
    },
    deleteRPCMetadata: function (t) {
      return t.deleteValue($D);
    },
    getEnv: ED,
    getEnvWithoutDefaults: SD,
    getRPCMetadata: function (t) {
      return t.getValue($D);
    },
    getTimeOrigin: wD,
    globalErrorHandler: QH,
    hexToBase64: function (t) {
      return Buffer.from(_D(t)).toString("base64");
    },
    hexToBinary: _D,
    hrTime: ZD,
    hrTimeDuration: PD,
    hrTimeToMicroseconds: VD,
    hrTimeToMilliseconds: function (t) {
      return 1e3 * t[0] + t[1] / 1e6;
    },
    hrTimeToNanoseconds: function (t) {
      return t[0] * ID + t[1];
    },
    hrTimeToTimeStamp: function (t) {
      var n = "" + "0".repeat(9) + t[1] + "Z",
        e = n.substr(n.length - 9 - 1);
      return new Date(1e3 * t[0]).toISOString().replace("000Z", e);
    },
    internal: wj,
    isAttributeKey: kH,
    isAttributeValue: KH,
    isTimeInput: XD,
    isTimeInputHrTime: GD,
    isTracingSuppressed: IH,
    isUrlIgnored: function (t, n) {
      var e, r;
      if (!n) return !1;
      try {
        for (var o = Oj(n), i = o.next(); !i.done; i = o.next()) {
          if (gj(t, i.value)) return !0;
        }
      } catch (t) {
        e = { error: t };
      } finally {
        try {
          i && !i.done && (r = o.return) && r.call(o);
        } finally {
          if (e) throw e.error;
        }
      }
      return !1;
    },
    isWrapped: function (t) {
      return (
        "function" == typeof t &&
        "function" == typeof t.__original &&
        "function" == typeof t.__unwrap &&
        !0 === t.__wrapped
      );
    },
    loggingErrorHandler: FH,
    merge: Sj,
    millisToHrTime: MD,
    otperformance: AD,
    parseEnvironment: pD,
    parseTraceParent: JD,
    sanitizeAttributes: xH,
    setGlobalErrorHandler: function (t) {
      zH = t;
    },
    setRPCMetadata: function (t, n) {
      return t.setValue($D, n);
    },
    suppressTracing: LH,
    timeInputToHrTime: function (t) {
      if (GD(t)) return t;
      if ("number" == typeof t) return t < wD() ? ZD(t) : MD(t);
      if (t instanceof Date) return MD(t.getTime());
      throw TypeError("Invalid input type");
    },
    unrefTimer: ND,
    unsuppressTracing: function (t) {
      return t.deleteValue(CH);
    },
    urlMatches: gj,
  }),
  Pj = function (t) {
    var n = "function" == typeof Symbol && Symbol.iterator,
      e = n && t[n],
      r = 0;
    if (e) return e.call(t);
    if (t && "number" == typeof t.length)
      return {
        next: function () {
          return (
            t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t }
          );
        },
      };
    throw new TypeError(
      n ? "Object is not iterable." : "Symbol.iterator is not defined."
    );
  },
  Vj = function (t, n) {
    var e = "function" == typeof Symbol && t[Symbol.iterator];
    if (!e) return t;
    var r,
      o,
      i = e.call(t),
      s = [];
    try {
      for (; (void 0 === n || n-- > 0) && !(r = i.next()).done; )
        s.push(r.value);
    } catch (t) {
      o = { error: t };
    } finally {
      try {
        r && !r.done && (e = i.return) && e.call(i);
      } finally {
        if (o) throw o.error;
      }
    }
    return s;
  },
  Gj = (function () {
    function t(t, n, e, r, o, i, s, u, c, a) {
      void 0 === s && (s = []),
        (this.attributes = {}),
        (this.links = []),
        (this.events = []),
        (this.ir = 0),
        (this.sr = 0),
        (this.ur = 0),
        (this.status = { code: Rr.UNSET }),
        (this.endTime = [0, 0]),
        (this.cr = !1),
        (this.ar = [-1, -1]),
        (this.name = e),
        (this.P = r),
        (this.parentSpanId = i),
        (this.kind = o),
        (this.links = s);
      var l = Date.now();
      (this.lr = AD.now()),
        (this.dr = l - (this.lr + wD())),
        (this.hr = null != u),
        (this.startTime = this.pr(null != u ? u : l)),
        (this.resource = t.resource),
        (this.instrumentationLibrary = t.instrumentationLibrary),
        (this.Sr = t.getSpanLimits()),
        (this.Er = this.Sr.attributeValueLengthLimit || 0),
        null != a && this.setAttributes(a),
        (this.mr = t.getActiveSpanProcessor()),
        this.mr.onStart(this, n);
    }
    return (
      (t.prototype.spanContext = function () {
        return this.P;
      }),
      (t.prototype.setAttribute = function (t, n) {
        return null == n || this.Tr()
          ? this
          : 0 === t.length
            ? (Pr.warn("Invalid attribute key: " + t), this)
            : KH(n)
              ? Object.keys(this.attributes).length >=
                  this.Sr.attributeCountLimit &&
                !Object.prototype.hasOwnProperty.call(this.attributes, t)
                ? (this.ir++, this)
                : ((this.attributes[t] = this._r(n)), this)
              : (Pr.warn("Invalid attribute value set for key: " + t), this);
      }),
      (t.prototype.setAttributes = function (t) {
        var n, e;
        try {
          for (
            var r = Pj(Object.entries(t)), o = r.next();
            !o.done;
            o = r.next()
          ) {
            var i = Vj(o.value, 2),
              s = i[0],
              u = i[1];
            this.setAttribute(s, u);
          }
        } catch (t) {
          n = { error: t };
        } finally {
          try {
            o && !o.done && (e = r.return) && e.call(r);
          } finally {
            if (n) throw n.error;
          }
        }
        return this;
      }),
      (t.prototype.addEvent = function (t, n, e) {
        if (this.Tr()) return this;
        if (0 === this.Sr.eventCountLimit)
          return Pr.warn("No events allowed."), this.sr++, this;
        this.events.length >= this.Sr.eventCountLimit &&
          (0 === this.sr && Pr.debug("Dropping extra events."),
          this.events.shift(),
          this.sr++),
          XD(n) && (XD(e) || (e = n), (n = void 0));
        var r = xH(n);
        return (
          this.events.push({
            name: t,
            attributes: r,
            time: this.pr(e),
            droppedAttributesCount: 0,
          }),
          this
        );
      }),
      (t.prototype.setStatus = function (t) {
        return this.Tr() || (this.status = t), this;
      }),
      (t.prototype.updateName = function (t) {
        return this.Tr() || (this.name = t), this;
      }),
      (t.prototype.end = function (t) {
        this.Tr()
          ? Pr.error(
              this.name +
                " " +
                this.P.traceId +
                "-" +
                this.P.spanId +
                " - You can only call end() on a span once."
            )
          : ((this.cr = !0),
            (this.endTime = this.pr(t)),
            (this.ar = PD(this.startTime, this.endTime)),
            this.ar[0] < 0 &&
              (Pr.warn(
                "Inconsistent start and end time, startTime > endTime. Setting span duration to 0ms.",
                this.startTime,
                this.endTime
              ),
              (this.endTime = this.startTime.slice()),
              (this.ar = [0, 0])),
            this.sr > 0 &&
              Pr.warn(
                "Dropped " + this.sr + " events because eventCountLimit reached"
              ),
            this.mr.onEnd(this));
      }),
      (t.prototype.pr = function (t) {
        if ("number" == typeof t && t < AD.now()) return ZD(t + this.dr);
        if ("number" == typeof t) return MD(t);
        if (t instanceof Date) return MD(t.getTime());
        if (GD(t)) return t;
        if (this.hr) return MD(Date.now());
        var n = AD.now() - this.lr;
        return UD(this.startTime, MD(n));
      }),
      (t.prototype.isRecording = function () {
        return !1 === this.cr;
      }),
      (t.prototype.recordException = function (t, n) {
        var e = {};
        "string" == typeof t
          ? (e[WL.EXCEPTION_MESSAGE] = t)
          : t &&
            (t.code
              ? (e[WL.EXCEPTION_TYPE] = t.code.toString())
              : t.name && (e[WL.EXCEPTION_TYPE] = t.name),
            t.message && (e[WL.EXCEPTION_MESSAGE] = t.message),
            t.stack && (e[WL.EXCEPTION_STACKTRACE] = t.stack)),
          e[WL.EXCEPTION_TYPE] || e[WL.EXCEPTION_MESSAGE]
            ? this.addEvent("exception", e, n)
            : Pr.warn("Failed to record an exception " + t);
      }),
      Object.defineProperty(t.prototype, "duration", {
        get: function () {
          return this.ar;
        },
        enumerable: !1,
        configurable: !0,
      }),
      Object.defineProperty(t.prototype, "ended", {
        get: function () {
          return this.cr;
        },
        enumerable: !1,
        configurable: !0,
      }),
      Object.defineProperty(t.prototype, "droppedAttributesCount", {
        get: function () {
          return this.ir;
        },
        enumerable: !1,
        configurable: !0,
      }),
      Object.defineProperty(t.prototype, "droppedEventsCount", {
        get: function () {
          return this.sr;
        },
        enumerable: !1,
        configurable: !0,
      }),
      Object.defineProperty(t.prototype, "droppedLinksCount", {
        get: function () {
          return this.ur;
        },
        enumerable: !1,
        configurable: !0,
      }),
      (t.prototype.Tr = function () {
        return (
          this.cr &&
            Pr.warn(
              "Can not execute the operation on ended Span {traceId: " +
                this.P.traceId +
                ", spanId: " +
                this.P.spanId +
                "}"
            ),
          this.cr
        );
      }),
      (t.prototype.br = function (t, n) {
        return t.length <= n ? t : t.substr(0, n);
      }),
      (t.prototype._r = function (t) {
        var n = this,
          e = this.Er;
        return e <= 0
          ? (Pr.warn("Attribute value limit must be positive, got " + e), t)
          : "string" == typeof t
            ? this.br(t, e)
            : Array.isArray(t)
              ? t.map(function (t) {
                  return "string" == typeof t ? n.br(t, e) : t;
                })
              : t;
      }),
      t
    );
  })();
!(function (t) {
  (t[(t.NOT_RECORD = 0)] = "NOT_RECORD"),
    (t[(t.RECORD = 1)] = "RECORD"),
    (t[(t.RECORD_AND_SAMPLED = 2)] = "RECORD_AND_SAMPLED");
})(Mj || (Mj = {}));
var Xj = (function () {
    function t() {}
    return (
      (t.prototype.shouldSample = function () {
        return { decision: Mj.NOT_RECORD };
      }),
      (t.prototype.toString = function () {
        return "AlwaysOffSampler";
      }),
      t
    );
  })(),
  Uj = (function () {
    function t() {}
    return (
      (t.prototype.shouldSample = function () {
        return { decision: Mj.RECORD_AND_SAMPLED };
      }),
      (t.prototype.toString = function () {
        return "AlwaysOnSampler";
      }),
      t
    );
  })(),
  Wj = (function () {
    function t(t) {
      var n, e, r, o;
      (this.et = t.root),
        this.et ||
          (QH(
            new Error("ParentBasedSampler must have a root sampler configured")
          ),
          (this.et = new Uj())),
        (this.rt =
          null !== (n = t.remoteParentSampled) && void 0 !== n ? n : new Uj()),
        (this.ot =
          null !== (e = t.remoteParentNotSampled) && void 0 !== e
            ? e
            : new Xj()),
        (this.it =
          null !== (r = t.localParentSampled) && void 0 !== r ? r : new Uj()),
        (this.st =
          null !== (o = t.localParentNotSampled) && void 0 !== o
            ? o
            : new Xj());
    }
    return (
      (t.prototype.shouldSample = function (t, n, e, r, o, i) {
        var s = Qr.getSpanContext(t);
        return s && mr(s)
          ? s.isRemote
            ? s.traceFlags & ke.SAMPLED
              ? this.rt.shouldSample(t, n, e, r, o, i)
              : this.ot.shouldSample(t, n, e, r, o, i)
            : s.traceFlags & ke.SAMPLED
              ? this.it.shouldSample(t, n, e, r, o, i)
              : this.st.shouldSample(t, n, e, r, o, i)
          : this.et.shouldSample(t, n, e, r, o, i);
      }),
      (t.prototype.toString = function () {
        return (
          "ParentBased{root=" +
          this.et.toString() +
          ", remoteParentSampled=" +
          this.rt.toString() +
          ", remoteParentNotSampled=" +
          this.ot.toString() +
          ", localParentSampled=" +
          this.it.toString() +
          ", localParentNotSampled=" +
          this.st.toString() +
          "}"
        );
      }),
      t
    );
  })(),
  Yj = (function () {
    function t(t) {
      void 0 === t && (t = 0),
        (this.ut = t),
        (this.ut = this.ct(t)),
        (this.ft = Math.floor(4294967295 * this.ut));
    }
    return (
      (t.prototype.shouldSample = function (t, n) {
        return {
          decision:
            Sr(n) && this.dt(n) < this.ft
              ? Mj.RECORD_AND_SAMPLED
              : Mj.NOT_RECORD,
        };
      }),
      (t.prototype.toString = function () {
        return "TraceIdRatioBased{" + this.ut + "}";
      }),
      (t.prototype.ct = function (t) {
        return "number" != typeof t || isNaN(t)
          ? 0
          : t >= 1
            ? 1
            : t <= 0
              ? 0
              : t;
      }),
      (t.prototype.dt = function (t) {
        for (var n = 0, e = 0; e < t.length / 8; e++) {
          var r = 8 * e;
          n = (n ^ parseInt(t.slice(r, r + 8), 16)) >>> 0;
        }
        return n;
      }),
      t
    );
  })(),
  Hj = ED(),
  Dj = JH.AlwaysOn,
  jj = 1;
function xj() {
  return {
    sampler: kj(Hj),
    forceFlushTimeoutMillis: 3e4,
    generalLimits: {
      attributeValueLengthLimit: ED().OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      attributeCountLimit: ED().OTEL_ATTRIBUTE_COUNT_LIMIT,
    },
    spanLimits: {
      attributeValueLengthLimit: ED().OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      attributeCountLimit: ED().OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT,
      linkCountLimit: ED().OTEL_SPAN_LINK_COUNT_LIMIT,
      eventCountLimit: ED().OTEL_SPAN_EVENT_COUNT_LIMIT,
      attributePerEventCountLimit:
        ED().OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,
      attributePerLinkCountLimit: ED().OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT,
    },
  };
}
function kj(t) {
  switch ((void 0 === t && (t = ED()), t.OTEL_TRACES_SAMPLER)) {
    case JH.AlwaysOn:
      return new Uj();
    case JH.AlwaysOff:
      return new Xj();
    case JH.ParentBasedAlwaysOn:
      return new Wj({ root: new Uj() });
    case JH.ParentBasedAlwaysOff:
      return new Wj({ root: new Xj() });
    case JH.TraceIdRatio:
      return new Yj(Kj(t));
    case JH.ParentBasedTraceIdRatio:
      return new Wj({ root: new Yj(Kj(t)) });
    default:
      return (
        Pr.error(
          'OTEL_TRACES_SAMPLER value "' +
            t.OTEL_TRACES_SAMPLER +
            " invalid, defaulting to " +
            Dj +
            '".'
        ),
        new Uj()
      );
  }
}
function Kj(t) {
  if (void 0 === t.OTEL_TRACES_SAMPLER_ARG || "" === t.OTEL_TRACES_SAMPLER_ARG)
    return (
      Pr.error("OTEL_TRACES_SAMPLER_ARG is blank, defaulting to " + jj + "."),
      jj
    );
  var n = Number(t.OTEL_TRACES_SAMPLER_ARG);
  return isNaN(n)
    ? (Pr.error(
        "OTEL_TRACES_SAMPLER_ARG=" +
          t.OTEL_TRACES_SAMPLER_ARG +
          " was given, but it is invalid, defaulting to " +
          jj +
          "."
      ),
      jj)
    : n < 0 || n > 1
      ? (Pr.error(
          "OTEL_TRACES_SAMPLER_ARG=" +
            t.OTEL_TRACES_SAMPLER_ARG +
            " was given, but it is out of range ([0..1]), defaulting to " +
            jj +
            "."
        ),
        jj)
      : n;
}
var Bj = (function () {
    function t(t, n) {
      (this.vr = t), (this.yr = !1), (this.Rr = []), (this.Ar = 0);
      var e = ED();
      (this.Or =
        "number" == typeof (null == n ? void 0 : n.maxExportBatchSize)
          ? n.maxExportBatchSize
          : e.OTEL_BSP_MAX_EXPORT_BATCH_SIZE),
        (this.gr =
          "number" == typeof (null == n ? void 0 : n.maxQueueSize)
            ? n.maxQueueSize
            : e.OTEL_BSP_MAX_QUEUE_SIZE),
        (this.Nr =
          "number" == typeof (null == n ? void 0 : n.scheduledDelayMillis)
            ? n.scheduledDelayMillis
            : e.OTEL_BSP_SCHEDULE_DELAY),
        (this.Cr =
          "number" == typeof (null == n ? void 0 : n.exportTimeoutMillis)
            ? n.exportTimeoutMillis
            : e.OTEL_BSP_EXPORT_TIMEOUT),
        (this.Lr = new Ij(this.Ir, this)),
        this.Or > this.gr &&
          (Pr.warn(
            "BatchSpanProcessor: maxExportBatchSize must be smaller or equal to maxQueueSize, setting maxExportBatchSize to match maxQueueSize"
          ),
          (this.Or = this.gr));
    }
    return (
      (t.prototype.forceFlush = function () {
        return this.Lr.isCalled ? this.Lr.promise : this.Mr();
      }),
      (t.prototype.onStart = function (t, n) {}),
      (t.prototype.onEnd = function (t) {
        this.Lr.isCalled ||
          (t.spanContext().traceFlags & ke.SAMPLED && this.wr(t));
      }),
      (t.prototype.shutdown = function () {
        return this.Lr.call();
      }),
      (t.prototype.Ir = function () {
        var t = this;
        return Promise.resolve()
          .then(function () {
            return t.onShutdown();
          })
          .then(function () {
            return t.Mr();
          })
          .then(function () {
            return t.vr.shutdown();
          });
      }),
      (t.prototype.wr = function (t) {
        if (this.Rr.length >= this.gr)
          return (
            0 === this.Ar && Pr.debug("maxQueueSize reached, dropping spans"),
            void this.Ar++
          );
        this.Ar > 0 &&
          (Pr.warn(
            "Dropped " + this.Ar + " spans because maxQueueSize reached"
          ),
          (this.Ar = 0)),
          this.Rr.push(t),
          this.Zr();
      }),
      (t.prototype.Mr = function () {
        var t = this;
        return new Promise(function (n, e) {
          for (var r = [], o = 0, i = Math.ceil(t.Rr.length / t.Or); o < i; o++)
            r.push(t.Pr());
          Promise.all(r)
            .then(function () {
              n();
            })
            .catch(e);
        });
      }),
      (t.prototype.Pr = function () {
        var t = this;
        return (
          this.Vr(),
          0 === this.Rr.length
            ? Promise.resolve()
            : new Promise(function (n, e) {
                var r = setTimeout(function () {
                  e(new Error("Timeout"));
                }, t.Cr);
                Zr.with(LH(Zr.active()), function () {
                  var o;
                  t.Rr.length <= t.Or
                    ? ((o = t.Rr), (t.Rr = []))
                    : (o = t.Rr.splice(0, t.Or));
                  for (
                    var i = function () {
                        return t.vr.export(o, function (t) {
                          var o;
                          clearTimeout(r),
                            t.code === CD.SUCCESS
                              ? n()
                              : e(
                                  null !== (o = t.error) && void 0 !== o
                                    ? o
                                    : new Error(
                                        "BatchSpanProcessor: span export failed"
                                      )
                                );
                        });
                      },
                      s = null,
                      u = 0,
                      c = o.length;
                    u < c;
                    u++
                  ) {
                    var a = o[u];
                    a.resource.asyncAttributesPending &&
                      a.resource.waitForAsyncAttributes &&
                      (null != s || (s = []),
                      s.push(a.resource.waitForAsyncAttributes()));
                  }
                  null === s
                    ? i()
                    : Promise.all(s).then(i, function (t) {
                        QH(t), e(t);
                      });
                });
              })
        );
      }),
      (t.prototype.Zr = function () {
        var t = this;
        if (!this.yr) {
          var n = function () {
            (t.yr = !0),
              t
                .Pr()
                .finally(function () {
                  (t.yr = !1), t.Rr.length > 0 && (t.Vr(), t.Zr());
                })
                .catch(function (n) {
                  (t.yr = !1), QH(n);
                });
          };
          if (this.Rr.length >= this.Or) return n();
          void 0 === this.Gr &&
            ((this.Gr = setTimeout(function () {
              return n();
            }, this.Nr)),
            ND(this.Gr));
        }
      }),
      (t.prototype.Vr = function () {
        void 0 !== this.Gr && (clearTimeout(this.Gr), (this.Gr = void 0));
      }),
      t
    );
  })(),
  Fj = (function () {
    var t = function (n, e) {
      return (
        (t =
          Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array &&
            function (t, n) {
              t.__proto__ = n;
            }) ||
          function (t, n) {
            for (var e in n)
              Object.prototype.hasOwnProperty.call(n, e) && (t[e] = n[e]);
          }),
        t(n, e)
      );
    };
    return function (n, e) {
      if ("function" != typeof e && null !== e)
        throw new TypeError(
          "Class extends value " + String(e) + " is not a constructor or null"
        );
      function r() {
        this.constructor = n;
      }
      t(n, e),
        (n.prototype =
          null === e
            ? Object.create(e)
            : ((r.prototype = e.prototype), new r()));
    };
  })(),
  Jj = (function (t) {
    function n() {
      return (null !== t && t.apply(this, arguments)) || this;
    }
    return Fj(n, t), (n.prototype.onShutdown = function () {}), n;
  })(Bj),
  zj = function () {
    (this.generateTraceId = $j(16)), (this.generateSpanId = $j(8));
  },
  Qj = Buffer.allocUnsafe(16);
function $j(t) {
  return function () {
    for (var n = 0; n < t / 4; n++)
      Qj.writeUInt32BE((Math.random() * Math.pow(2, 32)) >>> 0, 4 * n);
    for (n = 0; n < t && !(Qj[n] > 0); n++) n === t - 1 && (Qj[t - 1] = 1);
    return Qj.toString("hex", 0, t);
  };
}
var qj = (function () {
  function t(t, n, e) {
    this.Xr = e;
    var r = (function (t) {
      var n = { sampler: kj() },
        e = xj(),
        r = Object.assign({}, e, n, t);
      return (
        (r.generalLimits = Object.assign(
          {},
          e.generalLimits,
          t.generalLimits || {}
        )),
        (r.spanLimits = Object.assign({}, e.spanLimits, t.spanLimits || {})),
        r
      );
    })(n);
    (this.Ur = r.sampler),
      (this.Wr = r.generalLimits),
      (this.Sr = r.spanLimits),
      (this.Yr = n.idGenerator || new zj()),
      (this.resource = e.resource),
      (this.instrumentationLibrary = t);
  }
  return (
    (t.prototype.startSpan = function (t, n, e) {
      var r, o, i;
      void 0 === n && (n = {}),
        void 0 === e && (e = Zr.active()),
        n.root && (e = Qr.deleteSpan(e));
      var s = Qr.getSpan(e);
      if (IH(e))
        return (
          Pr.debug("Instrumentation suppressed, returning Noop Span"),
          Qr.wrapSpanContext(or)
        );
      var u,
        c,
        a,
        l = null == s ? void 0 : s.spanContext(),
        f = this.Yr.generateSpanId();
      l && Qr.isSpanContextValid(l)
        ? ((u = l.traceId), (c = l.traceState), (a = l.spanId))
        : (u = this.Yr.generateTraceId());
      var d = null !== (r = n.kind) && void 0 !== r ? r : yr.INTERNAL,
        h = (null !== (o = n.links) && void 0 !== o ? o : []).map(function (t) {
          return { context: t.context, attributes: xH(t.attributes) };
        }),
        p = xH(n.attributes),
        S = this.Ur.shouldSample(e, u, t, d, p, h);
      c = null !== (i = S.traceState) && void 0 !== i ? i : c;
      var E = {
        traceId: u,
        spanId: f,
        traceFlags: S.decision === vr.RECORD_AND_SAMPLED ? ke.SAMPLED : ke.NONE,
        traceState: c,
      };
      if (S.decision === vr.NOT_RECORD)
        return (
          Pr.debug(
            "Recording is off, propagating context in a non-recording span"
          ),
          Qr.wrapSpanContext(E)
        );
      var m = xH(Object.assign(p, S.attributes));
      return new Gj(this, e, t, E, d, a, h, n.startTime, void 0, m);
    }),
    (t.prototype.startActiveSpan = function (t, n, e, r) {
      var o, i, s;
      if (!(arguments.length < 2)) {
        2 === arguments.length
          ? (s = n)
          : 3 === arguments.length
            ? ((o = n), (s = e))
            : ((o = n), (i = e), (s = r));
        var u = null != i ? i : Zr.active(),
          c = this.startSpan(t, o, u),
          a = Qr.setSpan(u, c);
        return Zr.with(a, s, void 0, c);
      }
    }),
    (t.prototype.getGeneralLimits = function () {
      return this.Wr;
    }),
    (t.prototype.getSpanLimits = function () {
      return this.Sr;
    }),
    (t.prototype.getActiveSpanProcessor = function () {
      return this.Xr.getActiveSpanProcessor();
    }),
    t
  );
})();
var tx,
  nx = function () {
    return (
      (nx =
        Object.assign ||
        function (t) {
          for (var n, e = 1, r = arguments.length; e < r; e++)
            for (var o in (n = arguments[e]))
              Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
          return t;
        }),
      nx.apply(this, arguments)
    );
  },
  ex = function (t, n, e, r) {
    return new (e || (e = Promise))(function (o, i) {
      function s(t) {
        try {
          c(r.next(t));
        } catch (t) {
          i(t);
        }
      }
      function u(t) {
        try {
          c(r.throw(t));
        } catch (t) {
          i(t);
        }
      }
      function c(t) {
        var n;
        t.done
          ? o(t.value)
          : ((n = t.value),
            n instanceof e
              ? n
              : new e(function (t) {
                  t(n);
                })).then(s, u);
      }
      c((r = r.apply(t, n || [])).next());
    });
  },
  rx = function (t, n) {
    var e,
      r,
      o,
      i,
      s = {
        label: 0,
        sent: function () {
          if (1 & o[0]) throw o[1];
          return o[1];
        },
        trys: [],
        ops: [],
      };
    return (
      (i = { next: u(0), throw: u(1), return: u(2) }),
      "function" == typeof Symbol &&
        (i[Symbol.iterator] = function () {
          return this;
        }),
      i
    );
    function u(i) {
      return function (u) {
        return (function (i) {
          if (e) throw new TypeError("Generator is already executing.");
          for (; s; )
            try {
              if (
                ((e = 1),
                r &&
                  (o =
                    2 & i[0]
                      ? r.return
                      : i[0]
                        ? r.throw || ((o = r.return) && o.call(r), 0)
                        : r.next) &&
                  !(o = o.call(r, i[1])).done)
              )
                return o;
              switch (((r = 0), o && (i = [2 & i[0], o.value]), i[0])) {
                case 0:
                case 1:
                  o = i;
                  break;
                case 4:
                  return s.label++, { value: i[1], done: !1 };
                case 5:
                  s.label++, (r = i[1]), (i = [0]);
                  continue;
                case 7:
                  (i = s.ops.pop()), s.trys.pop();
                  continue;
                default:
                  if (
                    !((o = s.trys),
                    (o = o.length > 0 && o[o.length - 1]) ||
                      (6 !== i[0] && 2 !== i[0]))
                  ) {
                    s = 0;
                    continue;
                  }
                  if (3 === i[0] && (!o || (i[1] > o[0] && i[1] < o[3]))) {
                    s.label = i[1];
                    break;
                  }
                  if (6 === i[0] && s.label < o[1]) {
                    (s.label = o[1]), (o = i);
                    break;
                  }
                  if (o && s.label < o[2]) {
                    (s.label = o[2]), s.ops.push(i);
                    break;
                  }
                  o[2] && s.ops.pop(), s.trys.pop();
                  continue;
              }
              i = n.call(t, s);
            } catch (t) {
              (i = [6, t]), (r = 0);
            } finally {
              e = o = 0;
            }
          if (5 & i[0]) throw i[1];
          return { value: i[0] ? i[1] : void 0, done: !0 };
        })([i, u]);
      };
    }
  },
  ox = function (t, n) {
    var e = "function" == typeof Symbol && t[Symbol.iterator];
    if (!e) return t;
    var r,
      o,
      i = e.call(t),
      s = [];
    try {
      for (; (void 0 === n || n-- > 0) && !(r = i.next()).done; )
        s.push(r.value);
    } catch (t) {
      o = { error: t };
    } finally {
      try {
        r && !r.done && (e = i.return) && e.call(i);
      } finally {
        if (o) throw o.error;
      }
    }
    return s;
  },
  ix = (function () {
    function t(t, n) {
      var e,
        r = this;
      (this.Se = t),
        (this.asyncAttributesPending = null != n),
        (this.Hr = null !== (e = this.Se) && void 0 !== e ? e : {}),
        (this.Dr =
          null == n
            ? void 0
            : n.then(
                function (t) {
                  return (
                    (r.Se = Object.assign({}, r.Se, t)),
                    (r.asyncAttributesPending = !1),
                    t
                  );
                },
                function (t) {
                  return (
                    Pr.debug(
                      "a resource's async attributes promise rejected: %s",
                      t
                    ),
                    (r.asyncAttributesPending = !1),
                    {}
                  );
                }
              ));
    }
    return (
      (t.empty = function () {
        return t.EMPTY;
      }),
      (t.default = function () {
        var n;
        return new t(
          (((n = {})[ZG.SERVICE_NAME] = "unknown_service:" + process.argv0),
          (n[ZG.TELEMETRY_SDK_LANGUAGE] = gD[ZG.TELEMETRY_SDK_LANGUAGE]),
          (n[ZG.TELEMETRY_SDK_NAME] = gD[ZG.TELEMETRY_SDK_NAME]),
          (n[ZG.TELEMETRY_SDK_VERSION] = gD[ZG.TELEMETRY_SDK_VERSION]),
          n)
        );
      }),
      Object.defineProperty(t.prototype, "attributes", {
        get: function () {
          var t;
          return (
            this.asyncAttributesPending &&
              Pr.error(
                "Accessing resource attributes before async attributes settled"
              ),
            null !== (t = this.Se) && void 0 !== t ? t : {}
          );
        },
        enumerable: !1,
        configurable: !0,
      }),
      (t.prototype.waitForAsyncAttributes = function () {
        return ex(this, void 0, void 0, function () {
          return rx(this, function (t) {
            switch (t.label) {
              case 0:
                return this.asyncAttributesPending ? [4, this.Dr] : [3, 2];
              case 1:
                t.sent(), (t.label = 2);
              case 2:
                return [2];
            }
          });
        });
      }),
      (t.prototype.merge = function (n) {
        var e,
          r = this;
        if (!n) return this;
        var o = nx(
          nx({}, this.Hr),
          null !== (e = n.Hr) && void 0 !== e ? e : n.attributes
        );
        if (!this.Dr && !n.Dr) return new t(o);
        var i = Promise.all([this.Dr, n.Dr]).then(function (t) {
          var e,
            o = ox(t, 2),
            i = o[0],
            s = o[1];
          return nx(
            nx(
              nx(nx({}, r.Hr), i),
              null !== (e = n.Hr) && void 0 !== e ? e : n.attributes
            ),
            s
          );
        });
        return new t(o, i);
      }),
      (t.EMPTY = new t({})),
      t
    );
  })(),
  sx = function (t) {
    var n = "function" == typeof Symbol && Symbol.iterator,
      e = n && t[n],
      r = 0;
    if (e) return e.call(t);
    if (t && "number" == typeof t.length)
      return {
        next: function () {
          return (
            t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t }
          );
        },
      };
    throw new TypeError(
      n ? "Object is not iterable." : "Symbol.iterator is not defined."
    );
  },
  ux = (function () {
    function t(t) {
      this.jr = t;
    }
    return (
      (t.prototype.forceFlush = function () {
        var t,
          n,
          e = [];
        try {
          for (var r = sx(this.jr), o = r.next(); !o.done; o = r.next()) {
            var i = o.value;
            e.push(i.forceFlush());
          }
        } catch (n) {
          t = { error: n };
        } finally {
          try {
            o && !o.done && (n = r.return) && n.call(r);
          } finally {
            if (t) throw t.error;
          }
        }
        return new Promise(function (t) {
          Promise.all(e)
            .then(function () {
              t();
            })
            .catch(function (n) {
              QH(n || new Error("MultiSpanProcessor: forceFlush failed")), t();
            });
        });
      }),
      (t.prototype.onStart = function (t, n) {
        var e, r;
        try {
          for (var o = sx(this.jr), i = o.next(); !i.done; i = o.next()) {
            i.value.onStart(t, n);
          }
        } catch (t) {
          e = { error: t };
        } finally {
          try {
            i && !i.done && (r = o.return) && r.call(o);
          } finally {
            if (e) throw e.error;
          }
        }
      }),
      (t.prototype.onEnd = function (t) {
        var n, e;
        try {
          for (var r = sx(this.jr), o = r.next(); !o.done; o = r.next()) {
            o.value.onEnd(t);
          }
        } catch (t) {
          n = { error: t };
        } finally {
          try {
            o && !o.done && (e = r.return) && e.call(r);
          } finally {
            if (n) throw n.error;
          }
        }
      }),
      (t.prototype.shutdown = function () {
        var t,
          n,
          e = [];
        try {
          for (var r = sx(this.jr), o = r.next(); !o.done; o = r.next()) {
            var i = o.value;
            e.push(i.shutdown());
          }
        } catch (n) {
          t = { error: n };
        } finally {
          try {
            o && !o.done && (n = r.return) && n.call(r);
          } finally {
            if (t) throw t.error;
          }
        }
        return new Promise(function (t, n) {
          Promise.all(e).then(function () {
            t();
          }, n);
        });
      }),
      t
    );
  })(),
  cx = (function () {
    function t() {}
    return (
      (t.prototype.onStart = function (t, n) {}),
      (t.prototype.onEnd = function (t) {}),
      (t.prototype.shutdown = function () {
        return Promise.resolve();
      }),
      (t.prototype.forceFlush = function () {
        return Promise.resolve();
      }),
      t
    );
  })();
!(function (t) {
  (t[(t.resolved = 0)] = "resolved"),
    (t[(t.timeout = 1)] = "timeout"),
    (t[(t.error = 2)] = "error"),
    (t[(t.unresolved = 3)] = "unresolved");
})(tx || (tx = {}));
var ax = (function () {
    function t(t) {
      var n;
      void 0 === t && (t = {}), (this.kr = []), (this.Kr = new Map());
      var e = Sj(
        {},
        xj(),
        (function (t) {
          var n,
            e,
            r,
            o,
            i,
            s,
            u,
            c,
            a,
            l,
            f,
            d,
            h = Object.assign({}, t.spanLimits),
            p = SD();
          return (
            (h.attributeCountLimit =
              null !==
                (s =
                  null !==
                    (i =
                      null !==
                        (o =
                          null !==
                            (e =
                              null === (n = t.spanLimits) || void 0 === n
                                ? void 0
                                : n.attributeCountLimit) && void 0 !== e
                            ? e
                            : null === (r = t.generalLimits) || void 0 === r
                              ? void 0
                              : r.attributeCountLimit) && void 0 !== o
                        ? o
                        : p.OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT) && void 0 !== i
                    ? i
                    : p.OTEL_ATTRIBUTE_COUNT_LIMIT) && void 0 !== s
                ? s
                : uD),
            (h.attributeValueLengthLimit =
              null !==
                (d =
                  null !==
                    (f =
                      null !==
                        (l =
                          null !==
                            (c =
                              null === (u = t.spanLimits) || void 0 === u
                                ? void 0
                                : u.attributeValueLengthLimit) && void 0 !== c
                            ? c
                            : null === (a = t.generalLimits) || void 0 === a
                              ? void 0
                              : a.attributeValueLengthLimit) && void 0 !== l
                        ? l
                        : p.OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT) &&
                  void 0 !== f
                    ? f
                    : p.OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT) && void 0 !== d
                ? d
                : sD),
            Object.assign({}, t, { spanLimits: h })
          );
        })(t)
      );
      (this.resource =
        null !== (n = e.resource) && void 0 !== n ? n : ix.empty()),
        (this.resource = ix.default().merge(this.resource)),
        (this.Nt = Object.assign({}, e, { resource: this.resource }));
      var r = this.Br();
      if (void 0 !== r) {
        var o = new Jj(r);
        this.activeSpanProcessor = o;
      } else this.activeSpanProcessor = new cx();
    }
    return (
      (t.prototype.getTracer = function (t, n, e) {
        var r =
          t +
          "@" +
          (n || "") +
          ":" +
          ((null == e ? void 0 : e.schemaUrl) || "");
        return (
          this.Kr.has(r) ||
            this.Kr.set(
              r,
              new qj(
                {
                  name: t,
                  version: n,
                  schemaUrl: null == e ? void 0 : e.schemaUrl,
                },
                this.Nt,
                this
              )
            ),
          this.Kr.get(r)
        );
      }),
      (t.prototype.addSpanProcessor = function (t) {
        0 === this.kr.length &&
          this.activeSpanProcessor.shutdown().catch(function (t) {
            return Pr.error(
              "Error while trying to shutdown current span processor",
              t
            );
          }),
          this.kr.push(t),
          (this.activeSpanProcessor = new ux(this.kr));
      }),
      (t.prototype.getActiveSpanProcessor = function () {
        return this.activeSpanProcessor;
      }),
      (t.prototype.register = function (t) {
        void 0 === t && (t = {}),
          Qr.setGlobalTracerProvider(this),
          void 0 === t.propagator && (t.propagator = this.Fr()),
          t.contextManager && Zr.setGlobalContextManager(t.contextManager),
          t.propagator && Fr.setGlobalPropagator(t.propagator);
      }),
      (t.prototype.forceFlush = function () {
        var t = this.Nt.forceFlushTimeoutMillis,
          n = this.kr.map(function (n) {
            return new Promise(function (e) {
              var r,
                o = setTimeout(function () {
                  e(
                    new Error(
                      "Span processor did not completed within timeout period of " +
                        t +
                        " ms"
                    )
                  ),
                    (r = tx.timeout);
                }, t);
              n.forceFlush()
                .then(function () {
                  clearTimeout(o),
                    r !== tx.timeout && ((r = tx.resolved), e(r));
                })
                .catch(function (t) {
                  clearTimeout(o), (r = tx.error), e(t);
                });
            });
          });
        return new Promise(function (t, e) {
          Promise.all(n)
            .then(function (n) {
              var r = n.filter(function (t) {
                return t !== tx.resolved;
              });
              r.length > 0 ? e(r) : t();
            })
            .catch(function (t) {
              return e([t]);
            });
        });
      }),
      (t.prototype.shutdown = function () {
        return this.activeSpanProcessor.shutdown();
      }),
      (t.prototype.Jr = function (t) {
        var n;
        return null === (n = this.constructor.zr.get(t)) || void 0 === n
          ? void 0
          : n();
      }),
      (t.prototype.Qr = function (t) {
        var n;
        return null === (n = this.constructor.$r.get(t)) || void 0 === n
          ? void 0
          : n();
      }),
      (t.prototype.Fr = function () {
        var t = this,
          n = Array.from(new Set(ED().OTEL_PROPAGATORS)),
          e = n.map(function (n) {
            var e = t.Jr(n);
            return (
              e ||
                Pr.warn(
                  'Propagator "' +
                    n +
                    '" requested through environment variable is unavailable.'
                ),
              e
            );
          }),
          r = e.reduce(function (t, n) {
            return n && t.push(n), t;
          }, []);
        return 0 === r.length
          ? void 0
          : 1 === n.length
            ? r[0]
            : new YD({ propagators: r });
      }),
      (t.prototype.Br = function () {
        var t = ED().OTEL_TRACES_EXPORTER;
        if ("none" !== t && "" !== t) {
          var n = this.Qr(t);
          return (
            n ||
              Pr.error(
                'Exporter "' +
                  t +
                  '" requested through environment variable is unavailable.'
              ),
            n
          );
        }
      }),
      (t.zr = new Map([
        [
          "tracecontext",
          function () {
            return new QD();
          },
        ],
        [
          "baggage",
          function () {
            return new YH();
          },
        ],
      ])),
      (t.$r = new Map()),
      t
    );
  })(),
  lx = function (t) {
    var n = "function" == typeof Symbol && Symbol.iterator,
      e = n && t[n],
      r = 0;
    if (e) return e.call(t);
    if (t && "number" == typeof t.length)
      return {
        next: function () {
          return (
            t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t }
          );
        },
      };
    throw new TypeError(
      n ? "Object is not iterable." : "Symbol.iterator is not defined."
    );
  },
  fx = (function () {
    function t() {}
    return (
      (t.prototype.export = function (t, n) {
        return this.qr(t, n);
      }),
      (t.prototype.shutdown = function () {
        return this.qr([]), this.forceFlush();
      }),
      (t.prototype.forceFlush = function () {
        return Promise.resolve();
      }),
      (t.prototype.no = function (t) {
        var n;
        return {
          traceId: t.spanContext().traceId,
          parentId: t.parentSpanId,
          traceState:
            null === (n = t.spanContext().traceState) || void 0 === n
              ? void 0
              : n.serialize(),
          name: t.name,
          id: t.spanContext().spanId,
          kind: t.kind,
          timestamp: VD(t.startTime),
          duration: VD(t.duration),
          attributes: t.attributes,
          status: t.status,
          events: t.events,
          links: t.links,
        };
      }),
      (t.prototype.qr = function (t, n) {
        var e, r;
        try {
          for (var o = lx(t), i = o.next(); !i.done; i = o.next()) {
            var s = i.value;
            console.dir(this.no(s), { depth: 3 });
          }
        } catch (t) {
          e = { error: t };
        } finally {
          try {
            i && !i.done && (r = o.return) && r.call(o);
          } finally {
            if (e) throw e.error;
          }
        }
        if (n) return n({ code: CD.SUCCESS });
      }),
      t
    );
  })(),
  dx = function (t, n) {
    var e = "function" == typeof Symbol && t[Symbol.iterator];
    if (!e) return t;
    var r,
      o,
      i = e.call(t),
      s = [];
    try {
      for (; (void 0 === n || n-- > 0) && !(r = i.next()).done; )
        s.push(r.value);
    } catch (t) {
      o = { error: t };
    } finally {
      try {
        r && !r.done && (e = i.return) && e.call(i);
      } finally {
        if (o) throw o.error;
      }
    }
    return s;
  },
  hx = function (t, n, e) {
    if (e || 2 === arguments.length)
      for (var r, o = 0, i = n.length; o < i; o++)
        (!r && o in n) ||
          (r || (r = Array.prototype.slice.call(n, 0, o)), (r[o] = n[o]));
    return t.concat(r || Array.prototype.slice.call(n));
  },
  px = (function () {
    function t() {
      (this.Rr = []), (this.eo = !1);
    }
    return (
      (t.prototype.export = function (t, n) {
        var e;
        if (this.eo)
          return n({
            code: CD.FAILED,
            error: new Error("Exporter has been stopped"),
          });
        (e = this.Rr).push.apply(e, hx([], dx(t), !1)),
          setTimeout(function () {
            return n({ code: CD.SUCCESS });
          }, 0);
      }),
      (t.prototype.shutdown = function () {
        return (this.eo = !0), (this.Rr = []), this.forceFlush();
      }),
      (t.prototype.forceFlush = function () {
        return Promise.resolve();
      }),
      (t.prototype.reset = function () {
        this.Rr = [];
      }),
      (t.prototype.getFinishedSpans = function () {
        return this.Rr;
      }),
      t
    );
  })(),
  Sx = function (t, n, e, r) {
    return new (e || (e = Promise))(function (o, i) {
      function s(t) {
        try {
          c(r.next(t));
        } catch (t) {
          i(t);
        }
      }
      function u(t) {
        try {
          c(r.throw(t));
        } catch (t) {
          i(t);
        }
      }
      function c(t) {
        var n;
        t.done
          ? o(t.value)
          : ((n = t.value),
            n instanceof e
              ? n
              : new e(function (t) {
                  t(n);
                })).then(s, u);
      }
      c((r = r.apply(t, n || [])).next());
    });
  },
  Ex = function (t, n) {
    var e,
      r,
      o,
      i,
      s = {
        label: 0,
        sent: function () {
          if (1 & o[0]) throw o[1];
          return o[1];
        },
        trys: [],
        ops: [],
      };
    return (
      (i = { next: u(0), throw: u(1), return: u(2) }),
      "function" == typeof Symbol &&
        (i[Symbol.iterator] = function () {
          return this;
        }),
      i
    );
    function u(i) {
      return function (u) {
        return (function (i) {
          if (e) throw new TypeError("Generator is already executing.");
          for (; s; )
            try {
              if (
                ((e = 1),
                r &&
                  (o =
                    2 & i[0]
                      ? r.return
                      : i[0]
                        ? r.throw || ((o = r.return) && o.call(r), 0)
                        : r.next) &&
                  !(o = o.call(r, i[1])).done)
              )
                return o;
              switch (((r = 0), o && (i = [2 & i[0], o.value]), i[0])) {
                case 0:
                case 1:
                  o = i;
                  break;
                case 4:
                  return s.label++, { value: i[1], done: !1 };
                case 5:
                  s.label++, (r = i[1]), (i = [0]);
                  continue;
                case 7:
                  (i = s.ops.pop()), s.trys.pop();
                  continue;
                default:
                  if (
                    !((o = s.trys),
                    (o = o.length > 0 && o[o.length - 1]) ||
                      (6 !== i[0] && 2 !== i[0]))
                  ) {
                    s = 0;
                    continue;
                  }
                  if (3 === i[0] && (!o || (i[1] > o[0] && i[1] < o[3]))) {
                    s.label = i[1];
                    break;
                  }
                  if (6 === i[0] && s.label < o[1]) {
                    (s.label = o[1]), (o = i);
                    break;
                  }
                  if (o && s.label < o[2]) {
                    (s.label = o[2]), s.ops.push(i);
                    break;
                  }
                  o[2] && s.ops.pop(), s.trys.pop();
                  continue;
              }
              i = n.call(t, s);
            } catch (t) {
              (i = [6, t]), (r = 0);
            } finally {
              e = o = 0;
            }
          if (5 & i[0]) throw i[1];
          return { value: i[0] ? i[1] : void 0, done: !0 };
        })([i, u]);
      };
    }
  },
  mx = (function () {
    function t(t) {
      (this.vr = t), (this.Lr = new Ij(this.Ir, this)), (this.ro = new Set());
    }
    return (
      (t.prototype.forceFlush = function () {
        return Sx(this, void 0, void 0, function () {
          return Ex(this, function (t) {
            switch (t.label) {
              case 0:
                return [4, Promise.all(Array.from(this.ro))];
              case 1:
                return (
                  t.sent(),
                  this.vr.forceFlush ? [4, this.vr.forceFlush()] : [3, 3]
                );
              case 2:
                t.sent(), (t.label = 3);
              case 3:
                return [2];
            }
          });
        });
      }),
      (t.prototype.onStart = function (t, n) {}),
      (t.prototype.onEnd = function (t) {
        var n,
          e,
          r = this;
        if (!this.Lr.isCalled && t.spanContext().traceFlags & ke.SAMPLED) {
          var o = function () {
            return wj
              .bt(r.vr, [t])
              .then(function (t) {
                var n;
                t.code !== CD.SUCCESS &&
                  QH(
                    null !== (n = t.error) && void 0 !== n
                      ? n
                      : new Error(
                          "SimpleSpanProcessor: span export failed (status " +
                            t +
                            ")"
                        )
                  );
              })
              .catch(function (t) {
                QH(t);
              });
          };
          if (t.resource.asyncAttributesPending) {
            var i =
              null === (e = (n = t.resource).waitForAsyncAttributes) ||
              void 0 === e
                ? void 0
                : e.call(n).then(
                    function () {
                      return null != i && r.ro.delete(i), o();
                    },
                    function (t) {
                      return QH(t);
                    }
                  );
            null != i && this.ro.add(i);
          } else o();
        }
      }),
      (t.prototype.shutdown = function () {
        return this.Lr.call();
      }),
      (t.prototype.Ir = function () {
        return this.vr.shutdown();
      }),
      t
    );
  })(),
  Tx = Object.freeze({
    __proto__: null,
    AlwaysOffSampler: Xj,
    AlwaysOnSampler: Uj,
    BasicTracerProvider: ax,
    BatchSpanProcessor: Jj,
    ConsoleSpanExporter: fx,
    get ForceFlushState() {
      return tx;
    },
    InMemorySpanExporter: px,
    NoopSpanProcessor: cx,
    ParentBasedSampler: Wj,
    RandomIdGenerator: zj,
    get SamplingDecision() {
      return Mj;
    },
    SimpleSpanProcessor: mx,
    Span: Gj,
    TraceIdRatioBasedSampler: Yj,
    Tracer: qj,
  }),
  _x = (function () {
    function t() {}
    return (t.prototype.emit = function (t) {}), t;
  })(),
  bx = (function () {
    function t() {}
    return (
      (t.prototype.getLogger = function (t, n, e) {
        return new _x();
      }),
      t
    );
  })(),
  vx = new bx(),
  yx = "object" == typeof globalThis ? globalThis : global,
  Rx = Symbol.for("io.opentelemetry.js.api.logs"),
  Ax = yx;
var Ox = (function () {
    function t() {}
    return (
      (t.getInstance = function () {
        return this.L || (this.L = new t()), this.L;
      }),
      (t.prototype.setGlobalLoggerProvider = function (t) {
        return Ax[Rx]
          ? this.getLoggerProvider()
          : ((Ax[Rx] =
              ((n = 1),
              (e = t),
              (r = vx),
              function (t) {
                return t === n ? e : r;
              })),
            t);
        var n, e, r;
      }),
      (t.prototype.getLoggerProvider = function () {
        var t, n;
        return null !==
          (n =
            null === (t = Ax[Rx]) || void 0 === t ? void 0 : t.call(Ax, 1)) &&
          void 0 !== n
          ? n
          : vx;
      }),
      (t.prototype.getLogger = function (t, n, e) {
        return this.getLoggerProvider().getLogger(t, n, e);
      }),
      (t.prototype.disable = function () {
        delete Ax[Rx];
      }),
      t
    );
  })(),
  gx = Ox.getInstance();
function Nx(t) {
  void 0 === t && (t = []);
  for (var n = [], e = 0, r = t.length; e < r; e++) {
    var o = t[e];
    if (Array.isArray(o)) {
      var i = Nx(o);
      n = n.concat(i.instrumentations);
    } else
      "function" == typeof o
        ? n.push(new o())
        : o.instrumentationName && n.push(o);
  }
  return { instrumentations: n };
}
function Cx(t) {
  var n = Nx(t.instrumentations).instrumentations,
    e = t.tracerProvider || Qr.getTracerProvider(),
    r = t.meterProvider || Ur.getMeterProvider(),
    o = t.loggerProvider || gx.getLoggerProvider();
  return (
    (function (t, n, e, r) {
      for (var o = 0, i = t.length; o < i; o++) {
        var s = t[o];
        n && s.setTracerProvider(n),
          e && s.setMeterProvider(e),
          r && s.setLoggerProvider && s.setLoggerProvider(r),
          s.getConfig().enabled || s.enable();
      }
    })(n, e, r, o),
    function () {
      !(function (t) {
        t.forEach(function (t) {
          return t.disable();
        });
      })(n);
    }
  );
}
function Lx(t) {
  throw new Error(
    'Could not dynamically require "' +
      t +
      '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.'
  );
}
var Ix = function () {
    return (
      (Ix =
        Object.assign ||
        function (t) {
          for (var n, e = 1, r = arguments.length; e < r; e++)
            for (var o in (n = arguments[e]))
              Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
          return t;
        }),
      Ix.apply(this, arguments)
    );
  },
  Mx = (function () {
    function t(t, n, e) {
      void 0 === e && (e = {}),
        (this.instrumentationName = t),
        (this.instrumentationVersion = n),
        (this.yt = Ty.wrap),
        (this.Rt = Ty.unwrap),
        (this.At = Ty.massWrap),
        (this.Ot = Ty.massUnwrap),
        (this.Nt = Ix({ enabled: !0 }, e)),
        (this.Ct = Pr.createComponentLogger({ namespace: t })),
        (this.Lt = Qr.getTracer(t, n)),
        (this.It = Ur.getMeter(t, n)),
        (this.Mt = gx.getLogger(t, n)),
        this.wt();
    }
    return (
      Object.defineProperty(t.prototype, "meter", {
        get: function () {
          return this.It;
        },
        enumerable: !1,
        configurable: !0,
      }),
      (t.prototype.setMeterProvider = function (t) {
        (this.It = t.getMeter(
          this.instrumentationName,
          this.instrumentationVersion
        )),
          this.wt();
      }),
      Object.defineProperty(t.prototype, "logger", {
        get: function () {
          return this.Mt;
        },
        enumerable: !1,
        configurable: !0,
      }),
      (t.prototype.setLoggerProvider = function (t) {
        this.Mt = t.getLogger(
          this.instrumentationName,
          this.instrumentationVersion
        );
      }),
      (t.prototype.getModuleDefinitions = function () {
        var t,
          n = null !== (t = this.init()) && void 0 !== t ? t : [];
        return Array.isArray(n) ? n : [n];
      }),
      (t.prototype.wt = function () {}),
      (t.prototype.getConfig = function () {
        return this.Nt;
      }),
      (t.prototype.setConfig = function (t) {
        void 0 === t && (t = {}), (this.Nt = Object.assign({}, t));
      }),
      (t.prototype.setTracerProvider = function (t) {
        this.Lt = t.getTracer(
          this.instrumentationName,
          this.instrumentationVersion
        );
      }),
      Object.defineProperty(t.prototype, "tracer", {
        get: function () {
          return this.Lt;
        },
        enumerable: !1,
        configurable: !0,
      }),
      t
    );
  })(),
  wx = function (t) {
    var n = "function" == typeof Symbol && Symbol.iterator,
      e = n && t[n],
      r = 0;
    if (e) return e.call(t);
    if (t && "number" == typeof t.length)
      return {
        next: function () {
          return (
            t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t }
          );
        },
      };
    throw new TypeError(
      n ? "Object is not iterable." : "Symbol.iterator is not defined."
    );
  },
  Zx = function (t, n) {
    var e = "function" == typeof Symbol && t[Symbol.iterator];
    if (!e) return t;
    var r,
      o,
      i = e.call(t),
      s = [];
    try {
      for (; (void 0 === n || n-- > 0) && !(r = i.next()).done; )
        s.push(r.value);
    } catch (t) {
      o = { error: t };
    } finally {
      try {
        r && !r.done && (e = i.return) && e.call(i);
      } finally {
        if (o) throw o.error;
      }
    }
    return s;
  },
  Px = function (t, n, e) {
    if (e || 2 === arguments.length)
      for (var r, o = 0, i = n.length; o < i; o++)
        (!r && o in n) ||
          (r || (r = Array.prototype.slice.call(n, 0, o)), (r[o] = n[o]));
    return t.concat(r || Array.prototype.slice.call(n));
  },
  Vx = "/",
  Gx = function () {
    (this.hooks = []), (this.children = new Map());
  },
  Xx = (function () {
    function t() {
      (this.rn = new Gx()), (this.sn = 0);
    }
    return (
      (t.prototype.insert = function (t) {
        var n,
          e,
          r = this.rn;
        try {
          for (
            var o = wx(t.moduleName.split(Vx)), i = o.next();
            !i.done;
            i = o.next()
          ) {
            var s = i.value,
              u = r.children.get(s);
            u || ((u = new Gx()), r.children.set(s, u)), (r = u);
          }
        } catch (t) {
          n = { error: t };
        } finally {
          try {
            i && !i.done && (e = o.return) && e.call(o);
          } finally {
            if (n) throw n.error;
          }
        }
        r.hooks.push({ hook: t, insertedId: this.sn++ });
      }),
      (t.prototype.search = function (t, n) {
        var e,
          r,
          o = void 0 === n ? {} : n,
          i = o.maintainInsertionOrder,
          s = o.fullOnly,
          u = this.rn,
          c = [],
          a = !0;
        try {
          for (var l = wx(t.split(Vx)), f = l.next(); !f.done; f = l.next()) {
            var d = f.value,
              h = u.children.get(d);
            if (!h) {
              a = !1;
              break;
            }
            s || c.push.apply(c, Px([], Zx(h.hooks), !1)), (u = h);
          }
        } catch (t) {
          e = { error: t };
        } finally {
          try {
            f && !f.done && (r = l.return) && r.call(l);
          } finally {
            if (e) throw e.error;
          }
        }
        return (
          s && a && c.push.apply(c, Px([], Zx(u.hooks), !1)),
          0 === c.length
            ? []
            : 1 === c.length
              ? [c[0].hook]
              : (i &&
                  c.sort(function (t, n) {
                    return t.insertedId - n.insertedId;
                  }),
                c.map(function (t) {
                  return t.hook;
                }))
        );
      }),
      t
    );
  })(),
  Ux = function (t) {
    var n = "function" == typeof Symbol && Symbol.iterator,
      e = n && t[n],
      r = 0;
    if (e) return e.call(t);
    if (t && "number" == typeof t.length)
      return {
        next: function () {
          return (
            t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t }
          );
        },
      };
    throw new TypeError(
      n ? "Object is not iterable." : "Symbol.iterator is not defined."
    );
  },
  Wx = ["afterEach", "after", "beforeEach", "before", "describe", "it"].every(
    function (t) {
      return "function" == typeof global[t];
    }
  ),
  Yx = (function () {
    function t() {
      (this.un = new Xx()), this.cn();
    }
    return (
      (t.prototype.cn = function () {
        var t = this;
        new JR(null, { internals: !0 }, function (n, e, r) {
          var o,
            i,
            s,
            u = ((s = e), A.sep !== Vx ? s.split(A.sep).join(Vx) : s),
            c = t.un.search(u, {
              maintainInsertionOrder: !0,
              fullOnly: void 0 === r,
            });
          try {
            for (var a = Ux(c), l = a.next(); !l.done; l = a.next()) {
              n = (0, l.value.onRequire)(n, e, r);
            }
          } catch (t) {
            o = { error: t };
          } finally {
            try {
              l && !l.done && (i = a.return) && i.call(a);
            } finally {
              if (o) throw o.error;
            }
          }
          return n;
        });
      }),
      (t.prototype.register = function (t, n) {
        var e = { moduleName: t, onRequire: n };
        return this.un.insert(e), e;
      }),
      (t.getInstance = function () {
        var n;
        return Wx
          ? new t()
          : (this.L = null !== (n = this.L) && void 0 !== n ? n : new t());
      }),
      t
    );
  })();
var Hx = { exports: {} },
  Dx = {};
const jx = [],
  xx = new WeakMap(),
  kx = new Map(),
  Kx = [],
  Bx = {
    set: (t, n, e) => xx.get(t)[n](e),
    defineProperty(t, n, e) {
      if (!("value" in e))
        throw new Error(
          "Getters/setters are not supported for exports property descriptors."
        );
      return xx.get(t)[n](e.value);
    },
  };
(Dx.register = function (t, n, e, r) {
  kx.set(t, r), xx.set(n, e);
  const o = new Proxy(n, Bx);
  jx.forEach((n) => n(t, o)), Kx.push([t, o]);
}),
  (Dx.importHooks = jx),
  (Dx.specifiers = kx),
  (Dx.toHook = Kx);
const Fx = n,
  Jx = DR,
  { fileURLToPath: zx } = u,
  { importHooks: Qx, specifiers: $x, toHook: qx } = Dx;
function tk(t) {
  Qx.push(t), qx.forEach(([n, e]) => t(n, e));
}
function nk(t) {
  const n = Qx.indexOf(t);
  n > -1 && Qx.splice(n, 1);
}
function ek(t, n, e, r) {
  const o = t(n, e, r);
  o && o !== n && (n.default = o);
}
function rk(t, n, e) {
  if (this instanceof rk == !1) return new rk(t, n, e);
  "function" == typeof t
    ? ((e = t), (t = null), (n = null))
    : "function" == typeof n && ((e = n), (n = null));
  const r = !!n && !0 === n.internals;
  (this.an = (n, o) => {
    const i = n;
    let s;
    if (n.startsWith("node:")) n = n.replace(/^node:/, "");
    else {
      if (n.startsWith("file://"))
        try {
          n = zx(n);
        } catch (t) {}
      const t = Jx(n);
      t && ((n = t.name), (s = t.basedir));
    }
    if (t) {
      for (const u of t)
        if (u === n) {
          if (s)
            if (r) n = n + Fx.sep + Fx.relative(s, zx(i));
            else if (!s.endsWith($x.get(i))) continue;
          ek(e, o, n, s);
        }
    } else ek(e, o, n, s);
  }),
    tk(this.an);
}
(rk.prototype.unhook = function () {
  nk(this.an);
}),
  (Hx.exports = rk);
var ok = (Hx.exports.addHook = tk),
  ik = (Hx.exports.removeHook = nk),
  sk = Hx.exports,
  uk = R({ __proto__: null, addHook: ok, default: Yt(sk), removeHook: ik }, [
    sk,
  ]),
  ck = (function () {
    var t = function (n, e) {
      return (
        (t =
          Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array &&
            function (t, n) {
              t.__proto__ = n;
            }) ||
          function (t, n) {
            for (var e in n)
              Object.prototype.hasOwnProperty.call(n, e) && (t[e] = n[e]);
          }),
        t(n, e)
      );
    };
    return function (n, e) {
      if ("function" != typeof e && null !== e)
        throw new TypeError(
          "Class extends value " + String(e) + " is not a constructor or null"
        );
      function r() {
        this.constructor = n;
      }
      t(n, e),
        (n.prototype =
          null === e
            ? Object.create(e)
            : ((r.prototype = e.prototype), new r()));
    };
  })(),
  ak = function (t) {
    var n = "function" == typeof Symbol && Symbol.iterator,
      e = n && t[n],
      r = 0;
    if (e) return e.call(t);
    if (t && "number" == typeof t.length)
      return {
        next: function () {
          return (
            t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t }
          );
        },
      };
    throw new TypeError(
      n ? "Object is not iterable." : "Symbol.iterator is not defined."
    );
  },
  lk = (function (t) {
    function n(n, r, o) {
      void 0 === o && (o = {});
      var i = t.call(this, n, r, o) || this;
      (i.ln = []),
        (i.fn = Yx.getInstance()),
        (i.dn = !1),
        (i.yt = function (t, n, r) {
          if (e.types.isProxy(t)) {
            var o = Ty.wrap(Object.assign({}, t), n, r);
            return Object.defineProperty(t, n, { value: o });
          }
          return Ty.wrap(t, n, r);
        }),
        (i.Rt = function (t, n) {
          return e.types.isProxy(t)
            ? Object.defineProperty(t, n, { value: t[n] })
            : Ty.unwrap(t, n);
        }),
        (i.At = function (t, n, e) {
          t
            ? (Array.isArray(t) || (t = [t]),
              n && Array.isArray(n)
                ? t.forEach(function (t) {
                    n.forEach(function (n) {
                      i.yt(t, n, e);
                    });
                  })
                : Pr.error(
                    "must provide one or more functions to wrap on modules"
                  ))
            : Pr.error("must provide one or more modules to patch");
        }),
        (i.Ot = function (t, n) {
          t
            ? (Array.isArray(t) || (t = [t]),
              n && Array.isArray(n)
                ? t.forEach(function (t) {
                    n.forEach(function (n) {
                      i.Rt(t, n);
                    });
                  })
                : Pr.error(
                    "must provide one or more functions to wrap on modules"
                  ))
            : Pr.error("must provide one or more modules to patch");
        });
      var s = i.init();
      return (
        s && !Array.isArray(s) && (s = [s]),
        (i.hn = s || []),
        0 === i.hn.length &&
          Pr.debug(
            "No modules instrumentation has been defined for '" +
              i.instrumentationName +
              "@" +
              i.instrumentationVersion +
              "', nothing will be patched"
          ),
        i.Nt.enabled && i.enable(),
        i
      );
    }
    return (
      ck(n, t),
      (n.prototype.pn = function () {
        var t = this;
        this.hn.forEach(function (n) {
          var e = n.name;
          try {
            var r = require.resolve(e);
            require.cache[r] &&
              t.Ct.warn(
                "Module " +
                  e +
                  " has been loaded before " +
                  t.instrumentationName +
                  " so it might not work, please initialize it before requiring " +
                  e
              );
          } catch (t) {}
        });
      }),
      (n.prototype.Sn = function (t) {
        try {
          var n = Lx(A.join(t, "package.json")).version;
          return "string" == typeof n ? n : void 0;
        } catch (n) {
          Pr.warn("Failed extracting version", t);
        }
      }),
      (n.prototype.En = function (t, n, e, r) {
        var o,
          i = this;
        if (!r)
          return "function" == typeof t.patch &&
            ((t.moduleExports = n), this.dn)
            ? t.patch(n)
            : n;
        var s = this.Sn(r);
        if (((t.moduleVersion = s), t.name === e))
          return fk(t.supportedVersions, s, t.includePrerelease) &&
            "function" == typeof t.patch &&
            ((t.moduleExports = n), this.dn)
            ? t.patch(n, t.moduleVersion)
            : n;
        var u = null !== (o = t.files) && void 0 !== o ? o : [],
          c = A.normalize(e);
        return u
          .filter(function (t) {
            return t.name === c;
          })
          .filter(function (n) {
            return fk(n.supportedVersions, s, t.includePrerelease);
          })
          .reduce(function (n, e) {
            return (
              (e.moduleExports = n), i.dn ? e.patch(n, t.moduleVersion) : n
            );
          }, n);
      }),
      (n.prototype.enable = function () {
        var t,
          n,
          e,
          r,
          o,
          i,
          s = this;
        if (!this.dn)
          if (((this.dn = !0), this.ln.length > 0))
            try {
              for (var u = ak(this.hn), c = u.next(); !c.done; c = u.next()) {
                var a = c.value;
                "function" == typeof a.patch &&
                  a.moduleExports &&
                  a.patch(a.moduleExports, a.moduleVersion);
                try {
                  for (
                    var l = ((e = void 0), ak(a.files)), f = l.next();
                    !f.done;
                    f = l.next()
                  ) {
                    var d = f.value;
                    d.moduleExports &&
                      d.patch(d.moduleExports, a.moduleVersion);
                  }
                } catch (t) {
                  e = { error: t };
                } finally {
                  try {
                    f && !f.done && (r = l.return) && r.call(l);
                  } finally {
                    if (e) throw e.error;
                  }
                }
              }
            } catch (n) {
              t = { error: n };
            } finally {
              try {
                c && !c.done && (n = u.return) && n.call(u);
              } finally {
                if (t) throw t.error;
              }
            }
          else {
            this.pn();
            var h = function (t) {
                var n = function (n, e, r) {
                    return s.En(t, n, e, r);
                  },
                  e = A.isAbsolute(t.name)
                    ? new JR([t.name], { internals: !0 }, n)
                    : p.fn.register(t.name, n);
                p.ln.push(e);
                var r = new uk([t.name], { internals: !1 }, function (n, e, r) {
                  return s.En(t, n, e, r);
                });
                p.ln.push(r);
              },
              p = this;
            try {
              for (var S = ak(this.hn), E = S.next(); !E.done; E = S.next()) {
                h(E.value);
              }
            } catch (t) {
              o = { error: t };
            } finally {
              try {
                E && !E.done && (i = S.return) && i.call(S);
              } finally {
                if (o) throw o.error;
              }
            }
          }
      }),
      (n.prototype.disable = function () {
        var t, n, e, r;
        if (this.dn) {
          this.dn = !1;
          try {
            for (var o = ak(this.hn), i = o.next(); !i.done; i = o.next()) {
              var s = i.value;
              "function" == typeof s.unpatch &&
                s.moduleExports &&
                s.unpatch(s.moduleExports, s.moduleVersion);
              try {
                for (
                  var u = ((e = void 0), ak(s.files)), c = u.next();
                  !c.done;
                  c = u.next()
                ) {
                  var a = c.value;
                  a.moduleExports &&
                    a.unpatch(a.moduleExports, s.moduleVersion);
                }
              } catch (t) {
                e = { error: t };
              } finally {
                try {
                  c && !c.done && (r = u.return) && r.call(u);
                } finally {
                  if (e) throw e.error;
                }
              }
            }
          } catch (n) {
            t = { error: n };
          } finally {
            try {
              i && !i.done && (n = o.return) && n.call(o);
            } finally {
              if (t) throw t.error;
            }
          }
        }
      }),
      (n.prototype.isEnabled = function () {
        return this.dn;
      }),
      n
    );
  })(Mx);
function fk(t, n, e) {
  return void 0 === n
    ? t.includes("*")
    : t.some(function (t) {
        return Qv.satisfies(n, t, { includePrerelease: e });
      });
}
var dk = function (t, n, e, r, o) {
    (this.name = t),
      (this.supportedVersions = n),
      (this.patch = e),
      (this.unpatch = r),
      (this.files = o || []);
  },
  hk = function (t, e, r, o) {
    (this.supportedVersions = e),
      (this.patch = r),
      (this.unpatch = o),
      (this.name = n.normalize(t));
  },
  pk = function (t, n, e, r) {
    return new (e || (e = Promise))(function (o, i) {
      function s(t) {
        try {
          c(r.next(t));
        } catch (t) {
          i(t);
        }
      }
      function u(t) {
        try {
          c(r.throw(t));
        } catch (t) {
          i(t);
        }
      }
      function c(t) {
        var n;
        t.done
          ? o(t.value)
          : ((n = t.value),
            n instanceof e
              ? n
              : new e(function (t) {
                  t(n);
                })).then(s, u);
      }
      c((r = r.apply(t, n || [])).next());
    });
  },
  Sk = function (t, n) {
    var e,
      r,
      o,
      i,
      s = {
        label: 0,
        sent: function () {
          if (1 & o[0]) throw o[1];
          return o[1];
        },
        trys: [],
        ops: [],
      };
    return (
      (i = { next: u(0), throw: u(1), return: u(2) }),
      "function" == typeof Symbol &&
        (i[Symbol.iterator] = function () {
          return this;
        }),
      i
    );
    function u(i) {
      return function (u) {
        return (function (i) {
          if (e) throw new TypeError("Generator is already executing.");
          for (; s; )
            try {
              if (
                ((e = 1),
                r &&
                  (o =
                    2 & i[0]
                      ? r.return
                      : i[0]
                        ? r.throw || ((o = r.return) && o.call(r), 0)
                        : r.next) &&
                  !(o = o.call(r, i[1])).done)
              )
                return o;
              switch (((r = 0), o && (i = [2 & i[0], o.value]), i[0])) {
                case 0:
                case 1:
                  o = i;
                  break;
                case 4:
                  return s.label++, { value: i[1], done: !1 };
                case 5:
                  s.label++, (r = i[1]), (i = [0]);
                  continue;
                case 7:
                  (i = s.ops.pop()), s.trys.pop();
                  continue;
                default:
                  if (
                    !((o = s.trys),
                    (o = o.length > 0 && o[o.length - 1]) ||
                      (6 !== i[0] && 2 !== i[0]))
                  ) {
                    s = 0;
                    continue;
                  }
                  if (3 === i[0] && (!o || (i[1] > o[0] && i[1] < o[3]))) {
                    s.label = i[1];
                    break;
                  }
                  if (6 === i[0] && s.label < o[1]) {
                    (s.label = o[1]), (o = i);
                    break;
                  }
                  if (o && s.label < o[2]) {
                    (s.label = o[2]), s.ops.push(i);
                    break;
                  }
                  o[2] && s.ops.pop(), s.trys.pop();
                  continue;
              }
              i = n.call(t, s);
            } catch (t) {
              (i = [6, t]), (r = 0);
            } finally {
              e = o = 0;
            }
          if (5 & i[0]) throw i[1];
          return { value: i[0] ? i[1] : void 0, done: !0 };
        })([i, u]);
      };
    }
  };
var Ek = Object.freeze({
  __proto__: null,
  InstrumentationBase: lk,
  InstrumentationNodeModuleDefinition: dk,
  InstrumentationNodeModuleFile: hk,
  isWrapped: function (t) {
    return (
      "function" == typeof t &&
      "function" == typeof t.__original &&
      "function" == typeof t.__unwrap &&
      !0 === t.__wrapped
    );
  },
  registerInstrumentations: Cx,
  safeExecuteInTheMiddle: function (t, n, e) {
    var r, o;
    try {
      o = t();
    } catch (t) {
      r = t;
    } finally {
      if ((n(r, o), r && !e)) throw r;
      return o;
    }
  },
  safeExecuteInTheMiddleAsync: function (t, n, e) {
    return pk(this, void 0, void 0, function () {
      var r, o, i;
      return Sk(this, function (s) {
        switch (s.label) {
          case 0:
            return s.trys.push([0, 2, 3, 4]), [4, t()];
          case 1:
            return (o = s.sent()), [3, 4];
          case 2:
            return (i = s.sent()), (r = i), [3, 4];
          case 3:
            if ((n(r, o), r && !e)) throw r;
            return [2, o];
          case 4:
            return [2];
        }
      });
    });
  },
});
function mk(t) {
  const n = t;
  return !!n.attributes && "object" == typeof n.attributes;
}
function Tk(t) {
  return !!t.name;
}
function _k(t) {
  return !!t.parentSpanId;
}
function bk(t) {
  if (!mk(t)) return {};
  const n = { url: t.attributes[gC], "http.method": t.attributes[OC] };
  !n["http.method"] && n.url && (n["http.method"] = "GET");
  try {
    const e = t.attributes[gC];
    if ("string" == typeof e) {
      const t = un(e);
      (n.url = an(t)),
        t.search && (n["http.query"] = t.search),
        t.hash && (n["http.fragment"] = t.hash);
    }
  } catch (t) {}
  return n;
}
function vk(t) {
  return (function (t) {
    return !!t.kind;
  })(t)
    ? t.kind
    : yr.INTERNAL;
}
const yk = "sentry-trace",
  Rk = "baggage",
  Ak = "sentry.dsc",
  Ok = "sentry.parent_span_id",
  gk = "sentry.sampled_not_recording",
  Nk = "sentry.url",
  Ck = ve("sentry_scopes"),
  Lk = ve("sentry_fork_isolation_scope"),
  Ik = ve("sentry_fork_set_scope"),
  Mk = ve("sentry_fork_set_isolation_scope"),
  wk = "_scopeContext";
function Zk(t) {
  return t.getValue(Ck);
}
function Pk(t, n) {
  return t.setValue(Ck, n);
}
function Vk(t) {
  let n,
    e = t[0],
    r = 1;
  for (; r < t.length; ) {
    const o = t[r],
      i = t[r + 1];
    if (
      ((r += 2), ("optionalAccess" === o || "optionalCall" === o) && null == e)
    )
      return;
    "access" === o || "optionalAccess" === o
      ? ((n = e), (e = i(e)))
      : ("call" !== o && "optionalCall" !== o) ||
        ((e = i((...t) => e.call(n, ...t))), (n = void 0));
  }
  return e;
}
function Gk(t) {
  const { traceFlags: n, traceState: e } = t,
    r = !!e && "1" === e.get(gk);
  if (n === ke.SAMPLED) return !0;
  if (r) return !1;
  const o = e ? e.get(Ak) : void 0,
    i = o ? Rn(o) : void 0;
  return (
    "true" === Vk([i, "optionalAccess", (t) => t.sampled]) ||
    ("false" !== Vk([i, "optionalAccess", (t) => t.sampled]) && void 0)
  );
}
function Xk(t) {
  const n = mk(t) ? t.attributes : {},
    e = Tk(t) ? t.name : "<unknown>",
    r = n["http.request.method"] || n[OC];
  if (r)
    return (function ({ name: t, kind: n, attributes: e }, r) {
      const o = ["http"];
      switch (n) {
        case yr.CLIENT:
          o.push("client");
          break;
        case yr.SERVER:
          o.push("server");
      }
      const {
        urlPath: i,
        url: s,
        query: u,
        fragment: c,
        hasRoute: a,
      } = (function (t, n) {
        const e = t[NC],
          r = t[gC],
          o = t[UC],
          i = "string" == typeof r ? un(r) : void 0,
          s = i ? an(i) : void 0,
          u = i && i.search ? i.search : void 0,
          c = i && i.hash ? i.hash : void 0;
        if ("string" == typeof o)
          return { urlPath: o, url: s, query: u, fragment: c, hasRoute: !0 };
        if (n === yr.SERVER && "string" == typeof e)
          return {
            urlPath: cn(e),
            url: s,
            query: u,
            fragment: c,
            hasRoute: !1,
          };
        if (i)
          return { urlPath: s, url: s, query: u, fragment: c, hasRoute: !1 };
        if ("string" == typeof e)
          return {
            urlPath: cn(e),
            url: s,
            query: u,
            fragment: c,
            hasRoute: !1,
          };
        return { urlPath: void 0, url: s, query: u, fragment: c, hasRoute: !1 };
      })(e, n);
      if (!i) return { op: o.join("."), description: t, source: "custom" };
      const l = `${r} ${i}`,
        f = a || "/" === i ? "route" : "url",
        d = {};
      s && (d.url = s);
      u && (d["http.query"] = u);
      c && (d["http.fragment"] = c);
      return { op: o.join("."), description: l, source: f, data: d };
    })({ attributes: n, name: e, kind: vk(t) }, r);
  if (n[bN])
    return (function ({ attributes: t, name: n }) {
      const e = t[ON],
        r = e ? e.toString() : n;
      return { op: "db", description: r, source: "task" };
    })({ attributes: n, name: e });
  if (n[CL]) return { op: "rpc", description: e, source: "route" };
  if (n[cL]) return { op: "message", description: e, source: "route" };
  const o = n[xN];
  return o
    ? { op: o.toString(), description: e, source: "route" }
    : { op: void 0, description: e, source: "custom" };
}
function Uk(t) {
  const n = GU();
  if (!n) return {};
  const e = (function (t) {
      let n,
        e = t[0],
        r = 1;
      for (; r < t.length; ) {
        const o = t[r],
          i = t[r + 1];
        if (
          ((r += 2),
          ("optionalAccess" === o || "optionalCall" === o) && null == e)
        )
          return;
        "access" === o || "optionalAccess" === o
          ? ((n = e), (e = i(e)))
          : ("call" !== o && "optionalCall" !== o) ||
            ((e = i((...t) => e.call(n, ...t))), (n = void 0));
      }
      return e;
    })([
      t.spanContext().traceState,
      "optionalAccess",
      (t) => t.get,
      "call",
      (t) => t(Ak),
    ]),
    r = e ? Rn(e) : void 0;
  if (r) return r;
  const o = sW(t.spanContext().traceId, n),
    i = mk(t) ? t.attributes : {},
    s = i[BU];
  null != s && (o.sample_rate = `${s}`);
  const u = i[KU],
    { description: c } = Tk(t) ? Xk(t) : { description: "" };
  "url" !== u && c && (o.transaction = c);
  const a = Gk(t.spanContext());
  return null != a && (o.sampled = String(a)), n.emit("createDsc", o), o;
}
function Wk() {
  return Qr.getActiveSpan();
}
const Yk = new Set();
function Hk(t) {
  Yk.add(t);
}
function Dk(t) {
  let n,
    e = t[0],
    r = 1;
  for (; r < t.length; ) {
    const o = t[r],
      i = t[r + 1];
    if (
      ((r += 2), ("optionalAccess" === o || "optionalCall" === o) && null == e)
    )
      return;
    "access" === o || "optionalAccess" === o
      ? ((n = e), (e = i(e)))
      : ("call" !== o && "optionalCall" !== o) ||
        ((e = i((...t) => e.call(n, ...t))), (n = void 0));
  }
  return e;
}
function jk(t) {
  const n = t.spanContext(),
    { traceId: e, spanId: r, traceState: o } = n,
    i = o ? o.get(Ak) : void 0,
    s = i ? Rn(i) : void 0,
    u = o ? o.get(Ok) : void 0;
  return {
    traceId: e,
    spanId: r,
    sampled: Gk(n),
    parentSpanId: u,
    dsc: s || Uk(bW(t)),
  };
}
class xk extends yH {
  constructor() {
    super(), Hk("SentryPropagator"), (this.oo = new Kn(100));
  }
  inject(t, n, e) {
    if (_H(t)) return;
    const r = Qr.getSpan(t),
      o =
        r &&
        (function (t) {
          const n = Dk([
            hW,
            "call",
            (n) => n(t),
            "access",
            (t) => t.data,
            "optionalAccess",
            (t) => t[gC],
          ]);
          if (n) return n;
          const e = Dk([
            t,
            "access",
            (t) => t.spanContext,
            "call",
            (t) => t(),
            "access",
            (t) => t.traceState,
            "optionalAccess",
            (t) => t.get,
            "call",
            (t) => t(Nk),
          ]);
          if (e) return e;
          return;
        })(r),
      i = Dk([
        GU,
        "call",
        (t) => t(),
        "optionalAccess",
        (t) => t.getOptions,
        "call",
        (t) => t(),
        "optionalAccess",
        (t) => t.tracePropagationTargets,
      ]);
    if ("string" == typeof o && i && !this.io(i, o)) return;
    const s = (function (t) {
      try {
        const n = t[Rk];
        return Array.isArray(n) ? n.join(",") : n;
      } catch (t) {
        return;
      }
    })(n);
    let u = Fr.getBaggage(t) || Fr.createBaggage({});
    const {
      dynamicSamplingContext: c,
      traceId: a,
      spanId: l,
      sampled: f,
    } = (function (t) {
      const n = IW() ? Qr.getSpan(t) : void 0,
        e = Dk([
          n,
          "optionalAccess",
          (t) => t.spanContext,
          "call",
          (t) => t(),
          "access",
          (t) => t.isRemote,
        ]);
      if (n && !e) {
        const t = n.spanContext();
        return {
          dynamicSamplingContext: Kk(jk(n), t.traceId),
          traceId: t.traceId,
          spanId: t.spanId,
          sampled: Gk(t),
        };
      }
      const r =
          Dk([Zk, "call", (n) => n(t), "optionalAccess", (t) => t.scope]) ||
          MU(),
        o = r.getPropagationContext(),
        i = Kk(o, o.traceId);
      return {
        dynamicSamplingContext: i,
        traceId: o.traceId,
        spanId: o.spanId,
        sampled: o.sampled,
      };
    })(t);
    if (s) {
      const t = On(s);
      t &&
        Object.entries(t).forEach(([t, n]) => {
          u = u.setEntry(t, { value: n });
        });
    }
    c &&
      (u = Object.entries(c).reduce(
        (t, [n, e]) => (e ? t.setEntry(`${bn}${n}`, { value: e }) : t),
        u
      )),
      a &&
        "00000000000000000000000000000000" !== a &&
        e.set(n, yk, Ln(a, l, f)),
      super.inject(Fr.setBaggage(t, u), n, e);
  }
  extract(t, n, e) {
    const r = e.get(n, yk),
      o = e.get(n, Rk),
      i = r ? (Array.isArray(r) ? r[0] : r) : void 0,
      s = Cn(i, o),
      u = Bk(t, { sentryTrace: i, baggage: o }),
      c = Zk(u),
      a = {
        scope: c ? c.scope.clone() : MU().clone(),
        isolationScope: c ? c.isolationScope : wU(),
      };
    return a.scope.setPropagationContext(s), Pk(u, a);
  }
  fields() {
    return [yk, Rk];
  }
  io(t, n) {
    if (void 0 === t) return !0;
    const e = this.oo.get(n);
    if (void 0 !== e) return e;
    const r = K(n, t);
    return this.oo.set(n, r), r;
  }
}
function kk({ parentSpanId: t, dsc: n, sampled: e }) {
  if (!t && !n && !1 !== e) return;
  const r = n ? An(n) : void 0,
    o = t ? new NH().set(Ok, t) : new NH(),
    i = r ? o.set(Ak, r) : o;
  return !1 === e ? i.set(gk, "1") : i;
}
function Kk(t, n) {
  if (Dk([t, "optionalAccess", (t) => t.dsc])) return t.dsc;
  const e = GU();
  return e ? sW(n || t.traceId, e) : void 0;
}
function Bk(t, { sentryTrace: n, baggage: e }) {
  const r = Cn(n, e),
    o = kk({ parentSpanId: r.parentSpanId, dsc: r.dsc, sampled: r.sampled }),
    i = {
      traceId: r.traceId,
      spanId: r.parentSpanId || "",
      isRemote: !0,
      traceFlags: r.sampled ? ke.SAMPLED : ke.NONE,
      traceState: o,
    };
  return Qr.setSpanContext(t, i);
}
function Fk(t, n) {
  const e = $k(),
    { name: r } = t,
    o = nK(t.scope, t.forceTransaction),
    i = t.onlyIfParent && !Qr.getSpan(o) ? TH(o) : o,
    s = tK(t);
  return e.startActiveSpan(
    r,
    s,
    i,
    (e) => (
      qk(e, t),
      wW(
        () => n(e),
        () => {
          void 0 === hW(e).status && e.setStatus({ code: Rr.ERROR });
        },
        () => e.end()
      )
    )
  );
}
function Jk(t, n) {
  const e = $k(),
    { name: r } = t,
    o = nK(t.scope, t.forceTransaction),
    i = t.onlyIfParent && !Qr.getSpan(o) ? TH(o) : o,
    s = tK(t);
  return e.startActiveSpan(
    r,
    s,
    i,
    (e) => (
      qk(e, t),
      wW(
        () => n(e, () => e.end()),
        () => {
          void 0 === hW(e).status && e.setStatus({ code: Rr.ERROR });
        }
      )
    )
  );
}
function zk(t) {
  const n = $k(),
    { name: e } = t,
    r = nK(t.scope, t.forceTransaction),
    o = t.onlyIfParent && !Qr.getSpan(r) ? TH(r) : r,
    i = tK(t),
    s = n.startSpan(e, i, o);
  return qk(s, t), s;
}
function Qk(t, n) {
  const e = t ? Qr.setSpan(Zr.active(), t) : Qr.deleteSpan(Zr.active());
  return Zr.with(e, () => n(MU()));
}
function $k() {
  const t = GU();
  return (t && t.tracer) || Qr.getTracer("@sentry/opentelemetry", IY);
}
function qk(t, n) {
  const { op: e } = n;
  e && t.setAttribute(FU, e);
}
function tK(t) {
  const { startTime: n, attributes: e, kind: r } = t;
  var o;
  return {
    attributes: e,
    kind: r,
    startTime: "number" == typeof n ? ((o = n) < 9999999999 ? 1e3 * o : o) : n,
  };
}
function nK(t, n) {
  const e = (function (t) {
      if (t) {
        const n = (function (t) {
          return t[wk];
        })(t);
        if (n) return n;
      }
      return Zr.active();
    })(t),
    r = (function (t) {
      let n,
        e = t[0],
        r = 1;
      for (; r < t.length; ) {
        const o = t[r],
          i = t[r + 1];
        if (
          ((r += 2),
          ("optionalAccess" === o || "optionalCall" === o) && null == e)
        )
          return;
        "access" === o || "optionalAccess" === o
          ? ((n = e), (e = i(e)))
          : ("call" !== o && "optionalCall" !== o) ||
            ((e = i((...t) => e.call(n, ...t))), (n = void 0));
      }
      return e;
    })([Zk, "call", (t) => t(e), "optionalAccess", (t) => t.scope]),
    o = Qr.getSpan(e);
  if (!o) {
    const t = GU();
    if (r && t) {
      const t = r.getPropagationContext(),
        n = kk({
          parentSpanId: t.parentSpanId,
          dsc: void 0,
          sampled: t.sampled,
        }),
        o = {
          traceId: t.traceId,
          spanId: t.parentSpanId || t.spanId,
          isRemote: !0,
          traceFlags: t.sampled ? ke.SAMPLED : ke.NONE,
          traceState: n,
        };
      return Qr.setSpanContext(e, o);
    }
    return e;
  }
  if (!n) return e;
  const i = Qr.deleteSpan(e),
    { spanId: s, traceId: u } = o.spanContext(),
    c = Gk(o.spanContext()),
    a = kk({ dsc: Uk(bW(o)), parentSpanId: s, sampled: c }),
    l = {
      traceId: u,
      spanId: s,
      isRemote: !0,
      traceFlags: c ? ke.SAMPLED : ke.NONE,
      traceState: a,
    };
  return Qr.setSpanContext(i, l);
}
function eK(t, n) {
  return DW(t, () =>
    (function (t, n, e) {
      const r = Bk(t, n);
      return Zr.with(r, e);
    })(Zr.active(), t, n)
  );
}
function rK(t) {
  const n = TH(Zr.active());
  return Zr.with(n, t);
}
function oK() {
  function t() {
    const t = Zk(Zr.active());
    return t || { scope: LU(), isolationScope: IU() };
  }
  function n() {
    return t().scope;
  }
  function e() {
    return t().isolationScope;
  }
  var r;
  (r = {
    withScope: function (t) {
      const e = Zr.active();
      return Zr.with(e, () => t(n()));
    },
    withSetScope: function (t, n) {
      const e = Zr.active();
      return Zr.with(e.setValue(Ik, t), () => n(t));
    },
    withSetIsolationScope: function (t, n) {
      const r = Zr.active();
      return Zr.with(r.setValue(Mk, t), () => n(e()));
    },
    withIsolationScope: function (t) {
      const n = Zr.active();
      return Zr.with(n.setValue(Lk, !0), () => t(e()));
    },
    getCurrentScope: n,
    getIsolationScope: e,
    startSpan: Fk,
    startSpanManual: Jk,
    startInactiveSpan: zk,
    getActiveSpan: Wk,
    withActiveSpan: Qk,
    suppressTracing: rK,
  }),
    (bU(_U()).acs = r);
}
function iK(t) {
  let n,
    e = t[0],
    r = 1;
  for (; r < t.length; ) {
    const o = t[r],
      i = t[r + 1];
    if (
      ((r += 2), ("optionalAccess" === o || "optionalCall" === o) && null == e)
    )
      return;
    "access" === o || "optionalAccess" === o
      ? ((n = e), (e = i(e)))
      : ("call" !== o && "optionalCall" !== o) ||
        ((e = i((...t) => e.call(n, ...t))), (n = void 0));
  }
  return e;
}
const sK = "sentry.parentIsRemote";
function uK([t, n]) {
  return t + n / 1e9;
}
function cK(t) {
  return !0 === t.attributes[sK] ? void 0 : t.parentSpanId;
}
function aK(t, n) {
  const e = n.spanContext().spanId,
    r = cK(n);
  if (!r) return void lK(t, { id: e, span: n, children: [] });
  const o = (function (t, n) {
      const e = t.get(n);
      if (e) return e;
      return lK(t, { id: n, children: [] });
    })(t, r),
    i = lK(t, { id: e, span: n, parentNode: o, children: [] });
  o.children.push(i);
}
function lK(t, n) {
  const e = t.get(n.id);
  return e && e.span
    ? e
    : e && !e.span
      ? ((e.span = n.span), (e.parentNode = n.parentNode), e)
      : (t.set(n.id, n), n);
}
const fK = {
    1: "cancelled",
    2: "unknown_error",
    3: "invalid_argument",
    4: "deadline_exceeded",
    5: "not_found",
    6: "already_exists",
    7: "permission_denied",
    8: "resource_exhausted",
    9: "failed_precondition",
    10: "aborted",
    11: "out_of_range",
    12: "unimplemented",
    13: "internal_error",
    14: "unavailable",
    15: "data_loss",
    16: "unauthenticated",
  },
  dK = (t) => Object.values(fK).includes(t);
function hK(t) {
  const n = mk(t) ? t.attributes : {},
    e = (function (t) {
      return !!t.status;
    })(t)
      ? t.status
      : void 0;
  if (e) {
    if (e.code === Rr.OK) return { code: tW };
    if (e.code === Rr.ERROR)
      return void 0 === e.message || dK(e.message)
        ? { code: nW, message: e.message }
        : { code: nW, message: "unknown_error" };
  }
  const r = n[IC],
    o = n[IL],
    i = "number" == typeof r ? r : "string" == typeof r ? parseInt(r) : void 0;
  return i
    ? eW(i)
    : "string" == typeof o
      ? { code: nW, message: fK[o] || "unknown_error" }
      : e && e.code === Rr.UNSET
        ? { code: tW }
        : { code: nW, message: "unknown_error" };
}
class pK {
  constructor() {
    this.Rr = [];
  }
  export(t) {
    this.Rr.push(t),
      cK(t)
        ? this.so()
        : (this.uo(),
          (this.co = setTimeout(() => {
            this.flush();
          }, 1)));
  }
  flush() {
    this.uo();
    const t = (function (t) {
      const n = (function (t) {
          const n = new Map();
          for (const e of t) aK(n, e);
          return Array.from(n, function ([t, n]) {
            return n;
          });
        })(t),
        e = new Set(n);
      return (
        EK(n).forEach((t) => {
          e.delete(t);
          const n = t.span,
            r = (function (t) {
              const {
                  op: n,
                  description: e,
                  data: r,
                  origin: o = "manual",
                  source: i,
                } = TK(t),
                s = LW(t),
                u = t.attributes[BU],
                c = Et({
                  [KU]: i,
                  [BU]: u,
                  [FU]: n,
                  [JU]: o,
                  ...r,
                  ..._K(t.attributes),
                }),
                { traceId: a, spanId: l } = t.spanContext(),
                f = t.parentSpanId,
                d = hK(t),
                h = {
                  contexts: {
                    trace: Et({
                      parent_span_id: f,
                      span_id: l,
                      trace_id: a,
                      data: c,
                      origin: o,
                      op: n,
                      status: SW(d),
                    }),
                    otel: { resource: t.resource.attributes },
                  },
                  spans: [],
                  start_timestamp: uK(t.startTime),
                  timestamp: uK(t.endTime),
                  transaction: e,
                  type: "transaction",
                  sdkProcessingMetadata: {
                    ...Et({
                      capturedSpanScope: s.scope,
                      capturedSpanIsolationScope: s.isolationScope,
                      sampleRate: u,
                      dynamicSamplingContext: Uk(t),
                    }),
                  },
                  ...(i && { transaction_info: { source: i } }),
                  fe: kU(t),
                };
              return h;
            })(n),
            o = r.spans || [];
          t.children.forEach((t) => {
            mK(t, o, e);
          }),
            (r.spans = o);
          const i = GW(n.events);
          i && (r.measurements = i), eY(r);
        }),
        Array.from(e)
          .map((t) => t.span)
          .filter((t) => !!t)
      );
    })(this.Rr);
    this.so(t);
  }
  clear() {
    (this.Rr = []), this.uo();
  }
  uo() {
    this.co && (clearTimeout(this.co), (this.co = void 0));
  }
  so(t = this.Rr) {
    this.Rr = t.filter((t) => {
      const n = (function (t, n) {
        const e = Date.now() / 1e3 - n;
        return uK(t.startTime) < e;
      })(t, 300);
      return !n;
    });
  }
}
function SK(t) {
  return !!t.span && !t.parentNode;
}
function EK(t) {
  return t.filter(SK);
}
function mK(t, n, e) {
  e.delete(t);
  const r = t.span;
  if (!r)
    return void t.children.forEach((t) => {
      mK(t, n, e);
    });
  const o = r.spanContext().spanId,
    i = r.spanContext().traceId,
    { attributes: s, startTime: u, endTime: c, parentSpanId: a } = r,
    { op: l, description: f, data: d, origin: h = "manual" } = TK(r),
    p = Et({ [JU]: h, [FU]: l, ..._K(s), ...d }),
    S = hK(r),
    E = Et({
      span_id: o,
      trace_id: i,
      data: p,
      description: f,
      parent_span_id: a,
      start_timestamp: uK(u),
      timestamp: uK(c) || void 0,
      status: SW(S),
      op: l,
      origin: h,
      fe: kU(r),
      measurements: GW(r.events),
    });
  n.push(E),
    t.children.forEach((t) => {
      mK(t, n, e);
    });
}
function TK(t) {
  const {
      op: n,
      source: e,
      origin: r,
    } = (function (t) {
      const n = t.attributes;
      return { origin: n[JU], op: n[FU], source: n[KU] };
    })(t),
    { op: o, description: i, source: s, data: u } = Xk(t);
  return {
    op: n || o,
    description: i,
    source: e || s,
    origin: r,
    data: { ...u, ...bK(t) },
  };
}
function _K(t) {
  const n = { ...t };
  return delete n[BU], delete n[sK], n;
}
function bK(t) {
  const n = t.attributes,
    e = { "otel.kind": yr[t.kind] };
  if (n[IC]) {
    const t = n[IC];
    e["http.response.status_code"] = t;
  }
  const r = bk(t);
  return (
    r.url && (e.url = r.url),
    r["http.query"] && (e["http.query"] = r["http.query"].slice(1)),
    r["http.fragment"] && (e["http.fragment"] = r["http.fragment"].slice(1)),
    e
  );
}
function vK(t) {
  let n,
    e = t[0],
    r = 1;
  for (; r < t.length; ) {
    const o = t[r],
      i = t[r + 1];
    if (
      ((r += 2), ("optionalAccess" === o || "optionalCall" === o) && null == e)
    )
      return;
    "access" === o || "optionalAccess" === o
      ? ((n = e), (e = i(e)))
      : ("call" !== o && "optionalCall" !== o) ||
        ((e = i((...t) => e.call(n, ...t))), (n = void 0));
  }
  return e;
}
class yK {
  constructor() {
    Hk("SentrySpanProcessor"), (this.vr = new pK());
  }
  async forceFlush() {
    this.vr.flush();
  }
  async shutdown() {
    this.vr.clear();
  }
  onStart(t, n) {
    !(function (t, n) {
      const e = Qr.getSpan(n);
      let r = Zk(n);
      e && !e.spanContext().isRemote && TW(e, t),
        e && e.spanContext().isRemote && t.setAttribute(sK, !0),
        n === Oe && (r = { scope: LU(), isolationScope: IU() }),
        r && CW(t, r.scope, r.isolationScope),
        vK([
          GU(),
          "optionalAccess",
          (t) => t.emit,
          "call",
          (n) => n("spanStart", t),
        ]);
    })(t, n);
  }
  onEnd(t) {
    !(function (t) {
      vK([
        GU(),
        "optionalAccess",
        (t) => t.emit,
        "call",
        (n) => n("spanEnd", t),
      ]);
    })(t),
      this.vr.export(t);
  }
}
class RK {
  constructor(t) {
    (this.oe = t), Hk("SentrySampler");
  }
  shouldSample(t, n, e, r, o, i) {
    const s = this.oe.getOptions(),
      u = Qr.getSpan(t),
      c = Fn([u, "optionalAccess", (t) => t.spanContext, "call", (t) => t()]);
    let a = Fn([c, "optionalAccess", (t) => t.traceState]) || new NH();
    const l = o[gC];
    if ((l && "string" == typeof l && (a = a.set(Nk, l)), !IW(s)))
      return { decision: Mj.NOT_RECORD, traceState: a };
    if (
      r === yr.CLIENT &&
      o[OC] &&
      (!u || Fn([c, "optionalAccess", (t) => t.isRemote]))
    )
      return { decision: Mj.NOT_RECORD, traceState: a };
    const f = u
        ? (function (t, n, e) {
            const r = t.spanContext();
            if (mr(r) && r.traceId === n) {
              if (r.isRemote) {
                const n = (function (t) {
                  const n = t.spanContext().traceId,
                    e = jk(t);
                  return e && n === e.traceId ? e.sampled : void 0;
                })(t);
                return n;
              }
              return Gk(r);
            }
            return;
          })(u, n)
        : void 0,
      d = { decision: !0 };
    if (
      (this.oe.emit(
        "beforeSampling",
        { spanAttributes: o, spanName: e, parentSampled: f, parentContext: c },
        d
      ),
      !d.decision)
    )
      return { decision: Mj.NOT_RECORD, traceState: a };
    const [h, p] = PW(s, {
        name: e,
        attributes: o,
        transactionContext: { name: e, parentSampled: f },
        parentSampled: f,
      }),
      S = { [BU]: p },
      E = `${o[OC]}`.toUpperCase();
    return "OPTIONS" === E || "HEAD" === E
      ? { decision: Mj.NOT_RECORD, attributes: S, traceState: a.set(gk, "1") }
      : h
        ? { decision: Mj.RECORD_AND_SAMPLED, attributes: S, traceState: a }
        : {
            decision: Mj.NOT_RECORD,
            attributes: S,
            traceState: a.set(gk, "1"),
          };
  }
  toString() {
    return "SentrySampler";
  }
}
function AK(...t) {
  Cx({ instrumentations: t });
}
function OK(t, n) {
  t.setAttribute(JU, n);
}
function gK(t) {
  const n = t.protocol || "",
    e = t.hostname || t.host || "";
  return `${n}//${e}${
    !t.port || 80 === t.port || 443 === t.port || /^(.*):(\d+)$/.test(e)
      ? ""
      : `:${t.port}`
  }${t.path ? t.path : "/"}`;
}
const NK = (t = {}) => {
  const n = void 0 === t.breadcrumbs || t.breadcrumbs,
    e = t.ignoreOutgoingRequests,
    r = t.ignoreIncomingRequests,
    o = t.ao || qr.HttpInstrumentation;
  return {
    name: "Http",
    setupOnce() {
      AK(
        new o({
          ignoreOutgoingRequestHook: (t) => {
            const n = gK(t);
            return !!n && (!!MY(n, GU()) || !(!e || !e(n)));
          },
          ignoreIncomingRequestHook: (t) => {
            const n = gK(t),
              e = Fn([
                t,
                "access",
                (t) => t.method,
                "optionalAccess",
                (t) => t.toUpperCase,
                "call",
                (t) => t(),
              ]);
            return "OPTIONS" === e || "HEAD" === e || !(!r || !r(n));
          },
          requireParentforOutgoingSpans: !1,
          requireParentforIncomingSpans: !1,
          requestHook: (t, n) => {
            if (
              (OK(t, "auto.http.otel.http"),
              (function (t) {
                return (
                  "outputData" in t &&
                  "outputSize" in t &&
                  !("client" in t) &&
                  !("statusCode" in t)
                );
              })(n))
            )
              return;
            const e = LW(t),
              r = (e.isolationScope || wU()).clone(),
              o = e.scope || MU();
            r.setSDKProcessingMetadata({ request: n });
            const i = GU();
            i &&
              i.getOptions().autoSessionTracking &&
              r.setRequestSession({ status: "ok" }),
              (function (t) {
                const n = Zk(Zr.active());
                n && (n.isolationScope = t);
              })(r),
              CW(t, o, r);
            const s = `${(n.method || "GET").toUpperCase()} ${cn(
              n.url || "/"
            )}`;
            r.setTransactionName(s);
          },
          responseHook: (t, e) => {
            n &&
              (function (t, n) {
                if (vk(t) !== yr.CLIENT) return;
                const e = bk(t);
                PY(
                  {
                    category: "http",
                    data: { status_code: n.statusCode, ...e },
                    type: "http",
                  },
                  { event: "response", response: n }
                );
              })(t, e);
            const r = GU();
            r &&
              r.getOptions().autoSessionTracking &&
              setImmediate(() => {
                r.ke();
              });
          },
        })
      );
    },
  };
};
const CK = (function (t) {
    const n = t.match(xt) || [],
      e = parseInt(n[1], 10),
      r = parseInt(n[2], 10),
      o = parseInt(n[3], 10);
    return {
      buildmetadata: n[5],
      major: isNaN(e) ? void 0 : e,
      minor: isNaN(r) ? void 0 : r,
      patch: isNaN(o) ? void 0 : o,
      prerelease: n[4],
    };
  })(process.versions.node),
  LK = CK.major,
  IK = (t = {}) => {
    const n = void 0 === t.breadcrumbs || t.breadcrumbs,
      e = t.ignoreOutgoingRequests;
    async function r() {
      if (!(LK < 18))
        try {
          return new (
            await Promise.resolve()
              .then(function () {
                return require("./index-BRTi_YtD.js");
              })
              .then(function (t) {
                return t.index;
              })
          ).FetchInstrumentation({
            ignoreRequestHook: (t) => {
              const n = t.origin;
              return e && n && e(n);
            },
            onRequest: ({ span: t }) => {
              !(function (t) {
                OK(t, "auto.http.otel.node_fetch");
              })(t),
                n &&
                  (function (t) {
                    if (vk(t) !== yr.CLIENT) return;
                    const n = bk(t);
                    PY({ category: "http", data: { ...n }, type: "http" });
                  })(t);
            },
          });
        } catch (t) {}
    }
    return {
      name: "NodeFetch",
      setupOnce() {
        r().then((t) => {
          t && AK(t);
        });
      },
    };
  };
const MK = () => ({
    name: "Console",
    setup(t) {
      It(({ args: n, level: e }) => {
        GU() === t &&
          PY(
            {
              category: "console",
              level: mn(e),
              message: O.format.apply(void 0, n),
            },
            { input: [...n], level: e }
          );
      });
    },
  }),
  wK = e.promisify(o.readFile),
  ZK = e.promisify(o.readdir),
  PK = (t = {}) => {
    let e;
    const r = {
      app: !0,
      os: !0,
      device: !0,
      culture: !0,
      cloudResource: !0,
      ...t,
    };
    async function o(t) {
      void 0 === e &&
        (e = (async function () {
          const t = {};
          r.os &&
            (t.os = await (async function () {
              const t = g.platform();
              switch (t) {
                case "darwin":
                  return (async function () {
                    const t = {
                      kernel_version: g.release(),
                      name: "Mac OS X",
                      version: "10." + (Number(g.release().split(".")[0]) - 4),
                    };
                    try {
                      const n = await new Promise((t, n) => {
                        a.execFile("/usr/bin/sw_vers", (e, r) => {
                          e ? n(e) : t(r);
                        });
                      });
                      (t.name = UK(/^ProductName:\s+(.*)$/m, n)),
                        (t.version = UK(/^ProductVersion:\s+(.*)$/m, n)),
                        (t.build = UK(/^BuildVersion:\s+(.*)$/m, n));
                    } catch (t) {}
                    return t;
                  })();
                case "linux":
                  return (async function () {
                    const t = { kernel_version: g.release(), name: "Linux" };
                    try {
                      const e = await ZK("/etc"),
                        r = GK.find((t) => e.includes(t.name));
                      if (!r) return t;
                      const o = n.join("/etc", r.name),
                        i = (await wK(o, { encoding: "utf-8" })).toLowerCase(),
                        { distros: s } = r;
                      t.name = s.find((t) => i.indexOf(WK(t)) >= 0) || s[0];
                      const u = WK(t.name);
                      t.version = XK[u](i);
                    } catch (t) {}
                    return t;
                  })();
                default:
                  return { name: VK[t] || t, version: g.release() };
              }
            })());
          r.app &&
            (t.app = (function () {
              const t = process.memoryUsage().rss;
              return {
                app_start_time: new Date(
                  Date.now() - 1e3 * process.uptime()
                ).toISOString(),
                app_memory: t,
              };
            })());
          r.device &&
            (t.device = (function (t) {
              const n = {};
              let e;
              try {
                e = g.uptime && g.uptime();
              } catch (t) {}
              "number" == typeof e &&
                (n.boot_time = new Date(Date.now() - 1e3 * e).toISOString());
              (n.arch = g.arch()),
                (!0 === t || t.memory) &&
                  ((n.memory_size = g.totalmem()),
                  (n.free_memory = g.freemem()));
              if (!0 === t || t.cpu) {
                const t = g.cpus();
                if (t && t.length) {
                  const e = t[0];
                  (n.processor_count = t.length),
                    (n.cpu_description = e.model),
                    (n.processor_frequency = e.speed);
                }
              }
              return n;
            })(r.device));
          if (r.culture) {
            const n = (function () {
              try {
                if ("string" != typeof process.versions.icu) return;
                const t = new Date(9e8);
                if (
                  "enero" ===
                  new Intl.DateTimeFormat("es", { month: "long" }).format(t)
                ) {
                  const t = Intl.DateTimeFormat().resolvedOptions();
                  return { locale: t.locale, timezone: t.timeZone };
                }
              } catch (t) {}
              return;
            })();
            n && (t.culture = n);
          }
          r.cloudResource &&
            (t.cloud_resource = process.env.VERCEL
              ? {
                  "cloud.provider": "vercel",
                  "cloud.region": process.env.VERCEL_REGION,
                }
              : process.env.AWS_REGION
                ? {
                    "cloud.provider": "aws",
                    "cloud.region": process.env.AWS_REGION,
                    "cloud.platform": process.env.AWS_EXECUTION_ENV,
                  }
                : process.env.GCP_PROJECT
                  ? { "cloud.provider": "gcp" }
                  : process.env.ALIYUN_REGION_ID
                    ? {
                        "cloud.provider": "alibaba_cloud",
                        "cloud.region": process.env.ALIYUN_REGION_ID,
                      }
                    : process.env.WEBSITE_SITE_NAME && process.env.REGION_NAME
                      ? {
                          "cloud.provider": "azure",
                          "cloud.region": process.env.REGION_NAME,
                        }
                      : process.env.IBM_CLOUD_REGION
                        ? {
                            "cloud.provider": "ibm_cloud",
                            "cloud.region": process.env.IBM_CLOUD_REGION,
                          }
                        : process.env.TENCENTCLOUD_REGION
                          ? {
                              "cloud.provider": "tencent_cloud",
                              "cloud.region": process.env.TENCENTCLOUD_REGION,
                              "cloud.account.id":
                                process.env.TENCENTCLOUD_APPID,
                              "cloud.availability_zone":
                                process.env.TENCENTCLOUD_ZONE,
                            }
                          : process.env.NETLIFY
                            ? { "cloud.provider": "netlify" }
                            : process.env.FLY_REGION
                              ? {
                                  "cloud.provider": "fly.io",
                                  "cloud.region": process.env.FLY_REGION,
                                }
                              : process.env.DYNO
                                ? { "cloud.provider": "heroku" }
                                : void 0);
          return t;
        })());
      const o = (function (t) {
        Fn([
          t,
          "optionalAccess",
          (t) => t.app,
          "optionalAccess",
          (t) => t.app_memory,
        ]) && (t.app.app_memory = process.memoryUsage().rss);
        Fn([
          t,
          "optionalAccess",
          (t) => t.device,
          "optionalAccess",
          (t) => t.free_memory,
        ]) && (t.device.free_memory = g.freemem());
        return t;
      })(await e);
      return (
        (t.contexts = {
          ...t.contexts,
          app: {
            ...o.app,
            ...Fn([
              t,
              "access",
              (t) => t.contexts,
              "optionalAccess",
              (t) => t.app,
            ]),
          },
          os: {
            ...o.os,
            ...Fn([
              t,
              "access",
              (t) => t.contexts,
              "optionalAccess",
              (t) => t.os,
            ]),
          },
          device: {
            ...o.device,
            ...Fn([
              t,
              "access",
              (t) => t.contexts,
              "optionalAccess",
              (t) => t.device,
            ]),
          },
          culture: {
            ...o.culture,
            ...Fn([
              t,
              "access",
              (t) => t.contexts,
              "optionalAccess",
              (t) => t.culture,
            ]),
          },
          cloud_resource: {
            ...o.cloud_resource,
            ...Fn([
              t,
              "access",
              (t) => t.contexts,
              "optionalAccess",
              (t) => t.cloud_resource,
            ]),
          },
        }),
        t
      );
    }
    return { name: "Context", processEvent: (t) => o(t) };
  };
const VK = {
    aix: "IBM AIX",
    freebsd: "FreeBSD",
    openbsd: "OpenBSD",
    sunos: "SunOS",
    win32: "Windows",
  },
  GK = [
    { name: "fedora-release", distros: ["Fedora"] },
    { name: "redhat-release", distros: ["Red Hat Linux", "Centos"] },
    { name: "redhat_version", distros: ["Red Hat Linux"] },
    { name: "SuSE-release", distros: ["SUSE Linux"] },
    { name: "lsb-release", distros: ["Ubuntu Linux", "Arch Linux"] },
    { name: "debian_version", distros: ["Debian"] },
    { name: "debian_release", distros: ["Debian"] },
    { name: "arch-release", distros: ["Arch Linux"] },
    { name: "gentoo-release", distros: ["Gentoo Linux"] },
    { name: "novell-release", distros: ["SUSE Linux"] },
    { name: "alpine-release", distros: ["Alpine Linux"] },
  ],
  XK = {
    alpine: (t) => t,
    arch: (t) => UK(/distrib_release=(.*)/, t),
    centos: (t) => UK(/release ([^ ]+)/, t),
    debian: (t) => t,
    fedora: (t) => UK(/release (..)/, t),
    mint: (t) => UK(/distrib_release=(.*)/, t),
    red: (t) => UK(/release ([^ ]+)/, t),
    suse: (t) => UK(/VERSION = (.*)\n/, t),
    ubuntu: (t) => UK(/distrib_release=(.*)/, t),
  };
function UK(t, n) {
  const e = t.exec(n);
  return e ? e[1] : void 0;
}
function WK(t) {
  return t.split(" ")[0].toLowerCase();
}
const YK = new Kn(100),
  HK = o.promises.readFile,
  DK = (t = {}) => {
    const n = void 0 !== t.frameContextLines ? t.frameContextLines : 7;
    return {
      name: "ContextLines",
      processEvent: (t) =>
        (async function (t, n) {
          const e = {},
            r = [];
          if (
            n > 0 &&
            Fn([
              t,
              "access",
              (t) => t.exception,
              "optionalAccess",
              (t) => t.values,
            ])
          )
            for (const n of t.exception.values)
              if (
                Fn([
                  n,
                  "access",
                  (t) => t.stacktrace,
                  "optionalAccess",
                  (t) => t.frames,
                ])
              )
                for (let t = n.stacktrace.frames.length - 1; t >= 0; t--) {
                  const o = n.stacktrace.frames[t];
                  !o.filename ||
                    e[o.filename] ||
                    YK.get(o.filename) ||
                    (r.push(xK(o.filename)), (e[o.filename] = 1));
                }
          r.length > 0 && (await Promise.all(r));
          if (
            n > 0 &&
            Fn([
              t,
              "access",
              (t) => t.exception,
              "optionalAccess",
              (t) => t.values,
            ])
          )
            for (const e of t.exception.values)
              e.stacktrace &&
                e.stacktrace.frames &&
                (await jK(e.stacktrace.frames, n));
          return t;
        })(t, n),
    };
  };
function jK(t, n) {
  for (const e of t)
    if (e.filename && void 0 === e.context_line) {
      const t = YK.get(e.filename);
      if (t)
        try {
          kt(t, e, n);
        } catch (t) {}
    }
}
async function xK(t) {
  const n = YK.get(t);
  if (null === n) return null;
  if (void 0 !== n) return n;
  let e = null;
  try {
    e = (await HK(t, "utf-8")).split("\n");
  } catch (t) {}
  return YK.set(t, e), e;
}
function kK(t) {
  return void 0 !== t && (0 === t.length || "?" === t || "<anonymous>" === t);
}
function KK(t, n) {
  return t === n || (kK(t) && kK(n));
}
function BK(t) {
  if (void 0 !== t)
    return t
      .slice(-10)
      .reduce((t, n) => `${t},${n.function},${n.lineno},${n.colno}`, "");
}
function FK(...t) {
  it.log("[LocalVariables]", ...t);
}
const JK = (t = {}) => {
  const n = new Kn(20);
  function e(t) {
    const e = BK(
      Fn([
        t,
        "optionalAccess",
        (t) => t.stacktrace,
        "optionalAccess",
        (t) => t.frames,
      ])
    );
    if (void 0 === e) return;
    const r = n.remove(e);
    if (void 0 === r) return;
    const o = (
      Fn([
        t,
        "access",
        (t) => t.stacktrace,
        "optionalAccess",
        (t) => t.frames,
      ]) || []
    ).filter((t) => "new Promise" !== t.function);
    for (let t = 0; t < o.length; t++) {
      const n = o.length - t - 1;
      if (!o[n] || !r[t]) break;
      void 0 !== r[t].vars &&
        !1 !== o[n].in_app &&
        KK(o[n].function, r[t].function) &&
        (o[n].vars = r[t].vars);
    }
  }
  return {
    name: "LocalVariablesAsync",
    setup(e) {
      if (!e.getOptions().includeLocalVariables) return;
      const r = { ...t, debug: it.isEnabled() };
      (async function () {
        const t = await import("inspector");
        t.url() || t.open(0);
      })().then(
        () => {
          try {
            !(function (t) {
              const e = new f.Worker(
                new URL(
                  "data:application/javascript;base64,LyohIEBzZW50cnkvbm9kZSA4LjIuMSAoOGZiZmY1OTRjKSB8IGh0dHBzOi8vZ2l0aHViLmNvbS9nZXRzZW50cnkvc2VudHJ5LWphdmFzY3JpcHQgKi8KaW1wb3J0e1Nlc3Npb24gYXMgZX1mcm9tIm5vZGU6aW5zcGVjdG9yL3Byb21pc2VzIjtpbXBvcnR7d29ya2VyRGF0YSBhcyBuLHBhcmVudFBvcnQgYXMgdH1mcm9tIndvcmtlcl90aHJlYWRzIjtpbXBvcnR7cG9zaXggYXMgbyxzZXAgYXMgcn1mcm9tInBhdGgiO2NvbnN0IGk9NTAscz0iPyIsYz0vXChlcnJvcjogKC4qKVwpLyxhPS9jYXB0dXJlTWVzc2FnZXxjYXB0dXJlRXhjZXB0aW9uLztjb25zdCB1PS9eKFxTKzpcXHxcLz8pKFtcc1xTXSo/KSgoPzpcLnsxLDJ9fFteL1xcXSs/fCkoXC5bXi4vXFxdKnwpKSg/OlsvXFxdKikkLztmdW5jdGlvbiBmKGUpe2NvbnN0IG49ZnVuY3Rpb24oZSl7Y29uc3Qgbj1lLmxlbmd0aD4xMDI0P2A8dHJ1bmNhdGVkPiR7ZS5zbGljZSgtMTAyNCl9YDplLHQ9dS5leGVjKG4pO3JldHVybiB0P3Quc2xpY2UoMSk6W119KGUpLHQ9blswXTtsZXQgbz1uWzFdO3JldHVybiB0fHxvPyhvJiYobz1vLnNsaWNlKDAsby5sZW5ndGgtMSkpLHQrbyk6Ii4ifWZ1bmN0aW9uIGwoZSxuPSExKXtyZXR1cm4hKG58fGUmJiFlLnN0YXJ0c1dpdGgoIi8iKSYmIWUubWF0Y2goL15bQS1aXTovKSYmIWUuc3RhcnRzV2l0aCgiLiIpJiYhZS5tYXRjaCgvXlthLXpBLVpdKFthLXpBLVowLTkuXC0rXSkqOlwvXC8vKSkmJnZvaWQgMCE9PWUmJiFlLmluY2x1ZGVzKCJub2RlX21vZHVsZXMvIil9ZnVuY3Rpb24gZChlKXtjb25zdCBuPS9eXHMqWy1dezQsfSQvLHQ9L2F0ICg/OmFzeW5jICk/KD86KC4rPylccytcKCk/KD86KC4rKTooXGQrKTooXGQrKT98KFteKV0rKSlcKT8vO3JldHVybiBvPT57Y29uc3Qgcj1vLm1hdGNoKHQpO2lmKHIpe2xldCBuLHQsbyxpLGM7aWYoclsxXSl7bz1yWzFdO2xldCBlPW8ubGFzdEluZGV4T2YoIi4iKTtpZigiLiI9PT1vW2UtMV0mJmUtLSxlPjApe249by5zbGljZSgwLGUpLHQ9by5zbGljZShlKzEpO2NvbnN0IHI9bi5pbmRleE9mKCIuTW9kdWxlIik7cj4wJiYobz1vLnNsaWNlKHIrMSksbj1uLnNsaWNlKDAscikpfWk9dm9pZCAwfXQmJihpPW4sYz10KSwiPGFub255bW91cz4iPT09dCYmKGM9dm9pZCAwLG89dm9pZCAwKSx2b2lkIDA9PT1vJiYoYz1jfHxzLG89aT9gJHtpfS4ke2N9YDpjKTtsZXQgYT1yWzJdJiZyWzJdLnN0YXJ0c1dpdGgoImZpbGU6Ly8iKT9yWzJdLnNsaWNlKDcpOnJbMl07Y29uc3QgdT0ibmF0aXZlIj09PXJbNV07cmV0dXJuIGEmJmEubWF0Y2goL1wvW0EtWl06LykmJihhPWEuc2xpY2UoMSkpLGF8fCFyWzVdfHx1fHwoYT1yWzVdKSx7ZmlsZW5hbWU6YSxtb2R1bGU6ZT9lKGEpOnZvaWQgMCxmdW5jdGlvbjpvLGxpbmVubzpwYXJzZUludChyWzNdLDEwKXx8dm9pZCAwLGNvbG5vOnBhcnNlSW50KHJbNF0sMTApfHx2b2lkIDAsaW5fYXBwOmwoYSx1KX19aWYoby5tYXRjaChuKSlyZXR1cm57ZmlsZW5hbWU6b319fWZ1bmN0aW9uIHAoZSl7cmV0dXJuIGUucmVwbGFjZSgvXltBLVpdOi8sIiIpLnJlcGxhY2UoL1xcL2csIi8iKX1jb25zdCBnPW4sbT1mdW5jdGlvbiguLi5lKXtjb25zdCBuPWUuc29ydCgoKGUsbik9PmVbMF0tblswXSkpLm1hcCgoZT0+ZVsxXSkpO3JldHVybihlLHQ9MCxvPTApPT57Y29uc3Qgcj1bXSx1PWUuc3BsaXQoIlxuIik7Zm9yKGxldCBlPXQ7ZTx1Lmxlbmd0aDtlKyspe2NvbnN0IHQ9dVtlXTtpZih0Lmxlbmd0aD4xMDI0KWNvbnRpbnVlO2NvbnN0IHM9Yy50ZXN0KHQpP3QucmVwbGFjZShjLCIkMSIpOnQ7aWYoIXMubWF0Y2goL1xTKkVycm9yOiAvKSl7Zm9yKGNvbnN0IGUgb2Ygbil7Y29uc3Qgbj1lKHMpO2lmKG4pe3IucHVzaChuKTticmVha319aWYoci5sZW5ndGg+PWkrbylicmVha319cmV0dXJuIGZ1bmN0aW9uKGUpe2lmKCFlLmxlbmd0aClyZXR1cm5bXTtjb25zdCBuPUFycmF5LmZyb20oZSk7L3NlbnRyeVdyYXBwZWQvLnRlc3QobltuLmxlbmd0aC0xXS5mdW5jdGlvbnx8IiIpJiZuLnBvcCgpO24ucmV2ZXJzZSgpLGEudGVzdChuW24ubGVuZ3RoLTFdLmZ1bmN0aW9ufHwiIikmJihuLnBvcCgpLGEudGVzdChuW24ubGVuZ3RoLTFdLmZ1bmN0aW9ufHwiIikmJm4ucG9wKCkpO3JldHVybiBuLnNsaWNlKDAsaSkubWFwKChlPT4oey4uLmUsZmlsZW5hbWU6ZS5maWxlbmFtZXx8bltuLmxlbmd0aC0xXS5maWxlbmFtZSxmdW5jdGlvbjplLmZ1bmN0aW9ufHxzfSkpKX0oci5zbGljZShvKSl9fShbOTAsZChmdW5jdGlvbihlPShwcm9jZXNzLmFyZ3ZbMV0/Zihwcm9jZXNzLmFyZ3ZbMV0pOnByb2Nlc3MuY3dkKCkpLG49IlxcIj09PXIpe2NvbnN0IHQ9bj9wKGUpOmU7cmV0dXJuIGU9PntpZighZSlyZXR1cm47Y29uc3Qgcj1uP3AoZSk6ZTtsZXR7ZGlyOmksYmFzZTpzLGV4dDpjfT1vLnBhcnNlKHIpOyIuanMiIT09YyYmIi5tanMiIT09YyYmIi5janMiIT09Y3x8KHM9cy5zbGljZSgwLC0xKmMubGVuZ3RoKSksaXx8KGk9Ii4iKTtjb25zdCBhPWkubGFzdEluZGV4T2YoIi9ub2RlX21vZHVsZXMiKTtpZihhPi0xKXJldHVybmAke2kuc2xpY2UoYSsxNCkucmVwbGFjZSgvXC8vZywiLiIpfToke3N9YDtpZihpLnN0YXJ0c1dpdGgodCkpe2xldCBlPWkuc2xpY2UodC5sZW5ndGgrMSkucmVwbGFjZSgvXC8vZywiLiIpO3JldHVybiBlJiYoZSs9IjoiKSxlKz1zLGV9cmV0dXJuIHN9fShnLmJhc2VQYXRoKSldKTtmdW5jdGlvbiBiKC4uLmUpe2cuZGVidWcmJmNvbnNvbGUubG9nKCJbTG9jYWxWYXJpYWJsZXMgV29ya2VyXSIsLi4uZSl9YXN5bmMgZnVuY3Rpb24gdihlLG4sdCxvKXtjb25zdCByPWF3YWl0IGUucG9zdCgiUnVudGltZS5nZXRQcm9wZXJ0aWVzIix7b2JqZWN0SWQ6bixvd25Qcm9wZXJ0aWVzOiEwfSk7b1t0XT1yLnJlc3VsdC5maWx0ZXIoKGU9PiJsZW5ndGgiIT09ZS5uYW1lJiYhaXNOYU4ocGFyc2VJbnQoZS5uYW1lLDEwKSkpKS5zb3J0KCgoZSxuKT0+cGFyc2VJbnQoZS5uYW1lLDEwKS1wYXJzZUludChuLm5hbWUsMTApKSkubWFwKChlPT5lLnZhbHVlPy52YWx1ZSkpfWFzeW5jIGZ1bmN0aW9uICQoZSxuLHQsbyl7Y29uc3Qgcj1hd2FpdCBlLnBvc3QoIlJ1bnRpbWUuZ2V0UHJvcGVydGllcyIse29iamVjdElkOm4sb3duUHJvcGVydGllczohMH0pO29bdF09ci5yZXN1bHQubWFwKChlPT5bZS5uYW1lLGUudmFsdWU/LnZhbHVlXSkpLnJlZHVjZSgoKGUsW24sdF0pPT4oZVtuXT10LGUpKSx7fSl9ZnVuY3Rpb24gdyhlLG4pe2UudmFsdWUmJigidmFsdWUiaW4gZS52YWx1ZT92b2lkIDA9PT1lLnZhbHVlLnZhbHVlfHxudWxsPT09ZS52YWx1ZS52YWx1ZT9uW2UubmFtZV09YDwke2UudmFsdWUudmFsdWV9PmA6bltlLm5hbWVdPWUudmFsdWUudmFsdWU6ImRlc2NyaXB0aW9uImluIGUudmFsdWUmJiJmdW5jdGlvbiIhPT1lLnZhbHVlLnR5cGU/bltlLm5hbWVdPWA8JHtlLnZhbHVlLmRlc2NyaXB0aW9ufT5gOiJ1bmRlZmluZWQiPT09ZS52YWx1ZS50eXBlJiYobltlLm5hbWVdPSI8dW5kZWZpbmVkPiIpKX1hc3luYyBmdW5jdGlvbiB5KGUsbil7Y29uc3QgdD1hd2FpdCBlLnBvc3QoIlJ1bnRpbWUuZ2V0UHJvcGVydGllcyIse29iamVjdElkOm4sb3duUHJvcGVydGllczohMH0pLG89e307Zm9yKGNvbnN0IG4gb2YgdC5yZXN1bHQpaWYobj8udmFsdWU/Lm9iamVjdElkJiYiQXJyYXkiPT09bj8udmFsdWUuY2xhc3NOYW1lKXtjb25zdCB0PW4udmFsdWUub2JqZWN0SWQ7YXdhaXQgdihlLHQsbi5uYW1lLG8pfWVsc2UgaWYobj8udmFsdWU/Lm9iamVjdElkJiYiT2JqZWN0Ij09PW4/LnZhbHVlPy5jbGFzc05hbWUpe2NvbnN0IHQ9bi52YWx1ZS5vYmplY3RJZDthd2FpdCAkKGUsdCxuLm5hbWUsbyl9ZWxzZSBuPy52YWx1ZSYmdyhuLG8pO3JldHVybiBvfWxldCBoOyhhc3luYyBmdW5jdGlvbigpe2NvbnN0IG49bmV3IGU7bi5jb25uZWN0VG9NYWluVGhyZWFkKCksYigiQ29ubmVjdGVkIHRvIG1haW4gdGhyZWFkIik7bGV0IG89ITE7bi5vbigiRGVidWdnZXIucmVzdW1lZCIsKCgpPT57bz0hMX0pKSxuLm9uKCJEZWJ1Z2dlci5wYXVzZWQiLChlPT57bz0hMCxhc3luYyBmdW5jdGlvbihlLG4se3JlYXNvbjpvLGRhdGE6cixjYWxsRnJhbWVzOml9KXtpZigiZXhjZXB0aW9uIiE9PW8mJiJwcm9taXNlUmVqZWN0aW9uIiE9PW8pcmV0dXJuO2g/LigpO2NvbnN0IHM9ZnVuY3Rpb24oZSxuKXtpZih2b2lkIDAhPT1uKXJldHVybiBmdW5jdGlvbihlKXtpZih2b2lkIDAhPT1lKXJldHVybiBlLnNsaWNlKC0xMCkucmVkdWNlKCgoZSxuKT0+YCR7ZX0sJHtuLmZ1bmN0aW9ufSwke24ubGluZW5vfSwke24uY29sbm99YCksIiIpfShlKG4sMSkpfShuLHI/LmRlc2NyaXB0aW9uKTtpZihudWxsPT1zKXJldHVybjtjb25zdCBjPVtdO2ZvcihsZXQgbj0wO248aS5sZW5ndGg7bisrKXtjb25zdHtzY29wZUNoYWluOnQsZnVuY3Rpb25OYW1lOm8sdGhpczpyfT1pW25dLHM9dC5maW5kKChlPT4ibG9jYWwiPT09ZS50eXBlKSksYT0iZ2xvYmFsIiE9PXIuY2xhc3NOYW1lJiZyLmNsYXNzTmFtZT9gJHtyLmNsYXNzTmFtZX0uJHtvfWA6bztpZih2b2lkIDA9PT1zPy5vYmplY3Qub2JqZWN0SWQpY1tuXT17ZnVuY3Rpb246YX07ZWxzZXtjb25zdCB0PWF3YWl0IHkoZSxzLm9iamVjdC5vYmplY3RJZCk7Y1tuXT17ZnVuY3Rpb246YSx2YXJzOnR9fX10Py5wb3N0TWVzc2FnZSh7ZXhjZXB0aW9uSGFzaDpzLGZyYW1lczpjfSl9KG4sbSxlLnBhcmFtcykudGhlbigoKCk9Pm8/bi5wb3N0KCJEZWJ1Z2dlci5yZXN1bWUiKTpQcm9taXNlLnJlc29sdmUoKSksKGU9Pnt9KSl9KSksYXdhaXQgbi5wb3N0KCJEZWJ1Z2dlci5lbmFibGUiKTtjb25zdCByPSExIT09Zy5jYXB0dXJlQWxsRXhjZXB0aW9ucztpZihhd2FpdCBuLnBvc3QoIkRlYnVnZ2VyLnNldFBhdXNlT25FeGNlcHRpb25zIix7c3RhdGU6cj8iYWxsIjoidW5jYXVnaHQifSkscil7Y29uc3QgZT1nLm1heEV4Y2VwdGlvbnNQZXJTZWNvbmR8fDUwO2g9ZnVuY3Rpb24oZSxuLHQpe2xldCBvPTAscj01LGk9MDtyZXR1cm4gc2V0SW50ZXJ2YWwoKCgpPT57MD09PWk/bz5lJiYocio9Mix0KHIpLHI+ODY0MDAmJihyPTg2NDAwKSxpPXIpOihpLT0xLDA9PT1pJiZuKCkpLG89MH0pLDFlMykudW5yZWYoKSwoKT0+e28rPTF9fShlLChhc3luYygpPT57YigiUmF0ZS1saW1pdCBsaWZ0ZWQuIiksYXdhaXQgbi5wb3N0KCJEZWJ1Z2dlci5zZXRQYXVzZU9uRXhjZXB0aW9ucyIse3N0YXRlOiJhbGwifSl9KSwoYXN5bmMgZT0+e2IoYFJhdGUtbGltaXQgZXhjZWVkZWQuIERpc2FibGluZyBjYXB0dXJpbmcgb2YgY2F1Z2h0IGV4Y2VwdGlvbnMgZm9yICR7ZX0gc2Vjb25kcy5gKSxhd2FpdCBuLnBvc3QoIkRlYnVnZ2VyLnNldFBhdXNlT25FeGNlcHRpb25zIix7c3RhdGU6InVuY2F1Z2h0In0pfSkpfX0pKCkuY2F0Y2goKGU9PntiKCJGYWlsZWQgdG8gc3RhcnQgZGVidWdnZXIiLGUpfSkpLHNldEludGVydmFsKCgoKT0+e30pLDFlNCk7"
                ),
                { workerData: t, execArgv: [] }
              );
              process.on("exit", () => {
                e.terminate();
              }),
                e.on("message", ({ exceptionHash: t, frames: e }) => {
                  n.set(t, e);
                }),
                e.once("error", (t) => {
                  FK("Worker error", t);
                }),
                e.once("exit", (t) => {
                  FK("Worker exit", t);
                }),
                e.unref();
            })(r);
          } catch (t) {
            it.error("Failed to start worker", t);
          }
        },
        (t) => {
          it.error("Failed to start inspector", t);
        }
      );
    },
    processEvent: (t) =>
      (function (t) {
        for (const n of Fn([
          t,
          "access",
          (t) => t.exception,
          "optionalAccess",
          (t) => t.values,
        ]) || [])
          e(n);
        return t;
      })(t),
  };
};
function zK(t) {
  let n = [],
    e = !1;
  function r(r) {
    (n = []), e || ((e = !0), t(r));
  }
  return (
    n.push(r),
    {
      add: function (t) {
        n.push(t);
      },
      next: function (t) {
        const e = n.pop() || r;
        try {
          e(t);
        } catch (n) {
          r(t);
        }
      },
    }
  );
}
class QK {
  constructor() {
    this.qn = new d.Session();
  }
  configureAndConnect(t, n) {
    this.qn.connect(),
      this.qn.on("Debugger.paused", (n) => {
        t(n, () => {
          this.qn.post("Debugger.resume");
        });
      }),
      this.qn.post("Debugger.enable"),
      this.qn.post("Debugger.setPauseOnExceptions", {
        state: n ? "all" : "uncaught",
      });
  }
  setPauseOnExceptions(t) {
    this.qn.post("Debugger.setPauseOnExceptions", {
      state: t ? "all" : "uncaught",
    });
  }
  getLocalVariables(t, n) {
    this.lo(t, (t) => {
      const { add: e, next: r } = zK(n);
      for (const n of t)
        if (
          Fn([
            n,
            "optionalAccess",
            (t) => t.value,
            "optionalAccess",
            (t) => t.objectId,
          ]) &&
          "Array" ===
            Fn([
              n,
              "optionalAccess",
              (t) => t.value,
              "access",
              (t) => t.className,
            ])
        ) {
          const t = n.value.objectId;
          e((e) => this.fo(t, n.name, e, r));
        } else if (
          Fn([
            n,
            "optionalAccess",
            (t) => t.value,
            "optionalAccess",
            (t) => t.objectId,
          ]) &&
          "Object" ===
            Fn([
              n,
              "optionalAccess",
              (t) => t.value,
              "optionalAccess",
              (t) => t.className,
            ])
        ) {
          const t = n.value.objectId;
          e((e) => this.do(t, n.name, e, r));
        } else
          Fn([n, "optionalAccess", (t) => t.value]) &&
            e((t) => this.ho(n, t, r));
      r({});
    });
  }
  lo(t, n) {
    this.qn.post(
      "Runtime.getProperties",
      { objectId: t, ownProperties: !0 },
      (t, e) => {
        n(t ? [] : e.result);
      }
    );
  }
  fo(t, n, e, r) {
    this.lo(t, (t) => {
      (e[n] = t
        .filter((t) => "length" !== t.name && !isNaN(parseInt(t.name, 10)))
        .sort((t, n) => parseInt(t.name, 10) - parseInt(n.name, 10))
        .map((t) =>
          Fn([
            t,
            "optionalAccess",
            (t) => t.value,
            "optionalAccess",
            (t) => t.value,
          ])
        )),
        r(e);
    });
  }
  do(t, n, e, r) {
    this.lo(t, (t) => {
      (e[n] = t
        .map((t) => [
          t.name,
          Fn([
            t,
            "optionalAccess",
            (t) => t.value,
            "optionalAccess",
            (t) => t.value,
          ]),
        ])
        .reduce((t, [n, e]) => ((t[n] = e), t), {})),
        r(e);
    });
  }
  ho(t, n, e) {
    t.value &&
      ("value" in t.value
        ? void 0 === t.value.value || null === t.value.value
          ? (n[t.name] = `<${t.value.value}>`)
          : (n[t.name] = t.value.value)
        : "description" in t.value && "function" !== t.value.type
          ? (n[t.name] = `<${t.value.description}>`)
          : "undefined" === t.value.type && (n[t.name] = "<undefined>")),
      e(n);
  }
}
const $K = (
    t = {},
    n = (function () {
      try {
        return new QK();
      } catch (t) {
        return;
      }
    })()
  ) => {
    const e = new Kn(20);
    let r,
      o = !1;
    function i(t, { params: { reason: o, data: i, callFrames: s } }, u) {
      if ("exception" !== o && "promiseRejection" !== o) return void u();
      Fn([r, "optionalCall", (t) => t()]);
      const c = (function (t, n) {
        if (void 0 !== n) return BK(t(n, 1));
      })(t, Fn([i, "optionalAccess", (t) => t.description]));
      if (null == c) return void u();
      const { add: a, next: l } = zK((t) => {
        e.set(c, t), u();
      });
      for (let t = 0; t < Math.min(s.length, 5); t++) {
        const { scopeChain: e, functionName: r, this: o } = s[t],
          i = e.find((t) => "local" === t.type),
          u =
            "global" !== o.className && o.className ? `${o.className}.${r}` : r;
        if (
          void 0 ===
          Fn([
            i,
            "optionalAccess",
            (t) => t.object,
            "access",
            (t) => t.objectId,
          ])
        )
          a((n) => {
            (n[t] = { function: u }), l(n);
          });
        else {
          const e = i.object.objectId;
          a((r) =>
            Fn([
              n,
              "optionalAccess",
              (t) => t.getLocalVariables,
              "call",
              (n) =>
                n(e, (n) => {
                  (r[t] = { function: u, vars: n }), l(r);
                }),
            ])
          );
        }
      }
      l([]);
    }
    function s(t) {
      const n = BK(
        Fn([
          t,
          "optionalAccess",
          (t) => t.stacktrace,
          "optionalAccess",
          (t) => t.frames,
        ])
      );
      if (void 0 === n) return;
      const r = e.remove(n);
      if (void 0 === r) return;
      const o = (
        Fn([
          t,
          "access",
          (t) => t.stacktrace,
          "optionalAccess",
          (t) => t.frames,
        ]) || []
      ).filter((t) => "new Promise" !== t.function);
      for (let t = 0; t < o.length; t++) {
        const n = o.length - t - 1;
        if (!o[n] || !r[t]) break;
        void 0 !== r[t].vars &&
          !1 !== o[n].in_app &&
          KK(o[n].function, r[t].function) &&
          (o[n].vars = r[t].vars);
      }
    }
    return {
      name: "LocalVariables",
      setupOnce() {
        const e = Fn([
          GU(),
          "optionalAccess",
          (t) => t.getOptions,
          "call",
          (t) => t(),
        ]);
        if (n && Fn([e, "optionalAccess", (t) => t.includeLocalVariables])) {
          if (LK < 18)
            return void it.log(
              "The `LocalVariables` integration is only supported on Node >= v18."
            );
          const s = !1 !== t.captureAllExceptions;
          if ((n.configureAndConnect((t, n) => i(e.stackParser, t, n), s), s)) {
            const e = t.maxExceptionsPerSecond || 50;
            r = (function (t, n, e) {
              let r = 0,
                o = 5,
                i = 0;
              return (
                setInterval(() => {
                  0 === i
                    ? r > t &&
                      ((o *= 2), e(o), o > 86400 && (o = 86400), (i = o))
                    : ((i -= 1), 0 === i && n()),
                    (r = 0);
                }, 1e3).unref(),
                () => {
                  r += 1;
                }
              );
            })(
              e,
              () => {
                it.log("Local variables rate-limit lifted."),
                  Fn([
                    n,
                    "optionalAccess",
                    (t) => t.setPauseOnExceptions,
                    "call",
                    (t) => t(!0),
                  ]);
              },
              (t) => {
                it.log(
                  `Local variables rate-limit exceeded. Disabling capturing of caught exceptions for ${t} seconds.`
                ),
                  Fn([
                    n,
                    "optionalAccess",
                    (t) => t.setPauseOnExceptions,
                    "call",
                    (t) => t(!1),
                  ]);
              }
            );
          }
          o = !0;
        }
      },
      processEvent: (t) =>
        o
          ? (function (t) {
              for (const n of Fn([
                t,
                "optionalAccess",
                (t) => t.exception,
                "optionalAccess",
                (t) => t.values,
              ]) || [])
                s(n);
              return t;
            })(t)
          : t,
      po: () => e.size,
      So: () => e.values()[0],
    };
  },
  qK = (t = {}) => (CK.major < 19 ? $K(t) : JK(t));
let tB;
const nB = () => ({
  name: "Modules",
  processEvent: (t) => ((t.modules = { ...t.modules, ...rB() }), t),
});
function eB() {
  const t = (require.main && require.main.paths) || [],
    e = (function () {
      try {
        return require.cache ? Object.keys(require.cache) : [];
      } catch (t) {
        return [];
      }
    })(),
    r = {},
    i = {};
  return (
    e.forEach((e) => {
      let s = e;
      const u = () => {
        const e = s;
        if (((s = n.dirname(e)), !s || e === s || i[e])) return;
        if (t.indexOf(s) < 0) return u();
        const c = n.join(e, "package.json");
        if (((i[e] = !0), !o.existsSync(c))) return u();
        try {
          const t = JSON.parse(o.readFileSync(c, "utf8"));
          r[t.name] = t.version;
        } catch (t) {}
      };
      u();
    }),
    r
  );
}
function rB() {
  return tB || (tB = eB()), tB;
}
const oB = 2e3;
function iB(t) {
  ot(() => {
    console.error(t);
  });
  const n = GU();
  if (void 0 === n) return void global.process.exit(1);
  const e = n.getOptions(),
    r =
      (e && e.shutdownTimeout && e.shutdownTimeout > 0 && e.shutdownTimeout) ||
      oB;
  n.close(r).then(
    (t) => {
      global.process.exit(1);
    },
    (t) => {}
  );
}
const sB = (t = {}) => {
  const n = { exitEvenIfOtherHandlersAreRegistered: !1, ...t };
  return {
    name: "OnUncaughtException",
    setup(t) {
      global.process.on(
        "uncaughtException",
        (function (t, n) {
          const e = 2e3;
          let r,
            o = !1,
            i = !1,
            s = !1;
          const u = t.getOptions();
          return Object.assign(
            (c) => {
              let a = iB;
              n.onFatalError
                ? (a = n.onFatalError)
                : u.onFatalError && (a = u.onFatalError);
              const l =
                  0 ===
                  global.process
                    .listeners("uncaughtException")
                    .filter(
                      (t) =>
                        "domainUncaughtExceptionClear" !== t.name &&
                        "sentry_tracingErrorCallback" !== t.tag &&
                        !0 !== t.Eo
                    ).length,
                f = n.exitEvenIfOtherHandlersAreRegistered || l;
              o
                ? f &&
                  (s
                    ? iB(c)
                    : i ||
                      ((i = !0),
                      setTimeout(() => {
                        s || ((s = !0), a(r, c));
                      }, e)))
                : ((r = c),
                  (o = !0),
                  GU() === t &&
                    captureException(c, {
                      originalException: c,
                      captureContext: { level: "fatal" },
                      mechanism: { handled: !1, type: "onuncaughtexception" },
                    }),
                  !s && f && ((s = !0), a(c)));
            },
            { Eo: !0 }
          );
        })(t, n)
      );
    },
  };
};
const uB = (t = {}) => {
  const n = t.mode || "warn";
  return {
    name: "OnUnhandledRejection",
    setup(t) {
      global.process.on(
        "unhandledRejection",
        (function (t, n) {
          return function (e, r) {
            GU() === t &&
              (captureException(e, {
                originalException: r,
                captureContext: { extra: { unhandledPromiseRejection: !0 } },
                mechanism: { handled: !1, type: "onunhandledrejection" },
              }),
              (function (t, n) {
                const e =
                  "This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). The promise rejected with the reason:";
                "warn" === n.mode
                  ? ot(() => {
                      console.warn(e),
                        console.error(t && t.stack ? t.stack : t);
                    })
                  : "strict" === n.mode &&
                    (ot(() => {
                      console.warn(e);
                    }),
                    iB(t));
              })(e, n));
          };
        })(t, { mode: n })
      );
    },
  };
};
const cB =
  "LyohIEBzZW50cnkvbm9kZSA4LjIuMSAoOGZiZmY1OTRjKSB8IGh0dHBzOi8vZ2l0aHViLmNvbS9nZXRzZW50cnkvc2VudHJ5LWphdmFzY3JpcHQgKi8KaW1wb3J0e1Nlc3Npb24gYXMgdH1mcm9tImluc3BlY3RvciI7aW1wb3J0e3BhcmVudFBvcnQgYXMgZSx3b3JrZXJEYXRhIGFzIG59ZnJvbSJ3b3JrZXJfdGhyZWFkcyI7aW1wb3J0e3Bvc2l4IGFzIHIsc2VwIGFzIG99ZnJvbSJwYXRoIjtpbXBvcnQqYXMgcyBmcm9tIm5vZGU6aHR0cCI7aW1wb3J0KmFzIGkgZnJvbSJub2RlOmh0dHBzIjtpbXBvcnR7UmVhZGFibGUgYXMgY31mcm9tInN0cmVhbSI7aW1wb3J0e2NyZWF0ZUd6aXAgYXMgdX1mcm9tInpsaWIiO2ltcG9ydCphcyBhIGZyb20ibmV0IjtpbXBvcnQqYXMgZiBmcm9tInRscyI7aW1wb3J0KmFzIGggZnJvbSJodHRwIjtjb25zdCBwPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7ZnVuY3Rpb24gbCh0LGUpe3JldHVybiBwLmNhbGwodCk9PT1gW29iamVjdCAke2V9XWB9ZnVuY3Rpb24gZCh0KXtyZXR1cm4gbCh0LCJPYmplY3QiKX1mdW5jdGlvbiBtKHQpe3JldHVybiBCb29sZWFuKHQmJnQudGhlbiYmImZ1bmN0aW9uIj09dHlwZW9mIHQudGhlbil9ZnVuY3Rpb24gZyh0LGUpe3RyeXtyZXR1cm4gdCBpbnN0YW5jZW9mIGV9Y2F0Y2godCl7cmV0dXJuITF9fWNvbnN0IHk9Z2xvYmFsVGhpcztmdW5jdGlvbiBiKHQsZSxuKXtjb25zdCByPW58fHksbz1yLl9fU0VOVFJZX189ci5fX1NFTlRSWV9ffHx7fTtyZXR1cm4gb1t0XXx8KG9bdF09ZSgpKX1jb25zdCB2PXksXz04MDtmdW5jdGlvbiB3KHQsZSl7Y29uc3Qgbj10LHI9W107bGV0IG8scyxpLGMsdTtpZighbnx8IW4udGFnTmFtZSlyZXR1cm4iIjtpZih2LkhUTUxFbGVtZW50JiZuIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQmJm4uZGF0YXNldCl7aWYobi5kYXRhc2V0LnNlbnRyeUNvbXBvbmVudClyZXR1cm4gbi5kYXRhc2V0LnNlbnRyeUNvbXBvbmVudDtpZihuLmRhdGFzZXQuc2VudHJ5RWxlbWVudClyZXR1cm4gbi5kYXRhc2V0LnNlbnRyeUVsZW1lbnR9ci5wdXNoKG4udGFnTmFtZS50b0xvd2VyQ2FzZSgpKTtjb25zdCBhPWUmJmUubGVuZ3RoP2UuZmlsdGVyKCh0PT5uLmdldEF0dHJpYnV0ZSh0KSkpLm1hcCgodD0+W3Qsbi5nZXRBdHRyaWJ1dGUodCldKSk6bnVsbDtpZihhJiZhLmxlbmd0aClhLmZvckVhY2goKHQ9PntyLnB1c2goYFske3RbMF19PSIke3RbMV19Il1gKX0pKTtlbHNlIGlmKG4uaWQmJnIucHVzaChgIyR7bi5pZH1gKSxvPW4uY2xhc3NOYW1lLG8mJmwobywiU3RyaW5nIikpZm9yKHM9by5zcGxpdCgvXHMrLyksdT0wO3U8cy5sZW5ndGg7dSsrKXIucHVzaChgLiR7c1t1XX1gKTtjb25zdCBmPVsiYXJpYS1sYWJlbCIsInR5cGUiLCJuYW1lIiwidGl0bGUiLCJhbHQiXTtmb3IodT0wO3U8Zi5sZW5ndGg7dSsrKWk9Zlt1XSxjPW4uZ2V0QXR0cmlidXRlKGkpLGMmJnIucHVzaChgWyR7aX09IiR7Y30iXWApO3JldHVybiByLmpvaW4oIiIpfWNvbnN0IFM9InVuZGVmaW5lZCI9PXR5cGVvZiBfX1NFTlRSWV9ERUJVR19ffHxfX1NFTlRSWV9ERUJVR19fLCQ9WyJkZWJ1ZyIsImluZm8iLCJ3YXJuIiwiZXJyb3IiLCJsb2ciLCJhc3NlcnQiLCJ0cmFjZSJdLEU9e307ZnVuY3Rpb24geCh0KXtpZighKCJjb25zb2xlImluIHkpKXJldHVybiB0KCk7Y29uc3QgZT15LmNvbnNvbGUsbj17fSxyPU9iamVjdC5rZXlzKEUpO3IuZm9yRWFjaCgodD0+e2NvbnN0IHI9RVt0XTtuW3RdPWVbdF0sZVt0XT1yfSkpO3RyeXtyZXR1cm4gdCgpfWZpbmFsbHl7ci5mb3JFYWNoKCh0PT57ZVt0XT1uW3RdfSkpfX1jb25zdCBOPWZ1bmN0aW9uKCl7bGV0IHQ9ITE7Y29uc3QgZT17ZW5hYmxlOigpPT57dD0hMH0sZGlzYWJsZTooKT0+e3Q9ITF9LGlzRW5hYmxlZDooKT0+dH07cmV0dXJuIFM/JC5mb3JFYWNoKChuPT57ZVtuXT0oLi4uZSk9Pnt0JiZ4KCgoKT0+e3kuY29uc29sZVtuXShgU2VudHJ5IExvZ2dlciBbJHtufV06YCwuLi5lKX0pKX19KSk6JC5mb3JFYWNoKCh0PT57ZVt0XT0oKT0+e319KSksZX0oKTtmdW5jdGlvbiBrKHQsZT0hMSl7Y29uc3R7aG9zdDpuLHBhdGg6cixwYXNzOm8scG9ydDpzLHByb2plY3RJZDppLHByb3RvY29sOmMscHVibGljS2V5OnV9PXQ7cmV0dXJuYCR7Y306Ly8ke3V9JHtlJiZvP2A6JHtvfWA6IiJ9QCR7bn0ke3M/YDoke3N9YDoiIn0vJHtyP2Ake3J9L2A6cn0ke2l9YH1jbGFzcyBDIGV4dGVuZHMgRXJyb3J7Y29uc3RydWN0b3IodCxlPSJ3YXJuIil7c3VwZXIodCksdGhpcy5tZXNzYWdlPXQsdGhpcy5uYW1lPW5ldy50YXJnZXQucHJvdG90eXBlLmNvbnN0cnVjdG9yLm5hbWUsT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsbmV3LnRhcmdldC5wcm90b3R5cGUpLHRoaXMubG9nTGV2ZWw9ZX19ZnVuY3Rpb24gRCh0KXtpZihmdW5jdGlvbih0KXtzd2l0Y2gocC5jYWxsKHQpKXtjYXNlIltvYmplY3QgRXJyb3JdIjpjYXNlIltvYmplY3QgRXhjZXB0aW9uXSI6Y2FzZSJbb2JqZWN0IERPTUV4Y2VwdGlvbl0iOnJldHVybiEwO2RlZmF1bHQ6cmV0dXJuIGcodCxFcnJvcil9fSh0KSlyZXR1cm57bWVzc2FnZTp0Lm1lc3NhZ2UsbmFtZTp0Lm5hbWUsc3RhY2s6dC5zdGFjaywuLi5PKHQpfTtpZihlPXQsInVuZGVmaW5lZCIhPXR5cGVvZiBFdmVudCYmZyhlLEV2ZW50KSl7Y29uc3QgZT17dHlwZTp0LnR5cGUsdGFyZ2V0OlQodC50YXJnZXQpLGN1cnJlbnRUYXJnZXQ6VCh0LmN1cnJlbnRUYXJnZXQpLC4uLk8odCl9O3JldHVybiJ1bmRlZmluZWQiIT10eXBlb2YgQ3VzdG9tRXZlbnQmJmcodCxDdXN0b21FdmVudCkmJihlLmRldGFpbD10LmRldGFpbCksZX1yZXR1cm4gdDt2YXIgZX1mdW5jdGlvbiBUKHQpe3RyeXtyZXR1cm4gZT10LCJ1bmRlZmluZWQiIT10eXBlb2YgRWxlbWVudCYmZyhlLEVsZW1lbnQpP2Z1bmN0aW9uKHQsZT17fSl7aWYoIXQpcmV0dXJuIjx1bmtub3duPiI7dHJ5e2xldCBuPXQ7Y29uc3Qgcj01LG89W107bGV0IHM9MCxpPTA7Y29uc3QgYz0iID4gIix1PWMubGVuZ3RoO2xldCBhO2NvbnN0IGY9QXJyYXkuaXNBcnJheShlKT9lOmUua2V5QXR0cnMsaD0hQXJyYXkuaXNBcnJheShlKSYmZS5tYXhTdHJpbmdMZW5ndGh8fF87Zm9yKDtuJiZzKys8ciYmKGE9dyhuLGYpLCEoImh0bWwiPT09YXx8cz4xJiZpK28ubGVuZ3RoKnUrYS5sZW5ndGg+PWgpKTspby5wdXNoKGEpLGkrPWEubGVuZ3RoLG49bi5wYXJlbnROb2RlO3JldHVybiBvLnJldmVyc2UoKS5qb2luKGMpfWNhdGNoKHQpe3JldHVybiI8dW5rbm93bj4ifX0odCk6T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpfWNhdGNoKHQpe3JldHVybiI8dW5rbm93bj4ifXZhciBlfWZ1bmN0aW9uIE8odCl7aWYoIm9iamVjdCI9PXR5cGVvZiB0JiZudWxsIT09dCl7Y29uc3QgZT17fTtmb3IoY29uc3QgbiBpbiB0KU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG4pJiYoZVtuXT10W25dKTtyZXR1cm4gZX1yZXR1cm57fX1mdW5jdGlvbiBqKHQpe3JldHVybiBSKHQsbmV3IE1hcCl9ZnVuY3Rpb24gUih0LGUpe2lmKGZ1bmN0aW9uKHQpe2lmKCFkKHQpKXJldHVybiExO3RyeXtjb25zdCBlPU9iamVjdC5nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3Rvci5uYW1lO3JldHVybiFlfHwiT2JqZWN0Ij09PWV9Y2F0Y2godCl7cmV0dXJuITB9fSh0KSl7Y29uc3Qgbj1lLmdldCh0KTtpZih2b2lkIDAhPT1uKXJldHVybiBuO2NvbnN0IHI9e307ZS5zZXQodCxyKTtmb3IoY29uc3QgbiBvZiBPYmplY3Qua2V5cyh0KSl2b2lkIDAhPT10W25dJiYocltuXT1SKHRbbl0sZSkpO3JldHVybiByfWlmKEFycmF5LmlzQXJyYXkodCkpe2NvbnN0IG49ZS5nZXQodCk7aWYodm9pZCAwIT09bilyZXR1cm4gbjtjb25zdCByPVtdO3JldHVybiBlLnNldCh0LHIpLHQuZm9yRWFjaCgodD0+e3IucHVzaChSKHQsZSkpfSkpLHJ9cmV0dXJuIHR9Y29uc3QgQT01MCxJPSI/IixQPS9jYXB0dXJlTWVzc2FnZXxjYXB0dXJlRXhjZXB0aW9uLztjb25zdCBVPSI8YW5vbnltb3VzPiI7Y29uc3QgTT0xZTM7ZnVuY3Rpb24gTCgpe3JldHVybiBEYXRlLm5vdygpL019Y29uc3QgQj1mdW5jdGlvbigpe2NvbnN0e3BlcmZvcm1hbmNlOnR9PXk7aWYoIXR8fCF0Lm5vdylyZXR1cm4gTDtjb25zdCBlPURhdGUubm93KCktdC5ub3coKSxuPW51bGw9PXQudGltZU9yaWdpbj9lOnQudGltZU9yaWdpbjtyZXR1cm4oKT0+KG4rdC5ub3coKSkvTX0oKTtmdW5jdGlvbiBHKCl7Y29uc3QgdD15LGU9dC5jcnlwdG98fHQubXNDcnlwdG87bGV0IG49KCk9PjE2Kk1hdGgucmFuZG9tKCk7dHJ5e2lmKGUmJmUucmFuZG9tVVVJRClyZXR1cm4gZS5yYW5kb21VVUlEKCkucmVwbGFjZSgvLS9nLCIiKTtlJiZlLmdldFJhbmRvbVZhbHVlcyYmKG49KCk9Pntjb25zdCB0PW5ldyBVaW50OEFycmF5KDEpO3JldHVybiBlLmdldFJhbmRvbVZhbHVlcyh0KSx0WzBdfSl9Y2F0Y2godCl7fXJldHVybihbMWU3XSsxZTMrNGUzKzhlMysxZTExKS5yZXBsYWNlKC9bMDE4XS9nLCh0PT4odF4oMTUmbigpKT4+dC80KS50b1N0cmluZygxNikpKX1mdW5jdGlvbiBKKHQsZT0xMDAsbj0xLzApe3RyeXtyZXR1cm4geigiIix0LGUsbil9Y2F0Y2godCl7cmV0dXJue0VSUk9SOmAqKm5vbi1zZXJpYWxpemFibGUqKiAoJHt0fSlgfX19ZnVuY3Rpb24geih0LGUsbj0xLzAscj0xLzAsbz1mdW5jdGlvbigpe2NvbnN0IHQ9ImZ1bmN0aW9uIj09dHlwZW9mIFdlYWtTZXQsZT10P25ldyBXZWFrU2V0OltdO3JldHVybltmdW5jdGlvbihuKXtpZih0KXJldHVybiEhZS5oYXMobil8fChlLmFkZChuKSwhMSk7Zm9yKGxldCB0PTA7dDxlLmxlbmd0aDt0KyspaWYoZVt0XT09PW4pcmV0dXJuITA7cmV0dXJuIGUucHVzaChuKSwhMX0sZnVuY3Rpb24obil7aWYodCllLmRlbGV0ZShuKTtlbHNlIGZvcihsZXQgdD0wO3Q8ZS5sZW5ndGg7dCsrKWlmKGVbdF09PT1uKXtlLnNwbGljZSh0LDEpO2JyZWFrfX1dfSgpKXtjb25zdFtzLGldPW87aWYobnVsbD09ZXx8WyJudW1iZXIiLCJib29sZWFuIiwic3RyaW5nIl0uaW5jbHVkZXModHlwZW9mIGUpJiYhTnVtYmVyLmlzTmFOKGUpKXJldHVybiBlO2NvbnN0IGM9ZnVuY3Rpb24odCxlKXt0cnl7aWYoImRvbWFpbiI9PT10JiZlJiYib2JqZWN0Ij09dHlwZW9mIGUmJmUudClyZXR1cm4iW0RvbWFpbl0iO2lmKCJkb21haW5FbWl0dGVyIj09PXQpcmV0dXJuIltEb21haW5FbWl0dGVyXSI7aWYoInVuZGVmaW5lZCIhPXR5cGVvZiBnbG9iYWwmJmU9PT1nbG9iYWwpcmV0dXJuIltHbG9iYWxdIjtpZigidW5kZWZpbmVkIiE9dHlwZW9mIHdpbmRvdyYmZT09PXdpbmRvdylyZXR1cm4iW1dpbmRvd10iO2lmKCJ1bmRlZmluZWQiIT10eXBlb2YgZG9jdW1lbnQmJmU9PT1kb2N1bWVudClyZXR1cm4iW0RvY3VtZW50XSI7aWYoIm9iamVjdCI9PXR5cGVvZihuPWUpJiZudWxsIT09biYmKG4uX19pc1Z1ZXx8bi5vKSlyZXR1cm4iW1Z1ZVZpZXdNb2RlbF0iO2lmKGZ1bmN0aW9uKHQpe3JldHVybiBkKHQpJiYibmF0aXZlRXZlbnQiaW4gdCYmInByZXZlbnREZWZhdWx0ImluIHQmJiJzdG9wUHJvcGFnYXRpb24iaW4gdH0oZSkpcmV0dXJuIltTeW50aGV0aWNFdmVudF0iO2lmKCJudW1iZXIiPT10eXBlb2YgZSYmZSE9ZSlyZXR1cm4iW05hTl0iO2lmKCJmdW5jdGlvbiI9PXR5cGVvZiBlKXJldHVybmBbRnVuY3Rpb246ICR7ZnVuY3Rpb24odCl7dHJ5e3JldHVybiB0JiYiZnVuY3Rpb24iPT10eXBlb2YgdCYmdC5uYW1lfHxVfWNhdGNoKHQpe3JldHVybiBVfX0oZSl9XWA7aWYoInN5bWJvbCI9PXR5cGVvZiBlKXJldHVybmBbJHtTdHJpbmcoZSl9XWA7aWYoImJpZ2ludCI9PXR5cGVvZiBlKXJldHVybmBbQmlnSW50OiAke1N0cmluZyhlKX1dYDtjb25zdCByPWZ1bmN0aW9uKHQpe2NvbnN0IGU9T2JqZWN0LmdldFByb3RvdHlwZU9mKHQpO3JldHVybiBlP2UuY29uc3RydWN0b3IubmFtZToibnVsbCBwcm90b3R5cGUifShlKTtyZXR1cm4vXkhUTUwoXHcqKUVsZW1lbnQkLy50ZXN0KHIpP2BbSFRNTEVsZW1lbnQ6ICR7cn1dYDpgW29iamVjdCAke3J9XWB9Y2F0Y2godCl7cmV0dXJuYCoqbm9uLXNlcmlhbGl6YWJsZSoqICgke3R9KWB9dmFyIG59KHQsZSk7aWYoIWMuc3RhcnRzV2l0aCgiW29iamVjdCAiKSlyZXR1cm4gYztpZihlLl9fc2VudHJ5X3NraXBfbm9ybWFsaXphdGlvbl9fKXJldHVybiBlO2NvbnN0IHU9Im51bWJlciI9PXR5cGVvZiBlLl9fc2VudHJ5X292ZXJyaWRlX25vcm1hbGl6YXRpb25fZGVwdGhfXz9lLl9fc2VudHJ5X292ZXJyaWRlX25vcm1hbGl6YXRpb25fZGVwdGhfXzpuO2lmKDA9PT11KXJldHVybiBjLnJlcGxhY2UoIm9iamVjdCAiLCIiKTtpZihzKGUpKXJldHVybiJbQ2lyY3VsYXIgfl0iO2NvbnN0IGE9ZTtpZihhJiYiZnVuY3Rpb24iPT10eXBlb2YgYS50b0pTT04pdHJ5e3JldHVybiB6KCIiLGEudG9KU09OKCksdS0xLHIsbyl9Y2F0Y2godCl7fWNvbnN0IGY9QXJyYXkuaXNBcnJheShlKT9bXTp7fTtsZXQgaD0wO2NvbnN0IHA9RChlKTtmb3IoY29uc3QgdCBpbiBwKXtpZighT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHAsdCkpY29udGludWU7aWYoaD49cil7Zlt0XT0iW01heFByb3BlcnRpZXMgfl0iO2JyZWFrfWNvbnN0IGU9cFt0XTtmW3RdPXoodCxlLHUtMSxyLG8pLGgrK31yZXR1cm4gaShlKSxmfWZ1bmN0aW9uIEgodCxlKXtjb25zdCBuPWUucmVwbGFjZSgvXFwvZywiLyIpLnJlcGxhY2UoL1t8XFx7fSgpW1xdXiQrKj8uXS9nLCJcXCQmIik7bGV0IHI9dDt0cnl7cj1kZWNvZGVVUkkodCl9Y2F0Y2godCl7fXJldHVybiByLnJlcGxhY2UoL1xcL2csIi8iKS5yZXBsYWNlKC93ZWJwYWNrOlwvPy9nLCIiKS5yZXBsYWNlKG5ldyBSZWdFeHAoYChmaWxlOi8vKT8vKiR7bn0vKmAsImlnIiksImFwcDovLy8iKX0oKCk9Pntjb25zdHtwZXJmb3JtYW5jZTp0fT15O2lmKCF0fHwhdC5ub3cpcmV0dXJuO2NvbnN0IGU9MzZlNSxuPXQubm93KCkscj1EYXRlLm5vdygpLG89dC50aW1lT3JpZ2luP01hdGguYWJzKHQudGltZU9yaWdpbituLXIpOmUscz1vPGUsaT10LnRpbWluZyYmdC50aW1pbmcubmF2aWdhdGlvblN0YXJ0LGM9Im51bWJlciI9PXR5cGVvZiBpP01hdGguYWJzKGkrbi1yKTplOyhzfHxjPGUpJiYobzw9YyYmdC50aW1lT3JpZ2luKX0pKCk7Y29uc3QgVz0vXihcUys6XFx8XC8/KShbXHNcU10qPykoKD86XC57MSwyfXxbXi9cXF0rP3wpKFwuW14uL1xcXSp8KSkoPzpbL1xcXSopJC87ZnVuY3Rpb24gWSh0KXtjb25zdCBlPWZ1bmN0aW9uKHQpe2NvbnN0IGU9dC5sZW5ndGg+MTAyND9gPHRydW5jYXRlZD4ke3Quc2xpY2UoLTEwMjQpfWA6dCxuPVcuZXhlYyhlKTtyZXR1cm4gbj9uLnNsaWNlKDEpOltdfSh0KSxuPWVbMF07bGV0IHI9ZVsxXTtyZXR1cm4gbnx8cj8ociYmKHI9ci5zbGljZSgwLHIubGVuZ3RoLTEpKSxuK3IpOiIuIn12YXIgcTtmdW5jdGlvbiBGKHQpe3JldHVybiBuZXcgSygoZT0+e2UodCl9KSl9IWZ1bmN0aW9uKHQpe3RbdC5QRU5ESU5HPTBdPSJQRU5ESU5HIjt0W3QuUkVTT0xWRUQ9MV09IlJFU09MVkVEIjt0W3QuUkVKRUNURUQ9Ml09IlJFSkVDVEVEIn0ocXx8KHE9e30pKTtjbGFzcyBLe2NvbnN0cnVjdG9yKHQpe0sucHJvdG90eXBlLl9faW5pdC5jYWxsKHRoaXMpLEsucHJvdG90eXBlLl9faW5pdDIuY2FsbCh0aGlzKSxLLnByb3RvdHlwZS5fX2luaXQzLmNhbGwodGhpcyksSy5wcm90b3R5cGUuX19pbml0NC5jYWxsKHRoaXMpLHRoaXMuaT1xLlBFTkRJTkcsdGhpcy51PVtdO3RyeXt0KHRoaXMuaCx0aGlzLnApfWNhdGNoKHQpe3RoaXMucCh0KX19dGhlbih0LGUpe3JldHVybiBuZXcgSygoKG4scik9Pnt0aGlzLnUucHVzaChbITEsZT0+e2lmKHQpdHJ5e24odChlKSl9Y2F0Y2godCl7cih0KX1lbHNlIG4oZSl9LHQ9PntpZihlKXRyeXtuKGUodCkpfWNhdGNoKHQpe3IodCl9ZWxzZSByKHQpfV0pLHRoaXMubCgpfSkpfWNhdGNoKHQpe3JldHVybiB0aGlzLnRoZW4oKHQ9PnQpLHQpfWZpbmFsbHkodCl7cmV0dXJuIG5ldyBLKCgoZSxuKT0+e2xldCByLG87cmV0dXJuIHRoaXMudGhlbigoZT0+e289ITEscj1lLHQmJnQoKX0pLChlPT57bz0hMCxyPWUsdCYmdCgpfSkpLnRoZW4oKCgpPT57bz9uKHIpOmUocil9KSl9KSl9X19pbml0KCl7dGhpcy5oPXQ9Pnt0aGlzLm0ocS5SRVNPTFZFRCx0KX19X19pbml0Migpe3RoaXMucD10PT57dGhpcy5tKHEuUkVKRUNURUQsdCl9fV9faW5pdDMoKXt0aGlzLm09KHQsZSk9Pnt0aGlzLmk9PT1xLlBFTkRJTkcmJihtKGUpP2UudGhlbih0aGlzLmgsdGhpcy5wKToodGhpcy5pPXQsdGhpcy52PWUsdGhpcy5sKCkpKX19X19pbml0NCgpe3RoaXMubD0oKT0+e2lmKHRoaXMuaT09PXEuUEVORElORylyZXR1cm47Y29uc3QgdD10aGlzLnUuc2xpY2UoKTt0aGlzLnU9W10sdC5mb3JFYWNoKCh0PT57dFswXXx8KHRoaXMuaT09PXEuUkVTT0xWRUQmJnRbMV0odGhpcy52KSx0aGlzLmk9PT1xLlJFSkVDVEVEJiZ0WzJdKHRoaXMudiksdFswXT0hMCl9KSl9fX1mdW5jdGlvbiBWKHQpe2NvbnN0IGU9W107ZnVuY3Rpb24gbih0KXtyZXR1cm4gZS5zcGxpY2UoZS5pbmRleE9mKHQpLDEpWzBdfXJldHVybnskOmUsYWRkOmZ1bmN0aW9uKHIpe2lmKCEodm9pZCAwPT09dHx8ZS5sZW5ndGg8dCkpcmV0dXJuIG89bmV3IEMoIk5vdCBhZGRpbmcgUHJvbWlzZSBiZWNhdXNlIGJ1ZmZlciBsaW1pdCB3YXMgcmVhY2hlZC4iKSxuZXcgSygoKHQsZSk9PntlKG8pfSkpO3ZhciBvO2NvbnN0IHM9cigpO3JldHVybi0xPT09ZS5pbmRleE9mKHMpJiZlLnB1c2gocykscy50aGVuKCgoKT0+bihzKSkpLnRoZW4obnVsbCwoKCk9Pm4ocykudGhlbihudWxsLCgoKT0+e30pKSkpLHN9LGRyYWluOmZ1bmN0aW9uKHQpe3JldHVybiBuZXcgSygoKG4scik9PntsZXQgbz1lLmxlbmd0aDtpZighbylyZXR1cm4gbighMCk7Y29uc3Qgcz1zZXRUaW1lb3V0KCgoKT0+e3QmJnQ+MCYmbighMSl9KSx0KTtlLmZvckVhY2goKHQ9PntGKHQpLnRoZW4oKCgpPT57LS1vfHwoY2xlYXJUaW1lb3V0KHMpLG4oITApKX0pLHIpfSkpfSkpfX19ZnVuY3Rpb24gWih0LGU9ITEpe3JldHVybiEoZXx8dCYmIXQuc3RhcnRzV2l0aCgiLyIpJiYhdC5tYXRjaCgvXltBLVpdOi8pJiYhdC5zdGFydHNXaXRoKCIuIikmJiF0Lm1hdGNoKC9eW2EtekEtWl0oW2EtekEtWjAtOS5cLStdKSo6XC9cLy8pKSYmdm9pZCAwIT09dCYmIXQuaW5jbHVkZXMoIm5vZGVfbW9kdWxlcy8iKX1mdW5jdGlvbiBRKHQsZT1bXSl7cmV0dXJuW3QsZV19ZnVuY3Rpb24gWCh0LGUpe2NvbnN0IG49dFsxXTtmb3IoY29uc3QgdCBvZiBuKXtpZihlKHQsdFswXS50eXBlKSlyZXR1cm4hMH1yZXR1cm4hMX1mdW5jdGlvbiB0dCh0KXtyZXR1cm4geS5fX1NFTlRSWV9fJiZ5Ll9fU0VOVFJZX18uZW5jb2RlUG9seWZpbGw/eS5fX1NFTlRSWV9fLmVuY29kZVBvbHlmaWxsKHQpOihuZXcgVGV4dEVuY29kZXIpLmVuY29kZSh0KX1mdW5jdGlvbiBldCh0KXtjb25zdFtlLG5dPXQ7bGV0IHI9SlNPTi5zdHJpbmdpZnkoZSk7ZnVuY3Rpb24gbyh0KXsic3RyaW5nIj09dHlwZW9mIHI/cj0ic3RyaW5nIj09dHlwZW9mIHQ/cit0Olt0dChyKSx0XTpyLnB1c2goInN0cmluZyI9PXR5cGVvZiB0P3R0KHQpOnQpfWZvcihjb25zdCB0IG9mIG4pe2NvbnN0W2Usbl09dDtpZihvKGBcbiR7SlNPTi5zdHJpbmdpZnkoZSl9XG5gKSwic3RyaW5nIj09dHlwZW9mIG58fG4gaW5zdGFuY2VvZiBVaW50OEFycmF5KW8obik7ZWxzZXtsZXQgdDt0cnl7dD1KU09OLnN0cmluZ2lmeShuKX1jYXRjaChlKXt0PUpTT04uc3RyaW5naWZ5KEoobikpfW8odCl9fXJldHVybiJzdHJpbmciPT10eXBlb2Ygcj9yOmZ1bmN0aW9uKHQpe2NvbnN0IGU9dC5yZWR1Y2UoKCh0LGUpPT50K2UubGVuZ3RoKSwwKSxuPW5ldyBVaW50OEFycmF5KGUpO2xldCByPTA7Zm9yKGNvbnN0IGUgb2YgdCluLnNldChlLHIpLHIrPWUubGVuZ3RoO3JldHVybiBufShyKX1jb25zdCBudD17c2Vzc2lvbjoic2Vzc2lvbiIsc2Vzc2lvbnM6InNlc3Npb24iLGF0dGFjaG1lbnQ6ImF0dGFjaG1lbnQiLHRyYW5zYWN0aW9uOiJ0cmFuc2FjdGlvbiIsZXZlbnQ6ImVycm9yIixjbGllbnRfcmVwb3J0OiJpbnRlcm5hbCIsdXNlcl9yZXBvcnQ6ImRlZmF1bHQiLHByb2ZpbGU6InByb2ZpbGUiLHJlcGxheV9ldmVudDoicmVwbGF5IixyZXBsYXlfcmVjb3JkaW5nOiJyZXBsYXkiLGNoZWNrX2luOiJtb25pdG9yIixmZWVkYmFjazoiZmVlZGJhY2siLHNwYW46InNwYW4iLHN0YXRzZDoibWV0cmljX2J1Y2tldCJ9O2Z1bmN0aW9uIHJ0KHQpe3JldHVybiBudFt0XX1mdW5jdGlvbiBvdCh0KXtpZighdHx8IXQuc2RrKXJldHVybjtjb25zdHtuYW1lOmUsdmVyc2lvbjpufT10LnNkaztyZXR1cm57bmFtZTplLHZlcnNpb246bn19Y29uc3Qgc3Q9NmU0O2Z1bmN0aW9uIGl0KHQse3N0YXR1c0NvZGU6ZSxoZWFkZXJzOm59LHI9RGF0ZS5ub3coKSl7Y29uc3Qgbz17Li4udH0scz1uJiZuWyJ4LXNlbnRyeS1yYXRlLWxpbWl0cyJdLGk9biYmblsicmV0cnktYWZ0ZXIiXTtpZihzKWZvcihjb25zdCB0IG9mIHMudHJpbSgpLnNwbGl0KCIsIikpe2NvbnN0W2UsbiwsLHNdPXQuc3BsaXQoIjoiLDUpLGk9cGFyc2VJbnQoZSwxMCksYz0xZTMqKGlzTmFOKGkpPzYwOmkpO2lmKG4pZm9yKGNvbnN0IHQgb2Ygbi5zcGxpdCgiOyIpKSJtZXRyaWNfYnVja2V0Ij09PXQmJnMmJiFzLnNwbGl0KCI7IikuaW5jbHVkZXMoImN1c3RvbSIpfHwob1t0XT1yK2MpO2Vsc2Ugby5hbGw9citjfWVsc2UgaT9vLmFsbD1yK2Z1bmN0aW9uKHQsZT1EYXRlLm5vdygpKXtjb25zdCBuPXBhcnNlSW50KGAke3R9YCwxMCk7aWYoIWlzTmFOKG4pKXJldHVybiAxZTMqbjtjb25zdCByPURhdGUucGFyc2UoYCR7dH1gKTtyZXR1cm4gaXNOYU4ocik/c3Q6ci1lfShpLHIpOjQyOT09PWUmJihvLmFsbD1yKzZlNCk7cmV0dXJuIG99Y29uc3QgY3Q9InVuZGVmaW5lZCI9PXR5cGVvZiBfX1NFTlRSWV9ERUJVR19ffHxfX1NFTlRSWV9ERUJVR19fO2Z1bmN0aW9uIHV0KCl7cmV0dXJuIGF0KHkpLHl9ZnVuY3Rpb24gYXQodCl7cmV0dXJuIHQuX19TRU5UUllfX3x8KHQuX19TRU5UUllfXz17ZXh0ZW5zaW9uczp7fX0pLHQuX19TRU5UUllfX31mdW5jdGlvbiBmdCh0KXtjb25zdCBlPUIoKSxuPXtzaWQ6RygpLGluaXQ6ITAsdGltZXN0YW1wOmUsc3RhcnRlZDplLGR1cmF0aW9uOjAsc3RhdHVzOiJvayIsZXJyb3JzOjAsaWdub3JlRHVyYXRpb246ITEsdG9KU09OOigpPT5mdW5jdGlvbih0KXtyZXR1cm4gaih7c2lkOmAke3Quc2lkfWAsaW5pdDp0LmluaXQsc3RhcnRlZDpuZXcgRGF0ZSgxZTMqdC5zdGFydGVkKS50b0lTT1N0cmluZygpLHRpbWVzdGFtcDpuZXcgRGF0ZSgxZTMqdC50aW1lc3RhbXApLnRvSVNPU3RyaW5nKCksc3RhdHVzOnQuc3RhdHVzLGVycm9yczp0LmVycm9ycyxkaWQ6Im51bWJlciI9PXR5cGVvZiB0LmRpZHx8InN0cmluZyI9PXR5cGVvZiB0LmRpZD9gJHt0LmRpZH1gOnZvaWQgMCxkdXJhdGlvbjp0LmR1cmF0aW9uLGFibm9ybWFsX21lY2hhbmlzbTp0LmFibm9ybWFsX21lY2hhbmlzbSxhdHRyczp7cmVsZWFzZTp0LnJlbGVhc2UsZW52aXJvbm1lbnQ6dC5lbnZpcm9ubWVudCxpcF9hZGRyZXNzOnQuaXBBZGRyZXNzLHVzZXJfYWdlbnQ6dC51c2VyQWdlbnR9fSl9KG4pfTtyZXR1cm4gdCYmaHQobix0KSxufWZ1bmN0aW9uIGh0KHQsZT17fSl7aWYoZS51c2VyJiYoIXQuaXBBZGRyZXNzJiZlLnVzZXIuaXBfYWRkcmVzcyYmKHQuaXBBZGRyZXNzPWUudXNlci5pcF9hZGRyZXNzKSx0LmRpZHx8ZS5kaWR8fCh0LmRpZD1lLnVzZXIuaWR8fGUudXNlci5lbWFpbHx8ZS51c2VyLnVzZXJuYW1lKSksdC50aW1lc3RhbXA9ZS50aW1lc3RhbXB8fEIoKSxlLmFibm9ybWFsX21lY2hhbmlzbSYmKHQuYWJub3JtYWxfbWVjaGFuaXNtPWUuYWJub3JtYWxfbWVjaGFuaXNtKSxlLmlnbm9yZUR1cmF0aW9uJiYodC5pZ25vcmVEdXJhdGlvbj1lLmlnbm9yZUR1cmF0aW9uKSxlLnNpZCYmKHQuc2lkPTMyPT09ZS5zaWQubGVuZ3RoP2Uuc2lkOkcoKSksdm9pZCAwIT09ZS5pbml0JiYodC5pbml0PWUuaW5pdCksIXQuZGlkJiZlLmRpZCYmKHQuZGlkPWAke2UuZGlkfWApLCJudW1iZXIiPT10eXBlb2YgZS5zdGFydGVkJiYodC5zdGFydGVkPWUuc3RhcnRlZCksdC5pZ25vcmVEdXJhdGlvbil0LmR1cmF0aW9uPXZvaWQgMDtlbHNlIGlmKCJudW1iZXIiPT10eXBlb2YgZS5kdXJhdGlvbil0LmR1cmF0aW9uPWUuZHVyYXRpb247ZWxzZXtjb25zdCBlPXQudGltZXN0YW1wLXQuc3RhcnRlZDt0LmR1cmF0aW9uPWU+PTA/ZTowfWUucmVsZWFzZSYmKHQucmVsZWFzZT1lLnJlbGVhc2UpLGUuZW52aXJvbm1lbnQmJih0LmVudmlyb25tZW50PWUuZW52aXJvbm1lbnQpLCF0LmlwQWRkcmVzcyYmZS5pcEFkZHJlc3MmJih0LmlwQWRkcmVzcz1lLmlwQWRkcmVzcyksIXQudXNlckFnZW50JiZlLnVzZXJBZ2VudCYmKHQudXNlckFnZW50PWUudXNlckFnZW50KSwibnVtYmVyIj09dHlwZW9mIGUuZXJyb3JzJiYodC5lcnJvcnM9ZS5lcnJvcnMpLGUuc3RhdHVzJiYodC5zdGF0dXM9ZS5zdGF0dXMpfWNvbnN0IHB0PSJfc2VudHJ5U3BhbiI7ZnVuY3Rpb24gbHQodCxlKXtlP2Z1bmN0aW9uKHQsZSxuKXt0cnl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsZSx7dmFsdWU6bix3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9KX1jYXRjaChuKXtTJiZOLmxvZyhgRmFpbGVkIHRvIGFkZCBub24tZW51bWVyYWJsZSBwcm9wZXJ0eSAiJHtlfSIgdG8gb2JqZWN0YCx0KX19KHQscHQsZSk6ZGVsZXRlIHRbcHRdfWZ1bmN0aW9uIGR0KHQpe3JldHVybiB0W3B0XX1jbGFzcyBtdHtjb25zdHJ1Y3Rvcigpe3RoaXMuXz0hMSx0aGlzLlM9W10sdGhpcy5OPVtdLHRoaXMuaz1bXSx0aGlzLkM9W10sdGhpcy5EPXt9LHRoaXMuVD17fSx0aGlzLk89e30sdGhpcy5qPXt9LHRoaXMuUj17fSx0aGlzLkE9eXQoKX1jbG9uZSgpe2NvbnN0IHQ9bmV3IG10O3JldHVybiB0Lms9Wy4uLnRoaXMua10sdC5UPXsuLi50aGlzLlR9LHQuTz17Li4udGhpcy5PfSx0Lmo9ey4uLnRoaXMuan0sdC5EPXRoaXMuRCx0Lkk9dGhpcy5JLHQuUD10aGlzLlAsdC5VPXRoaXMuVSx0Lk09dGhpcy5NLHQuTj1bLi4udGhpcy5OXSx0Lkw9dGhpcy5MLHQuQz1bLi4udGhpcy5DXSx0LlI9ey4uLnRoaXMuUn0sdC5BPXsuLi50aGlzLkF9LHQuQj10aGlzLkIsdC5HPXRoaXMuRyxsdCh0LGR0KHRoaXMpKSx0fXNldENsaWVudCh0KXt0aGlzLkI9dH1zZXRMYXN0RXZlbnRJZCh0KXt0aGlzLkc9dH1nZXRDbGllbnQoKXtyZXR1cm4gdGhpcy5CfWxhc3RFdmVudElkKCl7cmV0dXJuIHRoaXMuR31hZGRTY29wZUxpc3RlbmVyKHQpe3RoaXMuUy5wdXNoKHQpfWFkZEV2ZW50UHJvY2Vzc29yKHQpe3JldHVybiB0aGlzLk4ucHVzaCh0KSx0aGlzfXNldFVzZXIodCl7cmV0dXJuIHRoaXMuRD10fHx7ZW1haWw6dm9pZCAwLGlkOnZvaWQgMCxpcF9hZGRyZXNzOnZvaWQgMCx1c2VybmFtZTp2b2lkIDB9LHRoaXMuUCYmaHQodGhpcy5QLHt1c2VyOnR9KSx0aGlzLkooKSx0aGlzfWdldFVzZXIoKXtyZXR1cm4gdGhpcy5EfWdldFJlcXVlc3RTZXNzaW9uKCl7cmV0dXJuIHRoaXMuTH1zZXRSZXF1ZXN0U2Vzc2lvbih0KXtyZXR1cm4gdGhpcy5MPXQsdGhpc31zZXRUYWdzKHQpe3JldHVybiB0aGlzLlQ9ey4uLnRoaXMuVCwuLi50fSx0aGlzLkooKSx0aGlzfXNldFRhZyh0LGUpe3JldHVybiB0aGlzLlQ9ey4uLnRoaXMuVCxbdF06ZX0sdGhpcy5KKCksdGhpc31zZXRFeHRyYXModCl7cmV0dXJuIHRoaXMuTz17Li4udGhpcy5PLC4uLnR9LHRoaXMuSigpLHRoaXN9c2V0RXh0cmEodCxlKXtyZXR1cm4gdGhpcy5PPXsuLi50aGlzLk8sW3RdOmV9LHRoaXMuSigpLHRoaXN9c2V0RmluZ2VycHJpbnQodCl7cmV0dXJuIHRoaXMuTT10LHRoaXMuSigpLHRoaXN9c2V0TGV2ZWwodCl7cmV0dXJuIHRoaXMuST10LHRoaXMuSigpLHRoaXN9c2V0VHJhbnNhY3Rpb25OYW1lKHQpe3JldHVybiB0aGlzLlU9dCx0aGlzLkooKSx0aGlzfXNldENvbnRleHQodCxlKXtyZXR1cm4gbnVsbD09PWU/ZGVsZXRlIHRoaXMualt0XTp0aGlzLmpbdF09ZSx0aGlzLkooKSx0aGlzfXNldFNlc3Npb24odCl7cmV0dXJuIHQ/dGhpcy5QPXQ6ZGVsZXRlIHRoaXMuUCx0aGlzLkooKSx0aGlzfWdldFNlc3Npb24oKXtyZXR1cm4gdGhpcy5QfXVwZGF0ZSh0KXtpZighdClyZXR1cm4gdGhpcztjb25zdCBlPSJmdW5jdGlvbiI9PXR5cGVvZiB0P3QodGhpcyk6dCxbbixyXT1lIGluc3RhbmNlb2YgZ3Q/W2UuZ2V0U2NvcGVEYXRhKCksZS5nZXRSZXF1ZXN0U2Vzc2lvbigpXTpkKGUpP1t0LHQucmVxdWVzdFNlc3Npb25dOltdLHt0YWdzOm8sZXh0cmE6cyx1c2VyOmksY29udGV4dHM6YyxsZXZlbDp1LGZpbmdlcnByaW50OmE9W10scHJvcGFnYXRpb25Db250ZXh0OmZ9PW58fHt9O3JldHVybiB0aGlzLlQ9ey4uLnRoaXMuVCwuLi5vfSx0aGlzLk89ey4uLnRoaXMuTywuLi5zfSx0aGlzLmo9ey4uLnRoaXMuaiwuLi5jfSxpJiZPYmplY3Qua2V5cyhpKS5sZW5ndGgmJih0aGlzLkQ9aSksdSYmKHRoaXMuST11KSxhLmxlbmd0aCYmKHRoaXMuTT1hKSxmJiYodGhpcy5BPWYpLHImJih0aGlzLkw9ciksdGhpc31jbGVhcigpe3JldHVybiB0aGlzLms9W10sdGhpcy5UPXt9LHRoaXMuTz17fSx0aGlzLkQ9e30sdGhpcy5qPXt9LHRoaXMuST12b2lkIDAsdGhpcy5VPXZvaWQgMCx0aGlzLk09dm9pZCAwLHRoaXMuTD12b2lkIDAsdGhpcy5QPXZvaWQgMCxsdCh0aGlzLHZvaWQgMCksdGhpcy5DPVtdLHRoaXMuQT15dCgpLHRoaXMuSigpLHRoaXN9YWRkQnJlYWRjcnVtYih0LGUpe2NvbnN0IG49Im51bWJlciI9PXR5cGVvZiBlP2U6MTAwO2lmKG48PTApcmV0dXJuIHRoaXM7Y29uc3Qgcj17dGltZXN0YW1wOkwoKSwuLi50fSxvPXRoaXMuaztyZXR1cm4gby5wdXNoKHIpLHRoaXMuaz1vLmxlbmd0aD5uP28uc2xpY2UoLW4pOm8sdGhpcy5KKCksdGhpc31nZXRMYXN0QnJlYWRjcnVtYigpe3JldHVybiB0aGlzLmtbdGhpcy5rLmxlbmd0aC0xXX1jbGVhckJyZWFkY3J1bWJzKCl7cmV0dXJuIHRoaXMuaz1bXSx0aGlzLkooKSx0aGlzfWFkZEF0dGFjaG1lbnQodCl7cmV0dXJuIHRoaXMuQy5wdXNoKHQpLHRoaXN9Y2xlYXJBdHRhY2htZW50cygpe3JldHVybiB0aGlzLkM9W10sdGhpc31nZXRTY29wZURhdGEoKXtyZXR1cm57YnJlYWRjcnVtYnM6dGhpcy5rLGF0dGFjaG1lbnRzOnRoaXMuQyxjb250ZXh0czp0aGlzLmosdGFnczp0aGlzLlQsZXh0cmE6dGhpcy5PLHVzZXI6dGhpcy5ELGxldmVsOnRoaXMuSSxmaW5nZXJwcmludDp0aGlzLk18fFtdLGV2ZW50UHJvY2Vzc29yczp0aGlzLk4scHJvcGFnYXRpb25Db250ZXh0OnRoaXMuQSxzZGtQcm9jZXNzaW5nTWV0YWRhdGE6dGhpcy5SLHRyYW5zYWN0aW9uTmFtZTp0aGlzLlUsc3BhbjpkdCh0aGlzKX19c2V0U0RLUHJvY2Vzc2luZ01ldGFkYXRhKHQpe3JldHVybiB0aGlzLlI9ey4uLnRoaXMuUiwuLi50fSx0aGlzfXNldFByb3BhZ2F0aW9uQ29udGV4dCh0KXtyZXR1cm4gdGhpcy5BPXQsdGhpc31nZXRQcm9wYWdhdGlvbkNvbnRleHQoKXtyZXR1cm4gdGhpcy5BfWNhcHR1cmVFeGNlcHRpb24odCxlKXtjb25zdCBuPWUmJmUuZXZlbnRfaWQ/ZS5ldmVudF9pZDpHKCk7aWYoIXRoaXMuQilyZXR1cm4gTi53YXJuKCJObyBjbGllbnQgY29uZmlndXJlZCBvbiBzY29wZSAtIHdpbGwgbm90IGNhcHR1cmUgZXhjZXB0aW9uISIpLG47Y29uc3Qgcj1uZXcgRXJyb3IoIlNlbnRyeSBzeW50aGV0aWNFeGNlcHRpb24iKTtyZXR1cm4gdGhpcy5CLmNhcHR1cmVFeGNlcHRpb24odCx7b3JpZ2luYWxFeGNlcHRpb246dCxzeW50aGV0aWNFeGNlcHRpb246ciwuLi5lLGV2ZW50X2lkOm59LHRoaXMpLG59Y2FwdHVyZU1lc3NhZ2UodCxlLG4pe2NvbnN0IHI9biYmbi5ldmVudF9pZD9uLmV2ZW50X2lkOkcoKTtpZighdGhpcy5CKXJldHVybiBOLndhcm4oIk5vIGNsaWVudCBjb25maWd1cmVkIG9uIHNjb3BlIC0gd2lsbCBub3QgY2FwdHVyZSBtZXNzYWdlISIpLHI7Y29uc3Qgbz1uZXcgRXJyb3IodCk7cmV0dXJuIHRoaXMuQi5jYXB0dXJlTWVzc2FnZSh0LGUse29yaWdpbmFsRXhjZXB0aW9uOnQsc3ludGhldGljRXhjZXB0aW9uOm8sLi4ubixldmVudF9pZDpyfSx0aGlzKSxyfWNhcHR1cmVFdmVudCh0LGUpe2NvbnN0IG49ZSYmZS5ldmVudF9pZD9lLmV2ZW50X2lkOkcoKTtyZXR1cm4gdGhpcy5CPyh0aGlzLkIuY2FwdHVyZUV2ZW50KHQsey4uLmUsZXZlbnRfaWQ6bn0sdGhpcyksbik6KE4ud2FybigiTm8gY2xpZW50IGNvbmZpZ3VyZWQgb24gc2NvcGUgLSB3aWxsIG5vdCBjYXB0dXJlIGV2ZW50ISIpLG4pfUooKXt0aGlzLl98fCh0aGlzLl89ITAsdGhpcy5TLmZvckVhY2goKHQ9Pnt0KHRoaXMpfSkpLHRoaXMuXz0hMSl9fWNvbnN0IGd0PW10O2Z1bmN0aW9uIHl0KCl7cmV0dXJue3RyYWNlSWQ6RygpLHNwYW5JZDpHKCkuc3Vic3RyaW5nKDE2KX19ZnVuY3Rpb24gYnQoKXtyZXR1cm4gRXQodXQoKSkuZ2V0Q3VycmVudFNjb3BlKCkuZ2V0Q2xpZW50KCl9Y2xhc3MgdnR7Y29uc3RydWN0b3IodCxlKXtsZXQgbixyO249dHx8bmV3IGd0LHI9ZXx8bmV3IGd0LHRoaXMuSD1be3Njb3BlOm59XSx0aGlzLlc9cn13aXRoU2NvcGUodCl7Y29uc3QgZT10aGlzLlkoKTtsZXQgbjt0cnl7bj10KGUpfWNhdGNoKHQpe3Rocm93IHRoaXMucSgpLHR9cmV0dXJuIG0obik/bi50aGVuKCh0PT4odGhpcy5xKCksdCkpLCh0PT57dGhyb3cgdGhpcy5xKCksdH0pKToodGhpcy5xKCksbil9Z2V0Q2xpZW50KCl7cmV0dXJuIHRoaXMuZ2V0U3RhY2tUb3AoKS5jbGllbnR9Z2V0U2NvcGUoKXtyZXR1cm4gdGhpcy5nZXRTdGFja1RvcCgpLnNjb3BlfWdldElzb2xhdGlvblNjb3BlKCl7cmV0dXJuIHRoaXMuV31nZXRTdGFjaygpe3JldHVybiB0aGlzLkh9Z2V0U3RhY2tUb3AoKXtyZXR1cm4gdGhpcy5IW3RoaXMuSC5sZW5ndGgtMV19WSgpe2NvbnN0IHQ9dGhpcy5nZXRTY29wZSgpLmNsb25lKCk7cmV0dXJuIHRoaXMuZ2V0U3RhY2soKS5wdXNoKHtjbGllbnQ6dGhpcy5nZXRDbGllbnQoKSxzY29wZTp0fSksdH1xKCl7cmV0dXJuISh0aGlzLmdldFN0YWNrKCkubGVuZ3RoPD0xKSYmISF0aGlzLmdldFN0YWNrKCkucG9wKCl9fWZ1bmN0aW9uIF90KCl7Y29uc3QgdD1hdCh1dCgpKTtyZXR1cm4gdC5odWJ8fCh0Lmh1Yj1uZXcgdnQoYigiZGVmYXVsdEN1cnJlbnRTY29wZSIsKCgpPT5uZXcgZ3QpKSxiKCJkZWZhdWx0SXNvbGF0aW9uU2NvcGUiLCgoKT0+bmV3IGd0KSkpKSx0Lmh1Yn1mdW5jdGlvbiB3dCh0KXtyZXR1cm4gX3QoKS53aXRoU2NvcGUodCl9ZnVuY3Rpb24gU3QodCxlKXtjb25zdCBuPV90KCk7cmV0dXJuIG4ud2l0aFNjb3BlKCgoKT0+KG4uZ2V0U3RhY2tUb3AoKS5zY29wZT10LGUodCkpKSl9ZnVuY3Rpb24gJHQodCl7cmV0dXJuIF90KCkud2l0aFNjb3BlKCgoKT0+dChfdCgpLmdldElzb2xhdGlvblNjb3BlKCkpKSl9ZnVuY3Rpb24gRXQodCl7Y29uc3QgZT1hdCh0KTtyZXR1cm4gZS5hY3M/ZS5hY3M6e3dpdGhJc29sYXRpb25TY29wZTokdCx3aXRoU2NvcGU6d3Qsd2l0aFNldFNjb3BlOlN0LHdpdGhTZXRJc29sYXRpb25TY29wZToodCxlKT0+JHQoZSksZ2V0Q3VycmVudFNjb3BlOigpPT5fdCgpLmdldFNjb3BlKCksZ2V0SXNvbGF0aW9uU2NvcGU6KCk9Pl90KCkuZ2V0SXNvbGF0aW9uU2NvcGUoKX19Y29uc3QgeHQ9InNlbnRyeS5zb3VyY2UiLE50PSJzZW50cnkuc2FtcGxlX3JhdGUiLGt0PSJzZW50cnkub3AiLEN0PSJzZW50cnkub3JpZ2luIixEdD0wLFR0PTEsT3Q9InByb2R1Y3Rpb24iLGp0PSJfZnJvemVuRHNjIjtmdW5jdGlvbiBSdCh0KXtjb25zdCBlPWJ0KCk7aWYoIWUpcmV0dXJue307Y29uc3Qgbj1mdW5jdGlvbih0LGUpe2NvbnN0IG49ZS5nZXRPcHRpb25zKCkse3B1YmxpY0tleTpyfT1lLmdldERzbigpfHx7fSxvPWooe2Vudmlyb25tZW50Om4uZW52aXJvbm1lbnR8fE90LHJlbGVhc2U6bi5yZWxlYXNlLHB1YmxpY19rZXk6cix0cmFjZV9pZDp0fSk7cmV0dXJuIGUuZW1pdCgiY3JlYXRlRHNjIixvKSxvfShNdCh0KS50cmFjZV9pZHx8IiIsZSkscj1HdCh0KTtpZighcilyZXR1cm4gbjtjb25zdCBvPXJbanRdO2lmKG8pcmV0dXJuIG87Y29uc3Qgcz1NdChyKSxpPXMuZGF0YXx8e30sYz1pW050XTtudWxsIT1jJiYobi5zYW1wbGVfcmF0ZT1gJHtjfWApO2NvbnN0IHU9aVt4dF07cmV0dXJuIHUmJiJ1cmwiIT09dSYmKG4udHJhbnNhY3Rpb249cy5kZXNjcmlwdGlvbiksbi5zYW1wbGVkPVN0cmluZyhmdW5jdGlvbih0KXtjb25zdHt0cmFjZUZsYWdzOmV9PXQuc3BhbkNvbnRleHQoKTtyZXR1cm4gZT09PUF0fShyKSksZS5lbWl0KCJjcmVhdGVEc2MiLG4pLG59Y29uc3QgQXQ9MTtmdW5jdGlvbiBJdCh0KXtjb25zdHtzcGFuSWQ6ZSx0cmFjZUlkOm59PXQuc3BhbkNvbnRleHQoKSx7cGFyZW50X3NwYW5faWQ6cn09TXQodCk7cmV0dXJuIGooe3BhcmVudF9zcGFuX2lkOnIsc3Bhbl9pZDplLHRyYWNlX2lkOm59KX1mdW5jdGlvbiBQdCh0KXtyZXR1cm4ibnVtYmVyIj09dHlwZW9mIHQ/VXQodCk6QXJyYXkuaXNBcnJheSh0KT90WzBdK3RbMV0vMWU5OnQgaW5zdGFuY2VvZiBEYXRlP1V0KHQuZ2V0VGltZSgpKTpCKCl9ZnVuY3Rpb24gVXQodCl7cmV0dXJuIHQ+OTk5OTk5OTk5OT90LzFlMzp0fWZ1bmN0aW9uIE10KHQpe2lmKGZ1bmN0aW9uKHQpe3JldHVybiJmdW5jdGlvbiI9PXR5cGVvZiB0LmdldFNwYW5KU09OfSh0KSlyZXR1cm4gdC5nZXRTcGFuSlNPTigpO3RyeXtjb25zdHtzcGFuSWQ6ZSx0cmFjZUlkOm59PXQuc3BhbkNvbnRleHQoKTtpZihmdW5jdGlvbih0KXtjb25zdCBlPXQ7cmV0dXJuISEoZS5hdHRyaWJ1dGVzJiZlLnN0YXJ0VGltZSYmZS5uYW1lJiZlLmVuZFRpbWUmJmUuc3RhdHVzKX0odCkpe2NvbnN0e2F0dHJpYnV0ZXM6cixzdGFydFRpbWU6byxuYW1lOnMsZW5kVGltZTppLHBhcmVudFNwYW5JZDpjLHN0YXR1czp1fT10O3JldHVybiBqKHtzcGFuX2lkOmUsdHJhY2VfaWQ6bixkYXRhOnIsZGVzY3JpcHRpb246cyxwYXJlbnRfc3Bhbl9pZDpjLHN0YXJ0X3RpbWVzdGFtcDpQdChvKSx0aW1lc3RhbXA6UHQoaSl8fHZvaWQgMCxzdGF0dXM6THQodSksb3A6cltrdF0sb3JpZ2luOnJbQ3RdLEY6dm9pZCAwfSl9cmV0dXJue3NwYW5faWQ6ZSx0cmFjZV9pZDpufX1jYXRjaCh0KXtyZXR1cm57fX19ZnVuY3Rpb24gTHQodCl7aWYodCYmdC5jb2RlIT09RHQpcmV0dXJuIHQuY29kZT09PVR0PyJvayI6dC5tZXNzYWdlfHwidW5rbm93bl9lcnJvciJ9Y29uc3QgQnQ9Il9zZW50cnlSb290U3BhbiI7ZnVuY3Rpb24gR3QodCl7cmV0dXJuIHRbQnRdfHx0fWZ1bmN0aW9uIEp0KHQsZSxuLHIpe2NvbnN0IG89b3Qobikscz10LnR5cGUmJiJyZXBsYXlfZXZlbnQiIT09dC50eXBlP3QudHlwZToiZXZlbnQiOyFmdW5jdGlvbih0LGUpe2UmJih0LnNkaz10LnNka3x8e30sdC5zZGsubmFtZT10LnNkay5uYW1lfHxlLm5hbWUsdC5zZGsudmVyc2lvbj10LnNkay52ZXJzaW9ufHxlLnZlcnNpb24sdC5zZGsuaW50ZWdyYXRpb25zPVsuLi50LnNkay5pbnRlZ3JhdGlvbnN8fFtdLC4uLmUuaW50ZWdyYXRpb25zfHxbXV0sdC5zZGsucGFja2FnZXM9Wy4uLnQuc2RrLnBhY2thZ2VzfHxbXSwuLi5lLnBhY2thZ2VzfHxbXV0pfSh0LG4mJm4uc2RrKTtjb25zdCBpPWZ1bmN0aW9uKHQsZSxuLHIpe2NvbnN0IG89dC5zZGtQcm9jZXNzaW5nTWV0YWRhdGEmJnQuc2RrUHJvY2Vzc2luZ01ldGFkYXRhLmR5bmFtaWNTYW1wbGluZ0NvbnRleHQ7cmV0dXJue2V2ZW50X2lkOnQuZXZlbnRfaWQsc2VudF9hdDoobmV3IERhdGUpLnRvSVNPU3RyaW5nKCksLi4uZSYme3NkazplfSwuLi4hIW4mJnImJntkc246ayhyKX0sLi4ubyYme3RyYWNlOmooey4uLm99KX19fSh0LG8scixlKTtkZWxldGUgdC5zZGtQcm9jZXNzaW5nTWV0YWRhdGE7cmV0dXJuIFEoaSxbW3t0eXBlOnN9LHRdXSl9Y29uc3QgenQ9Il9fU0VOVFJZX1NVUFBSRVNTX1RSQUNJTkdfXyI7ZnVuY3Rpb24gSHQodCl7Y29uc3QgZT1FdCh1dCgpKTtyZXR1cm4gZS5zdXBwcmVzc1RyYWNpbmc/ZS5zdXBwcmVzc1RyYWNpbmcodCk6ZnVuY3Rpb24oLi4udCl7Y29uc3QgZT1FdCh1dCgpKTtpZigyPT09dC5sZW5ndGgpe2NvbnN0W24scl09dDtyZXR1cm4gbj9lLndpdGhTZXRTY29wZShuLHIpOmUud2l0aFNjb3BlKHIpfXJldHVybiBlLndpdGhTY29wZSh0WzBdKX0oKGU9PihlLnNldFNES1Byb2Nlc3NpbmdNZXRhZGF0YSh7W3p0XTohMH0pLHQoKSkpKX1mdW5jdGlvbiBXdCh0LGUpe2NvbnN0e2ZpbmdlcnByaW50Om4sc3BhbjpyLGJyZWFkY3J1bWJzOm8sc2RrUHJvY2Vzc2luZ01ldGFkYXRhOnN9PWU7IWZ1bmN0aW9uKHQsZSl7Y29uc3R7ZXh0cmE6bix0YWdzOnIsdXNlcjpvLGNvbnRleHRzOnMsbGV2ZWw6aSx0cmFuc2FjdGlvbk5hbWU6Y309ZSx1PWoobik7dSYmT2JqZWN0LmtleXModSkubGVuZ3RoJiYodC5leHRyYT17Li4udSwuLi50LmV4dHJhfSk7Y29uc3QgYT1qKHIpO2EmJk9iamVjdC5rZXlzKGEpLmxlbmd0aCYmKHQudGFncz17Li4uYSwuLi50LnRhZ3N9KTtjb25zdCBmPWoobyk7ZiYmT2JqZWN0LmtleXMoZikubGVuZ3RoJiYodC51c2VyPXsuLi5mLC4uLnQudXNlcn0pO2NvbnN0IGg9aihzKTtoJiZPYmplY3Qua2V5cyhoKS5sZW5ndGgmJih0LmNvbnRleHRzPXsuLi5oLC4uLnQuY29udGV4dHN9KTtpJiYodC5sZXZlbD1pKTtjJiYidHJhbnNhY3Rpb24iIT09dC50eXBlJiYodC50cmFuc2FjdGlvbj1jKX0odCxlKSxyJiZmdW5jdGlvbih0LGUpe3QuY29udGV4dHM9e3RyYWNlOkl0KGUpLC4uLnQuY29udGV4dHN9LHQuc2RrUHJvY2Vzc2luZ01ldGFkYXRhPXtkeW5hbWljU2FtcGxpbmdDb250ZXh0OlJ0KGUpLC4uLnQuc2RrUHJvY2Vzc2luZ01ldGFkYXRhfTtjb25zdCBuPUd0KGUpLHI9TXQobikuZGVzY3JpcHRpb247ciYmIXQudHJhbnNhY3Rpb24mJiJ0cmFuc2FjdGlvbiI9PT10LnR5cGUmJih0LnRyYW5zYWN0aW9uPXIpfSh0LHIpLGZ1bmN0aW9uKHQsZSl7dC5maW5nZXJwcmludD10LmZpbmdlcnByaW50P2Z1bmN0aW9uKHQpe3JldHVybiBBcnJheS5pc0FycmF5KHQpP3Q6W3RdfSh0LmZpbmdlcnByaW50KTpbXSxlJiYodC5maW5nZXJwcmludD10LmZpbmdlcnByaW50LmNvbmNhdChlKSk7dC5maW5nZXJwcmludCYmIXQuZmluZ2VycHJpbnQubGVuZ3RoJiZkZWxldGUgdC5maW5nZXJwcmludH0odCxuKSxmdW5jdGlvbih0LGUpe2NvbnN0IG49Wy4uLnQuYnJlYWRjcnVtYnN8fFtdLC4uLmVdO3QuYnJlYWRjcnVtYnM9bi5sZW5ndGg/bjp2b2lkIDB9KHQsbyksZnVuY3Rpb24odCxlKXt0LnNka1Byb2Nlc3NpbmdNZXRhZGF0YT17Li4udC5zZGtQcm9jZXNzaW5nTWV0YWRhdGEsLi4uZX19KHQscyl9Y29uc3QgWXQ9IjciO2Z1bmN0aW9uIHF0KHQsZSl7cmV0dXJuIG49e3NlbnRyeV9rZXk6dC5wdWJsaWNLZXksc2VudHJ5X3ZlcnNpb246WXQsLi4uZSYme3NlbnRyeV9jbGllbnQ6YCR7ZS5uYW1lfS8ke2UudmVyc2lvbn1gfX0sT2JqZWN0LmtleXMobikubWFwKCh0PT5gJHtlbmNvZGVVUklDb21wb25lbnQodCl9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KG5bdF0pfWApKS5qb2luKCImIik7dmFyIG59Y29uc3QgRnQ9NjQ7ZnVuY3Rpb24gS3QodCxlLG49Vih0LmJ1ZmZlclNpemV8fEZ0KSl7bGV0IHI9e307cmV0dXJue3NlbmQ6ZnVuY3Rpb24obyl7Y29uc3Qgcz1bXTtpZihYKG8sKChlLG4pPT57Y29uc3Qgbz1ydChuKTtpZihmdW5jdGlvbih0LGUsbj1EYXRlLm5vdygpKXtyZXR1cm4gZnVuY3Rpb24odCxlKXtyZXR1cm4gdFtlXXx8dC5hbGx8fDB9KHQsZSk+bn0ocixvKSl7Y29uc3Qgcj1WdChlLG4pO3QucmVjb3JkRHJvcHBlZEV2ZW50KCJyYXRlbGltaXRfYmFja29mZiIsbyxyKX1lbHNlIHMucHVzaChlKX0pKSwwPT09cy5sZW5ndGgpcmV0dXJuIEYoe30pO2NvbnN0IGk9UShvWzBdLHMpLGM9ZT0+e1goaSwoKG4scik9Pntjb25zdCBvPVZ0KG4scik7dC5yZWNvcmREcm9wcGVkRXZlbnQoZSxydChyKSxvKX0pKX07cmV0dXJuIG4uYWRkKCgoKT0+ZSh7Ym9keTpldChpKX0pLnRoZW4oKHQ9Pih2b2lkIDAhPT10LnN0YXR1c0NvZGUmJih0LnN0YXR1c0NvZGU8MjAwfHx0LnN0YXR1c0NvZGU+PTMwMCkmJmN0JiZOLndhcm4oYFNlbnRyeSByZXNwb25kZWQgd2l0aCBzdGF0dXMgY29kZSAke3Quc3RhdHVzQ29kZX0gdG8gc2VudCBldmVudC5gKSxyPWl0KHIsdCksdCkpLCh0PT57dGhyb3cgYygibmV0d29ya19lcnJvciIpLHR9KSkpKS50aGVuKCh0PT50KSwodD0+e2lmKHQgaW5zdGFuY2VvZiBDKXJldHVybiBjdCYmTi5lcnJvcigiU2tpcHBlZCBzZW5kaW5nIGV2ZW50IGJlY2F1c2UgYnVmZmVyIGlzIGZ1bGwuIiksYygicXVldWVfb3ZlcmZsb3ciKSxGKHt9KTt0aHJvdyB0fSkpfSxmbHVzaDp0PT5uLmRyYWluKHQpfX1mdW5jdGlvbiBWdCh0LGUpe2lmKCJldmVudCI9PT1lfHwidHJhbnNhY3Rpb24iPT09ZSlyZXR1cm4gQXJyYXkuaXNBcnJheSh0KT90WzFdOnZvaWQgMH1jb25zdCBadD1TeW1ib2woIkFnZW50QmFzZUludGVybmFsU3RhdGUiKTtjbGFzcyBRdCBleHRlbmRzIGguQWdlbnR7W1p0XTtvcHRpb25zO2tlZXBBbGl2ZTtjb25zdHJ1Y3Rvcih0KXtzdXBlcih0KSx0aGlzW1p0XT17fX1pc1NlY3VyZUVuZHBvaW50KHQpe2lmKHQpe2lmKCJib29sZWFuIj09dHlwZW9mIHQuc2VjdXJlRW5kcG9pbnQpcmV0dXJuIHQuc2VjdXJlRW5kcG9pbnQ7aWYoInN0cmluZyI9PXR5cGVvZiB0LnByb3RvY29sKXJldHVybiJodHRwczoiPT09dC5wcm90b2NvbH1jb25zdHtzdGFjazplfT1uZXcgRXJyb3I7cmV0dXJuInN0cmluZyI9PXR5cGVvZiBlJiZlLnNwbGl0KCJcbiIpLnNvbWUoKHQ9Pi0xIT09dC5pbmRleE9mKCIoaHR0cHMuanM6Iil8fC0xIT09dC5pbmRleE9mKCJub2RlOmh0dHBzOiIpKSl9Y3JlYXRlU29ja2V0KHQsZSxuKXtjb25zdCByPXsuLi5lLHNlY3VyZUVuZHBvaW50OnRoaXMuaXNTZWN1cmVFbmRwb2ludChlKX07UHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKCk9PnRoaXMuY29ubmVjdCh0LHIpKSkudGhlbigobz0+e2lmKG8gaW5zdGFuY2VvZiBoLkFnZW50KXJldHVybiBvLmFkZFJlcXVlc3QodCxyKTt0aGlzW1p0XS5jdXJyZW50U29ja2V0PW8sc3VwZXIuY3JlYXRlU29ja2V0KHQsZSxuKX0pLG4pfWNyZWF0ZUNvbm5lY3Rpb24oKXtjb25zdCB0PXRoaXNbWnRdLmN1cnJlbnRTb2NrZXQ7aWYodGhpc1tadF0uY3VycmVudFNvY2tldD12b2lkIDAsIXQpdGhyb3cgbmV3IEVycm9yKCJObyBzb2NrZXQgd2FzIHJldHVybmVkIGluIHRoZSBgY29ubmVjdCgpYCBmdW5jdGlvbiIpO3JldHVybiB0fWdldCBkZWZhdWx0UG9ydCgpe3JldHVybiB0aGlzW1p0XS5kZWZhdWx0UG9ydD8/KCJodHRwczoiPT09dGhpcy5wcm90b2NvbD80NDM6ODApfXNldCBkZWZhdWx0UG9ydCh0KXt0aGlzW1p0XSYmKHRoaXNbWnRdLmRlZmF1bHRQb3J0PXQpfWdldCBwcm90b2NvbCgpe3JldHVybiB0aGlzW1p0XS5wcm90b2NvbD8/KHRoaXMuaXNTZWN1cmVFbmRwb2ludCgpPyJodHRwczoiOiJodHRwOiIpfXNldCBwcm90b2NvbCh0KXt0aGlzW1p0XSYmKHRoaXNbWnRdLnByb3RvY29sPXQpfX1mdW5jdGlvbiBYdCguLi50KXtOLmxvZygiW2h0dHBzLXByb3h5LWFnZW50OnBhcnNlLXByb3h5LXJlc3BvbnNlXSIsLi4udCl9ZnVuY3Rpb24gdGUodCl7cmV0dXJuIG5ldyBQcm9taXNlKCgoZSxuKT0+e2xldCByPTA7Y29uc3Qgbz1bXTtmdW5jdGlvbiBzKCl7Y29uc3QgYz10LnJlYWQoKTtjP2Z1bmN0aW9uKGMpe28ucHVzaChjKSxyKz1jLmxlbmd0aDtjb25zdCB1PUJ1ZmZlci5jb25jYXQobyxyKSxhPXUuaW5kZXhPZigiXHJcblxyXG4iKTtpZigtMT09PWEpcmV0dXJuIFh0KCJoYXZlIG5vdCByZWNlaXZlZCBlbmQgb2YgSFRUUCBoZWFkZXJzIHlldC4uLiIpLHZvaWQgcygpO2NvbnN0IGY9dS5zbGljZSgwLGEpLnRvU3RyaW5nKCJhc2NpaSIpLnNwbGl0KCJcclxuIiksaD1mLnNoaWZ0KCk7aWYoIWgpcmV0dXJuIHQuZGVzdHJveSgpLG4obmV3IEVycm9yKCJObyBoZWFkZXIgcmVjZWl2ZWQgZnJvbSBwcm94eSBDT05ORUNUIHJlc3BvbnNlIikpO2NvbnN0IHA9aC5zcGxpdCgiICIpLGw9K3BbMV0sZD1wLnNsaWNlKDIpLmpvaW4oIiAiKSxtPXt9O2Zvcihjb25zdCBlIG9mIGYpe2lmKCFlKWNvbnRpbnVlO2NvbnN0IHI9ZS5pbmRleE9mKCI6Iik7aWYoLTE9PT1yKXJldHVybiB0LmRlc3Ryb3koKSxuKG5ldyBFcnJvcihgSW52YWxpZCBoZWFkZXIgZnJvbSBwcm94eSBDT05ORUNUIHJlc3BvbnNlOiAiJHtlfSJgKSk7Y29uc3Qgbz1lLnNsaWNlKDAscikudG9Mb3dlckNhc2UoKSxzPWUuc2xpY2UocisxKS50cmltU3RhcnQoKSxpPW1bb107InN0cmluZyI9PXR5cGVvZiBpP21bb109W2ksc106QXJyYXkuaXNBcnJheShpKT9pLnB1c2gocyk6bVtvXT1zfVh0KCJnb3QgcHJveHkgc2VydmVyIHJlc3BvbnNlOiAlbyAlbyIsaCxtKSxpKCksZSh7Y29ubmVjdDp7c3RhdHVzQ29kZTpsLHN0YXR1c1RleHQ6ZCxoZWFkZXJzOm19LGJ1ZmZlcmVkOnV9KX0oYyk6dC5vbmNlKCJyZWFkYWJsZSIscyl9ZnVuY3Rpb24gaSgpe3QucmVtb3ZlTGlzdGVuZXIoImVuZCIsYyksdC5yZW1vdmVMaXN0ZW5lcigiZXJyb3IiLHUpLHQucmVtb3ZlTGlzdGVuZXIoInJlYWRhYmxlIixzKX1mdW5jdGlvbiBjKCl7aSgpLFh0KCJvbmVuZCIpLG4obmV3IEVycm9yKCJQcm94eSBjb25uZWN0aW9uIGVuZGVkIGJlZm9yZSByZWNlaXZpbmcgQ09OTkVDVCByZXNwb25zZSIpKX1mdW5jdGlvbiB1KHQpe2koKSxYdCgib25lcnJvciAlbyIsdCksbih0KX10Lm9uKCJlcnJvciIsdSksdC5vbigiZW5kIixjKSxzKCl9KSl9ZnVuY3Rpb24gZWUoLi4udCl7Ti5sb2coIltodHRwcy1wcm94eS1hZ2VudF0iLC4uLnQpfWNsYXNzIG5lIGV4dGVuZHMgUXR7c3RhdGljIHByb3RvY29scz1bImh0dHAiLCJodHRwcyJdO3Byb3h5O3Byb3h5SGVhZGVycztjb25uZWN0T3B0cztjb25zdHJ1Y3Rvcih0LGUpe3N1cGVyKGUpLHRoaXMub3B0aW9ucz17fSx0aGlzLnByb3h5PSJzdHJpbmciPT10eXBlb2YgdD9uZXcgVVJMKHQpOnQsdGhpcy5wcm94eUhlYWRlcnM9ZT8uaGVhZGVycz8/e30sZWUoIkNyZWF0aW5nIG5ldyBIdHRwc1Byb3h5QWdlbnQgaW5zdGFuY2U6ICVvIix0aGlzLnByb3h5LmhyZWYpO2NvbnN0IG49KHRoaXMucHJveHkuaG9zdG5hbWV8fHRoaXMucHJveHkuaG9zdCkucmVwbGFjZSgvXlxbfFxdJC9nLCIiKSxyPXRoaXMucHJveHkucG9ydD9wYXJzZUludCh0aGlzLnByb3h5LnBvcnQsMTApOiJodHRwczoiPT09dGhpcy5wcm94eS5wcm90b2NvbD80NDM6ODA7dGhpcy5jb25uZWN0T3B0cz17QUxQTlByb3RvY29sczpbImh0dHAvMS4xIl0sLi4uZT9vZShlLCJoZWFkZXJzIik6bnVsbCxob3N0Om4scG9ydDpyfX1hc3luYyBjb25uZWN0KHQsZSl7Y29uc3R7cHJveHk6bn09dGhpcztpZighZS5ob3N0KXRocm93IG5ldyBUeXBlRXJyb3IoJ05vICJob3N0IiBwcm92aWRlZCcpO2xldCByO2lmKCJodHRwczoiPT09bi5wcm90b2NvbCl7ZWUoIkNyZWF0aW5nIGB0bHMuU29ja2V0YDogJW8iLHRoaXMuY29ubmVjdE9wdHMpO2NvbnN0IHQ9dGhpcy5jb25uZWN0T3B0cy5zZXJ2ZXJuYW1lfHx0aGlzLmNvbm5lY3RPcHRzLmhvc3Q7cj1mLmNvbm5lY3Qoey4uLnRoaXMuY29ubmVjdE9wdHMsc2VydmVybmFtZTp0JiZhLmlzSVAodCk/dm9pZCAwOnR9KX1lbHNlIGVlKCJDcmVhdGluZyBgbmV0LlNvY2tldGA6ICVvIix0aGlzLmNvbm5lY3RPcHRzKSxyPWEuY29ubmVjdCh0aGlzLmNvbm5lY3RPcHRzKTtjb25zdCBvPSJmdW5jdGlvbiI9PXR5cGVvZiB0aGlzLnByb3h5SGVhZGVycz90aGlzLnByb3h5SGVhZGVycygpOnsuLi50aGlzLnByb3h5SGVhZGVyc30scz1hLmlzSVB2NihlLmhvc3QpP2BbJHtlLmhvc3R9XWA6ZS5ob3N0O2xldCBpPWBDT05ORUNUICR7c306JHtlLnBvcnR9IEhUVFAvMS4xXHJcbmA7aWYobi51c2VybmFtZXx8bi5wYXNzd29yZCl7Y29uc3QgdD1gJHtkZWNvZGVVUklDb21wb25lbnQobi51c2VybmFtZSl9OiR7ZGVjb2RlVVJJQ29tcG9uZW50KG4ucGFzc3dvcmQpfWA7b1siUHJveHktQXV0aG9yaXphdGlvbiJdPWBCYXNpYyAke0J1ZmZlci5mcm9tKHQpLnRvU3RyaW5nKCJiYXNlNjQiKX1gfW8uSG9zdD1gJHtzfToke2UucG9ydH1gLG9bIlByb3h5LUNvbm5lY3Rpb24iXXx8KG9bIlByb3h5LUNvbm5lY3Rpb24iXT10aGlzLmtlZXBBbGl2ZT8iS2VlcC1BbGl2ZSI6ImNsb3NlIik7Zm9yKGNvbnN0IHQgb2YgT2JqZWN0LmtleXMobykpaSs9YCR7dH06ICR7b1t0XX1cclxuYDtjb25zdCBjPXRlKHIpO3Iud3JpdGUoYCR7aX1cclxuYCk7Y29uc3R7Y29ubmVjdDp1LGJ1ZmZlcmVkOmh9PWF3YWl0IGM7aWYodC5lbWl0KCJwcm94eUNvbm5lY3QiLHUpLHRoaXMuZW1pdCgicHJveHlDb25uZWN0Iix1LHQpLDIwMD09PXUuc3RhdHVzQ29kZSl7aWYodC5vbmNlKCJzb2NrZXQiLHJlKSxlLnNlY3VyZUVuZHBvaW50KXtlZSgiVXBncmFkaW5nIHNvY2tldCBjb25uZWN0aW9uIHRvIFRMUyIpO2NvbnN0IHQ9ZS5zZXJ2ZXJuYW1lfHxlLmhvc3Q7cmV0dXJuIGYuY29ubmVjdCh7Li4ub2UoZSwiaG9zdCIsInBhdGgiLCJwb3J0Iiksc29ja2V0OnIsc2VydmVybmFtZTphLmlzSVAodCk/dm9pZCAwOnR9KX1yZXR1cm4gcn1yLmRlc3Ryb3koKTtjb25zdCBwPW5ldyBhLlNvY2tldCh7d3JpdGFibGU6ITF9KTtyZXR1cm4gcC5yZWFkYWJsZT0hMCx0Lm9uY2UoInNvY2tldCIsKHQ9PntlZSgiUmVwbGF5aW5nIHByb3h5IGJ1ZmZlciBmb3IgZmFpbGVkIHJlcXVlc3QiKSx0LnB1c2goaCksdC5wdXNoKG51bGwpfSkpLHB9fWZ1bmN0aW9uIHJlKHQpe3QucmVzdW1lKCl9ZnVuY3Rpb24gb2UodCwuLi5lKXtjb25zdCBuPXt9O2xldCByO2ZvcihyIGluIHQpZS5pbmNsdWRlcyhyKXx8KG5bcl09dFtyXSk7cmV0dXJuIG59Y29uc3Qgc2U9MzI3Njg7ZnVuY3Rpb24gaWUodCl7cmV0dXJuIHQucmVwbGFjZSgvXltBLVpdOi8sIiIpLnJlcGxhY2UoL1xcL2csIi8iKX1jb25zdCBjZT1uO2xldCB1ZSxhZT0hMTtmdW5jdGlvbiBmZSh0KXtjZS5kZWJ1ZyYmY29uc29sZS5sb2coYFtBTlIgV29ya2VyXSAke3R9YCl9dmFyIGhlLHBlLGxlO2NvbnN0IGRlPWZ1bmN0aW9uKHQpe2xldCBlO3RyeXtlPW5ldyBVUkwodC51cmwpfWNhdGNoKGUpe3JldHVybiB4KCgoKT0+e2NvbnNvbGUud2FybigiW0BzZW50cnkvbm9kZV06IEludmFsaWQgZHNuIG9yIHR1bm5lbCBvcHRpb24sIHdpbGwgbm90IHNlbmQgYW55IGV2ZW50cy4gVGhlIHR1bm5lbCBvcHRpb24gbXVzdCBiZSBhIGZ1bGwgVVJMIHdoZW4gdXNlZC4iKX0pKSxLdCh0LCgoKT0+UHJvbWlzZS5yZXNvbHZlKHt9KSkpfWNvbnN0IG49Imh0dHBzOiI9PT1lLnByb3RvY29sLHI9ZnVuY3Rpb24odCxlKXtjb25zdHtub19wcm94eTpufT1wcm9jZXNzLmVudjtyZXR1cm4gbiYmbi5zcGxpdCgiLCIpLnNvbWUoKGU9PnQuaG9zdC5lbmRzV2l0aChlKXx8dC5ob3N0bmFtZS5lbmRzV2l0aChlKSkpP3ZvaWQgMDplfShlLHQucHJveHl8fChuP3Byb2Nlc3MuZW52Lmh0dHBzX3Byb3h5OnZvaWQgMCl8fHByb2Nlc3MuZW52Lmh0dHBfcHJveHkpLG89bj9pOnMsYT12b2lkIDAhPT10LmtlZXBBbGl2ZSYmdC5rZWVwQWxpdmUsZj1yP25ldyBuZShyKTpuZXcgby5BZ2VudCh7a2VlcEFsaXZlOmEsbWF4U29ja2V0czozMCx0aW1lb3V0OjJlM30pO3JldHVybiBIdCgoKCk9Pntjb25zdCBlPWZ1bmN0aW9uKHQsZSxuKXtjb25zdHtob3N0bmFtZTpyLHBhdGhuYW1lOm8scG9ydDpzLHByb3RvY29sOmksc2VhcmNoOmF9PW5ldyBVUkwodC51cmwpO3JldHVybiBmdW5jdGlvbihmKXtyZXR1cm4gbmV3IFByb21pc2UoKChoLHApPT57bGV0IGw9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBjKHtyZWFkKCl7dGhpcy5wdXNoKHQpLHRoaXMucHVzaChudWxsKX19KX0oZi5ib2R5KTtjb25zdCBkPXsuLi50LmhlYWRlcnN9O2YuYm9keS5sZW5ndGg+c2UmJihkWyJjb250ZW50LWVuY29kaW5nIl09Imd6aXAiLGw9bC5waXBlKHUoKSkpO2NvbnN0IG09ZS5yZXF1ZXN0KHttZXRob2Q6IlBPU1QiLGFnZW50Om4saGVhZGVyczpkLGhvc3RuYW1lOnIscGF0aDpgJHtvfSR7YX1gLHBvcnQ6cyxwcm90b2NvbDppLGNhOnQuY2FDZXJ0c30sKHQ9Pnt0Lm9uKCJkYXRhIiwoKCk9Pnt9KSksdC5vbigiZW5kIiwoKCk9Pnt9KSksdC5zZXRFbmNvZGluZygidXRmOCIpO2NvbnN0IGU9dC5oZWFkZXJzWyJyZXRyeS1hZnRlciJdPz9udWxsLG49dC5oZWFkZXJzWyJ4LXNlbnRyeS1yYXRlLWxpbWl0cyJdPz9udWxsO2goe3N0YXR1c0NvZGU6dC5zdGF0dXNDb2RlLGhlYWRlcnM6eyJyZXRyeS1hZnRlciI6ZSwieC1zZW50cnktcmF0ZS1saW1pdHMiOkFycmF5LmlzQXJyYXkobik/blswXTpufX0pfSkpO20ub24oImVycm9yIixwKSxsLnBpcGUobSl9KSl9fSh0LHQuaHR0cE1vZHVsZT8/byxmKTtyZXR1cm4gS3QodCxlKX0pKX0oe3VybDooaGU9Y2UuZHNuLHBlPWNlLnR1bm5lbCxsZT1jZS5zZGtNZXRhZGF0YS5zZGsscGV8fGAke2Z1bmN0aW9uKHQpe3JldHVybmAke2Z1bmN0aW9uKHQpe2NvbnN0IGU9dC5wcm90b2NvbD9gJHt0LnByb3RvY29sfTpgOiIiLG49dC5wb3J0P2A6JHt0LnBvcnR9YDoiIjtyZXR1cm5gJHtlfS8vJHt0Lmhvc3R9JHtufSR7dC5wYXRoP2AvJHt0LnBhdGh9YDoiIn0vYXBpL2B9KHQpfSR7dC5wcm9qZWN0SWR9L2VudmVsb3BlL2B9KGhlKX0/JHtxdChoZSxsZSl9YCkscmVjb3JkRHJvcHBlZEV2ZW50OigpPT57fX0pO2FzeW5jIGZ1bmN0aW9uIG1lKCl7aWYodWUpe2ZlKCJTZW5kaW5nIGFibm9ybWFsIHNlc3Npb24iKSxodCh1ZSx7c3RhdHVzOiJhYm5vcm1hbCIsYWJub3JtYWxfbWVjaGFuaXNtOiJhbnJfZm9yZWdyb3VuZCJ9KTtjb25zdCB0PWZ1bmN0aW9uKHQsZSxuLHIpe2NvbnN0IG89b3Qobik7cmV0dXJuIFEoe3NlbnRfYXQ6KG5ldyBEYXRlKS50b0lTT1N0cmluZygpLC4uLm8mJntzZGs6b30sLi4uISFyJiZlJiZ7ZHNuOmsoZSl9fSxbImFnZ3JlZ2F0ZXMiaW4gdD9be3R5cGU6InNlc3Npb25zIn0sdF06W3t0eXBlOiJzZXNzaW9uIn0sdC50b0pTT04oKV1dKX0odWUsY2UuZHNuLGNlLnNka01ldGFkYXRhLGNlLnR1bm5lbCk7ZmUoSlNPTi5zdHJpbmdpZnkodCkpLGF3YWl0IGRlLnNlbmQodCk7dHJ5e2U/LnBvc3RNZXNzYWdlKCJzZXNzaW9uLWVuZGVkIil9Y2F0Y2godCl7fX19ZnVuY3Rpb24gZ2UodCl7aWYoIXQpcmV0dXJuO2NvbnN0IGU9ZnVuY3Rpb24odCl7aWYoIXQubGVuZ3RoKXJldHVybltdO2NvbnN0IGU9QXJyYXkuZnJvbSh0KTtyZXR1cm4vc2VudHJ5V3JhcHBlZC8udGVzdChlW2UubGVuZ3RoLTFdLmZ1bmN0aW9ufHwiIikmJmUucG9wKCksZS5yZXZlcnNlKCksUC50ZXN0KGVbZS5sZW5ndGgtMV0uZnVuY3Rpb258fCIiKSYmKGUucG9wKCksUC50ZXN0KGVbZS5sZW5ndGgtMV0uZnVuY3Rpb258fCIiKSYmZS5wb3AoKSksZS5zbGljZSgwLEEpLm1hcCgodD0+KHsuLi50LGZpbGVuYW1lOnQuZmlsZW5hbWV8fGVbZS5sZW5ndGgtMV0uZmlsZW5hbWUsZnVuY3Rpb246dC5mdW5jdGlvbnx8SX0pKSl9KHQpO2lmKGNlLmFwcFJvb3RQYXRoKWZvcihjb25zdCB0IG9mIGUpdC5maWxlbmFtZSYmKHQuZmlsZW5hbWU9SCh0LmZpbGVuYW1lLGNlLmFwcFJvb3RQYXRoKSk7cmV0dXJuIGV9YXN5bmMgZnVuY3Rpb24geWUodCxlKXtpZihhZSlyZXR1cm47YWU9ITAsYXdhaXQgbWUoKSxmZSgiU2VuZGluZyBldmVudCIpO2NvbnN0IG49e2V2ZW50X2lkOkcoKSxjb250ZXh0czpjZS5jb250ZXh0cyxyZWxlYXNlOmNlLnJlbGVhc2UsZW52aXJvbm1lbnQ6Y2UuZW52aXJvbm1lbnQsZGlzdDpjZS5kaXN0LHBsYXRmb3JtOiJub2RlIixsZXZlbDoiZXJyb3IiLGV4Y2VwdGlvbjp7dmFsdWVzOlt7dHlwZToiQXBwbGljYXRpb25Ob3RSZXNwb25kaW5nIix2YWx1ZTpgQXBwbGljYXRpb24gTm90IFJlc3BvbmRpbmcgZm9yIGF0IGxlYXN0ICR7Y2UuYW5yVGhyZXNob2xkfSBtc2Asc3RhY2t0cmFjZTp7ZnJhbWVzOmdlKHQpfSxtZWNoYW5pc206e3R5cGU6IkFOUiJ9fV19LHRhZ3M6Y2Uuc3RhdGljVGFnc307ZSYmZnVuY3Rpb24odCxlKXtpZihXdCh0LGUpLCF0LmNvbnRleHRzPy50cmFjZSl7Y29uc3R7dHJhY2VJZDpuLHNwYW5JZDpyLHBhcmVudFNwYW5JZDpvfT1lLnByb3BhZ2F0aW9uQ29udGV4dDt0LmNvbnRleHRzPXt0cmFjZTp7dHJhY2VfaWQ6bixzcGFuX2lkOnIscGFyZW50X3NwYW5faWQ6b30sLi4udC5jb250ZXh0c319fShuLGUpO2NvbnN0IHI9SnQobixjZS5kc24sY2Uuc2RrTWV0YWRhdGEsY2UudHVubmVsKTtmZShKU09OLnN0cmluZ2lmeShyKSksYXdhaXQgZGUuc2VuZChyKSxhd2FpdCBkZS5mbHVzaCgyZTMpLHNldFRpbWVvdXQoKCgpPT57cHJvY2Vzcy5leGl0KDApfSksNWUzKX1sZXQgYmU7aWYoZmUoIlN0YXJ0ZWQiKSxjZS5jYXB0dXJlU3RhY2tUcmFjZSl7ZmUoIkNvbm5lY3RpbmcgdG8gZGVidWdnZXIiKTtjb25zdCBlPW5ldyB0O2UuY29ubmVjdFRvTWFpblRocmVhZCgpLGZlKCJDb25uZWN0ZWQgdG8gZGVidWdnZXIiKTtjb25zdCBuPW5ldyBNYXA7ZS5vbigiRGVidWdnZXIuc2NyaXB0UGFyc2VkIiwodD0+e24uc2V0KHQucGFyYW1zLnNjcmlwdElkLHQucGFyYW1zLnVybCl9KSksZS5vbigiRGVidWdnZXIucGF1c2VkIiwodD0+e2lmKCJvdGhlciI9PT10LnBhcmFtcy5yZWFzb24pdHJ5e2ZlKCJEZWJ1Z2dlciBwYXVzZWQiKTtjb25zdCBzPVsuLi50LnBhcmFtcy5jYWxsRnJhbWVzXSxpPWNlLmFwcFJvb3RQYXRoP2Z1bmN0aW9uKHQ9KHByb2Nlc3MuYXJndlsxXT9ZKHByb2Nlc3MuYXJndlsxXSk6cHJvY2Vzcy5jd2QoKSksZT0iXFwiPT09byl7Y29uc3Qgbj1lP2llKHQpOnQ7cmV0dXJuIHQ9PntpZighdClyZXR1cm47Y29uc3Qgbz1lP2llKHQpOnQ7bGV0e2RpcjpzLGJhc2U6aSxleHQ6Y309ci5wYXJzZShvKTsiLmpzIiE9PWMmJiIubWpzIiE9PWMmJiIuY2pzIiE9PWN8fChpPWkuc2xpY2UoMCwtMSpjLmxlbmd0aCkpLHN8fChzPSIuIik7Y29uc3QgdT1zLmxhc3RJbmRleE9mKCIvbm9kZV9tb2R1bGVzIik7aWYodT4tMSlyZXR1cm5gJHtzLnNsaWNlKHUrMTQpLnJlcGxhY2UoL1wvL2csIi4iKX06JHtpfWA7aWYocy5zdGFydHNXaXRoKG4pKXtsZXQgdD1zLnNsaWNlKG4ubGVuZ3RoKzEpLnJlcGxhY2UoL1wvL2csIi4iKTtyZXR1cm4gdCYmKHQrPSI6IiksdCs9aSx0fXJldHVybiBpfX0oY2UuYXBwUm9vdFBhdGgpOigpPT57fSxjPXMubWFwKCh0PT5mdW5jdGlvbih0LGUsbil7Y29uc3Qgcj1lP2UucmVwbGFjZSgvXmZpbGU6XC9cLy8sIiIpOnZvaWQgMCxvPXQubG9jYXRpb24uY29sdW1uTnVtYmVyP3QubG9jYXRpb24uY29sdW1uTnVtYmVyKzE6dm9pZCAwLHM9dC5sb2NhdGlvbi5saW5lTnVtYmVyP3QubG9jYXRpb24ubGluZU51bWJlcisxOnZvaWQgMDtyZXR1cm4gaih7ZmlsZW5hbWU6cixtb2R1bGU6bihyKSxmdW5jdGlvbjp0LmZ1bmN0aW9uTmFtZXx8SSxjb2xubzpvLGxpbmVubzpzLGluX2FwcDpyP1oocik6dm9pZCAwfSl9KHQsbi5nZXQodC5sb2NhdGlvbi5zY3JpcHRJZCksaSkpKSx1PXNldFRpbWVvdXQoKCgpPT57eWUoYykudGhlbihudWxsLCgoKT0+e2ZlKCJTZW5kaW5nIEFOUiBldmVudCBmYWlsZWQuIil9KSl9KSw1ZTMpO2UucG9zdCgiUnVudGltZS5ldmFsdWF0ZSIse2V4cHJlc3Npb246Imdsb2JhbC5fX1NFTlRSWV9HRVRfU0NPUEVTX18oKTsiLHNpbGVudDohMCxyZXR1cm5CeVZhbHVlOiEwfSwoKHQsbik9Pnt0JiZmZShgRXJyb3IgZXhlY3V0aW5nIHNjcmlwdDogJyR7dC5tZXNzYWdlfSdgKSxjbGVhclRpbWVvdXQodSk7Y29uc3Qgcj1uJiZuLnJlc3VsdD9uLnJlc3VsdC52YWx1ZTp2b2lkIDA7ZS5wb3N0KCJEZWJ1Z2dlci5yZXN1bWUiKSxlLnBvc3QoIkRlYnVnZ2VyLmRpc2FibGUiKSx5ZShjLHIpLnRoZW4obnVsbCwoKCk9PntmZSgiU2VuZGluZyBBTlIgZXZlbnQgZmFpbGVkLiIpfSkpfSkpfWNhdGNoKHQpe3Rocm93IGUucG9zdCgiRGVidWdnZXIucmVzdW1lIiksZS5wb3N0KCJEZWJ1Z2dlci5kaXNhYmxlIiksdH19KSksYmU9KCk9Pnt0cnl7ZS5wb3N0KCJEZWJ1Z2dlci5lbmFibGUiLCgoKT0+e2UucG9zdCgiRGVidWdnZXIucGF1c2UiKX0pKX1jYXRjaCh0KXt9fX1jb25zdHtwb2xsOnZlfT1mdW5jdGlvbih0LGUsbixyKXtjb25zdCBvPXQoKTtsZXQgcz0hMSxpPSEwO3JldHVybiBzZXRJbnRlcnZhbCgoKCk9Pntjb25zdCB0PW8uZ2V0VGltZU1zKCk7ITE9PT1zJiZ0PmUrbiYmKHM9ITAsaSYmcigpKSx0PGUrbiYmKHM9ITEpfSksMjApLHtwb2xsOigpPT57by5yZXNldCgpfSxlbmFibGVkOnQ9PntpPXR9fX0oKGZ1bmN0aW9uKCl7bGV0IHQ9cHJvY2Vzcy5ocnRpbWUoKTtyZXR1cm57Z2V0VGltZU1zOigpPT57Y29uc3RbZSxuXT1wcm9jZXNzLmhydGltZSh0KTtyZXR1cm4gTWF0aC5mbG9vcigxZTMqZStuLzFlNil9LHJlc2V0OigpPT57dD1wcm9jZXNzLmhydGltZSgpfX19KSxjZS5wb2xsSW50ZXJ2YWwsY2UuYW5yVGhyZXNob2xkLChmdW5jdGlvbigpe2ZlKCJXYXRjaGRvZyB0aW1lb3V0IiksYmU/KGZlKCJQYXVzaW5nIGRlYnVnZ2VyIHRvIGNhcHR1cmUgc3RhY2sgdHJhY2UiKSxiZSgpKTooZmUoIkNhcHR1cmluZyBldmVudCB3aXRob3V0IGEgc3RhY2sgdHJhY2UiKSx5ZSgpLnRoZW4obnVsbCwoKCk9PntmZSgiU2VuZGluZyBBTlIgZXZlbnQgZmFpbGVkIG9uIHdhdGNoZG9nIHRpbWVvdXQuIil9KSkpfSkpO2U/Lm9uKCJtZXNzYWdlIiwodD0+e3Quc2Vzc2lvbiYmKHVlPWZ0KHQuc2Vzc2lvbikpLHZlKCl9KSk7";
function aB(t, ...n) {
  it.log(`[ANR] ${t}`, ...n);
}
function lB() {
  const t = ZU().getScopeData();
  return (
    zW(t, wU().getScopeData()),
    zW(t, MU().getScopeData()),
    (t.attachments = []),
    (t.eventProcessors = []),
    t
  );
}
const fB = (t = {}) => {
  if (CK.major < 16 || (16 === CK.major && CK.minor < 17))
    throw new Error("ANR detection requires Node 16.17.0 or later");
  let n, e;
  return (
    (Q.__SENTRY_GET_SCOPES__ = lB),
    {
      name: "Anr",
      startWorker: () => {
        n ||
          (e &&
            (n = (async function (t, n) {
              const e = t.getDsn();
              if (!e) return () => {};
              const r = await (async function (t) {
                let n = { message: "ANR" };
                const e = {};
                for (const r of t.getEventProcessors()) {
                  if (null === n) break;
                  n = await r(n, e);
                }
                return Fn([n, "optionalAccess", (t) => t.contexts]) || {};
              })(t);
              Jn([
                r,
                "access",
                (t) => t.app,
                "optionalAccess",
                (t) => delete t.app_memory,
              ]),
                Jn([
                  r,
                  "access",
                  (t) => t.device,
                  "optionalAccess",
                  (t) => delete t.free_memory,
                ]);
              const o = t.getOptions(),
                i = t.getSdkMetadata() || {};
              i.sdk && (i.sdk.integrations = o.integrations.map((t) => t.name));
              const s = {
                debug: it.isEnabled(),
                dsn: e,
                tunnel: o.tunnel,
                environment: o.environment || "production",
                release: o.release,
                dist: o.dist,
                sdkMetadata: i,
                appRootPath: n.appRootPath,
                pollInterval: n.pollInterval || 50,
                anrThreshold: n.anrThreshold || 5e3,
                captureStackTrace: !!n.captureStackTrace,
                staticTags: n.staticTags || {},
                contexts: r,
              };
              s.captureStackTrace && (N.url() || N.open(0));
              const u = new f.Worker(
                new URL(`data:application/javascript;base64,${cB}`),
                { workerData: s, execArgv: [] }
              );
              process.on("exit", () => {
                u.terminate();
              });
              const c = setInterval(() => {
                try {
                  const t = MU().getSession(),
                    n = t ? { ...t, toJSON: void 0 } : void 0;
                  u.postMessage({ session: n });
                } catch (t) {}
              }, s.pollInterval);
              return (
                c.unref(),
                u.on("message", (t) => {
                  "session-ended" === t &&
                    (aB(
                      "ANR event sent from ANR worker. Clearing session in this thread."
                    ),
                    MU().setSession(void 0));
                }),
                u.once("error", (t) => {
                  clearInterval(c), aB("ANR worker error", t);
                }),
                u.once("exit", (t) => {
                  clearInterval(c), aB("ANR worker exit", t);
                }),
                u.unref(),
                () => {
                  u.terminate(), clearInterval(c);
                }
              );
            })(e, t)));
      },
      stopWorker: () => {
        n &&
          n.then((t) => {
            t(), (n = void 0);
          });
      },
      setup(t) {
        (e = t), setImmediate(() => this.startWorker());
      },
    }
  );
};
var dB = {},
  hB = {},
  pB = Ht(Zj),
  SB = {};
!(function (t) {
  Object.defineProperty(t, "__esModule", { value: !0 }),
    (t.ExpressLayerType = void 0),
    (function (t) {
      (t.ROUTER = "router"),
        (t.MIDDLEWARE = "middleware"),
        (t.REQUEST_HANDLER = "request_handler");
    })(t.ExpressLayerType || (t.ExpressLayerType = {}));
})(SB);
var EB = {};
!(function (t) {
  Object.defineProperty(t, "__esModule", { value: !0 }),
    (t.AttributeNames = void 0),
    (function (t) {
      (t.EXPRESS_TYPE = "express.type"), (t.EXPRESS_NAME = "express.name");
    })(t.AttributeNames || (t.AttributeNames = {}));
})(EB);
var mB = {},
  TB = {};
Object.defineProperty(TB, "__esModule", { value: !0 }),
  (TB.mo = TB.kLayerPatched = void 0),
  (TB.kLayerPatched = Symbol("express-layer-patched")),
  (TB.mo = "__ot_middlewares"),
  Object.defineProperty(mB, "__esModule", { value: !0 }),
  (mB.asErrorAndMessage =
    mB.isLayerIgnored =
    mB.getLayerMetadata =
    mB.storeLayerPath =
      void 0);
const _B = SB,
  bB = EB,
  vB = TB;
mB.storeLayerPath = (t, n) => {
  !1 === Array.isArray(t[vB.mo]) &&
    Object.defineProperty(t, vB.mo, { enumerable: !1, value: [] }),
    void 0 !== n && t[vB.mo].push(n);
};
mB.getLayerMetadata = (t, n) =>
  "router" === t.name
    ? {
        attributes: {
          [bB.AttributeNames.EXPRESS_NAME]: n,
          [bB.AttributeNames.EXPRESS_TYPE]: _B.ExpressLayerType.ROUTER,
        },
        name: `router - ${n}`,
      }
    : "bound dispatch" === t.name
      ? {
          attributes: {
            [bB.AttributeNames.EXPRESS_NAME]: null != n ? n : "request handler",
            [bB.AttributeNames.EXPRESS_TYPE]:
              _B.ExpressLayerType.REQUEST_HANDLER,
          },
          name: "request handler" + (t.path ? ` - ${n}` : ""),
        }
      : {
          attributes: {
            [bB.AttributeNames.EXPRESS_NAME]: t.name,
            [bB.AttributeNames.EXPRESS_TYPE]: _B.ExpressLayerType.MIDDLEWARE,
          },
          name: `middleware - ${t.name}`,
        };
const yB = (t, n) => {
  if ("string" == typeof n) return n === t;
  if (n instanceof RegExp) return n.test(t);
  if ("function" == typeof n) return n(t);
  throw new TypeError("Pattern is in unsupported datatype");
};
mB.isLayerIgnored = (t, n, e) => {
  var r;
  if (
    Array.isArray(null == e ? void 0 : e.ignoreLayersType) &&
    (null === (r = null == e ? void 0 : e.ignoreLayersType) || void 0 === r
      ? void 0
      : r.includes(n))
  )
    return !0;
  if (!1 === Array.isArray(null == e ? void 0 : e.ignoreLayers)) return !1;
  try {
    for (const n of e.ignoreLayers) if (yB(t, n)) return !0;
  } catch (t) {}
  return !1;
};
mB.asErrorAndMessage = (t) =>
  t instanceof Error ? [t, t.message] : [String(t), String(t)];
var RB = {};
function AB(t) {
  void 0 === t && (t = []);
  for (var n = [], e = 0, r = t.length; e < r; e++) {
    var o = t[e];
    if (Array.isArray(o)) {
      var i = AB(o);
      n = n.concat(i.instrumentations);
    } else
      "function" == typeof o
        ? n.push(new o())
        : o.instrumentationName && n.push(o);
  }
  return { instrumentations: n };
}
Object.defineProperty(RB, "__esModule", { value: !0 }),
  (RB.VERSION = void 0),
  (RB.VERSION = "0.35.0");
var OB = function () {
    return (
      (OB =
        Object.assign ||
        function (t) {
          for (var n, e = 1, r = arguments.length; e < r; e++)
            for (var o in (n = arguments[e]))
              Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
          return t;
        }),
      OB.apply(this, arguments)
    );
  },
  gB = (function () {
    function t(t, n, e) {
      void 0 === e && (e = {}),
        (this.instrumentationName = t),
        (this.instrumentationVersion = n),
        (this.yt = Ty.wrap),
        (this.Rt = Ty.unwrap),
        (this.At = Ty.massWrap),
        (this.Ot = Ty.massUnwrap),
        (this.Nt = OB({ enabled: !0 }, e)),
        (this.Ct = Pr.createComponentLogger({ namespace: t })),
        (this.Lt = Qr.getTracer(t, n)),
        (this.It = Ur.getMeter(t, n)),
        this.wt();
    }
    return (
      Object.defineProperty(t.prototype, "meter", {
        get: function () {
          return this.It;
        },
        enumerable: !1,
        configurable: !0,
      }),
      (t.prototype.setMeterProvider = function (t) {
        (this.It = t.getMeter(
          this.instrumentationName,
          this.instrumentationVersion
        )),
          this.wt();
      }),
      (t.prototype.wt = function () {}),
      (t.prototype.getConfig = function () {
        return this.Nt;
      }),
      (t.prototype.setConfig = function (t) {
        void 0 === t && (t = {}), (this.Nt = Object.assign({}, t));
      }),
      (t.prototype.setTracerProvider = function (t) {
        this.Lt = t.getTracer(
          this.instrumentationName,
          this.instrumentationVersion
        );
      }),
      Object.defineProperty(t.prototype, "tracer", {
        get: function () {
          return this.Lt;
        },
        enumerable: !1,
        configurable: !0,
      }),
      t
    );
  })(),
  NB = function (t) {
    var n = "function" == typeof Symbol && Symbol.iterator,
      e = n && t[n],
      r = 0;
    if (e) return e.call(t);
    if (t && "number" == typeof t.length)
      return {
        next: function () {
          return (
            t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t }
          );
        },
      };
    throw new TypeError(
      n ? "Object is not iterable." : "Symbol.iterator is not defined."
    );
  },
  CB = function (t, n) {
    var e = "function" == typeof Symbol && t[Symbol.iterator];
    if (!e) return t;
    var r,
      o,
      i = e.call(t),
      s = [];
    try {
      for (; (void 0 === n || n-- > 0) && !(r = i.next()).done; )
        s.push(r.value);
    } catch (t) {
      o = { error: t };
    } finally {
      try {
        r && !r.done && (e = i.return) && e.call(i);
      } finally {
        if (o) throw o.error;
      }
    }
    return s;
  },
  LB = function (t, n, e) {
    if (e || 2 === arguments.length)
      for (var r, o = 0, i = n.length; o < i; o++)
        (!r && o in n) ||
          (r || (r = Array.prototype.slice.call(n, 0, o)), (r[o] = n[o]));
    return t.concat(r || Array.prototype.slice.call(n));
  },
  IB = "/",
  MB = function () {
    (this.hooks = []), (this.children = new Map());
  },
  wB = (function () {
    function t() {
      (this.rn = new MB()), (this.sn = 0);
    }
    return (
      (t.prototype.insert = function (t) {
        var n,
          e,
          r = this.rn;
        try {
          for (
            var o = NB(t.moduleName.split(IB)), i = o.next();
            !i.done;
            i = o.next()
          ) {
            var s = i.value,
              u = r.children.get(s);
            u || ((u = new MB()), r.children.set(s, u)), (r = u);
          }
        } catch (t) {
          n = { error: t };
        } finally {
          try {
            i && !i.done && (e = o.return) && e.call(o);
          } finally {
            if (n) throw n.error;
          }
        }
        r.hooks.push({ hook: t, insertedId: this.sn++ });
      }),
      (t.prototype.search = function (t, n) {
        var e,
          r,
          o = void 0 === n ? {} : n,
          i = o.maintainInsertionOrder,
          s = o.fullOnly,
          u = this.rn,
          c = [],
          a = !0;
        try {
          for (var l = NB(t.split(IB)), f = l.next(); !f.done; f = l.next()) {
            var d = f.value,
              h = u.children.get(d);
            if (!h) {
              a = !1;
              break;
            }
            s || c.push.apply(c, LB([], CB(h.hooks), !1)), (u = h);
          }
        } catch (t) {
          e = { error: t };
        } finally {
          try {
            f && !f.done && (r = l.return) && r.call(l);
          } finally {
            if (e) throw e.error;
          }
        }
        return (
          s && a && c.push.apply(c, LB([], CB(u.hooks), !1)),
          0 === c.length
            ? []
            : 1 === c.length
              ? [c[0].hook]
              : (i &&
                  c.sort(function (t, n) {
                    return t.insertedId - n.insertedId;
                  }),
                c.map(function (t) {
                  return t.hook;
                }))
        );
      }),
      t
    );
  })(),
  ZB = function (t) {
    var n = "function" == typeof Symbol && Symbol.iterator,
      e = n && t[n],
      r = 0;
    if (e) return e.call(t);
    if (t && "number" == typeof t.length)
      return {
        next: function () {
          return (
            t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t }
          );
        },
      };
    throw new TypeError(
      n ? "Object is not iterable." : "Symbol.iterator is not defined."
    );
  },
  PB = ["afterEach", "after", "beforeEach", "before", "describe", "it"].every(
    function (t) {
      return "function" == typeof global[t];
    }
  ),
  VB = (function () {
    function t() {
      (this.un = new wB()), this.cn();
    }
    return (
      (t.prototype.cn = function () {
        var t = this;
        new JR(null, { internals: !0 }, function (n, e, r) {
          var o,
            i,
            s,
            u = ((s = e), A.sep !== IB ? s.split(A.sep).join(IB) : s),
            c = t.un.search(u, {
              maintainInsertionOrder: !0,
              fullOnly: void 0 === r,
            });
          try {
            for (var a = ZB(c), l = a.next(); !l.done; l = a.next()) {
              n = (0, l.value.onRequire)(n, e, r);
            }
          } catch (t) {
            o = { error: t };
          } finally {
            try {
              l && !l.done && (i = a.return) && i.call(a);
            } finally {
              if (o) throw o.error;
            }
          }
          return n;
        });
      }),
      (t.prototype.register = function (t, n) {
        var e = { moduleName: t, onRequire: n };
        return this.un.insert(e), e;
      }),
      (t.getInstance = function () {
        var n;
        return PB
          ? new t()
          : (this.L = null !== (n = this.L) && void 0 !== n ? n : new t());
      }),
      t
    );
  })();
var GB = (function () {
    var t = function (n, e) {
      return (
        (t =
          Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array &&
            function (t, n) {
              t.__proto__ = n;
            }) ||
          function (t, n) {
            for (var e in n)
              Object.prototype.hasOwnProperty.call(n, e) && (t[e] = n[e]);
          }),
        t(n, e)
      );
    };
    return function (n, e) {
      if ("function" != typeof e && null !== e)
        throw new TypeError(
          "Class extends value " + String(e) + " is not a constructor or null"
        );
      function r() {
        this.constructor = n;
      }
      t(n, e),
        (n.prototype =
          null === e
            ? Object.create(e)
            : ((r.prototype = e.prototype), new r()));
    };
  })(),
  XB = function (t) {
    var n = "function" == typeof Symbol && Symbol.iterator,
      e = n && t[n],
      r = 0;
    if (e) return e.call(t);
    if (t && "number" == typeof t.length)
      return {
        next: function () {
          return (
            t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t }
          );
        },
      };
    throw new TypeError(
      n ? "Object is not iterable." : "Symbol.iterator is not defined."
    );
  },
  UB = (function (t) {
    function n(n, r, o) {
      void 0 === o && (o = {});
      var i = t.call(this, n, r, o) || this;
      (i.ln = []),
        (i.fn = VB.getInstance()),
        (i.dn = !1),
        (i.yt = function (t, n, r) {
          if (e.types.isProxy(t)) {
            var o = Ty.wrap(Object.assign({}, t), n, r);
            return Object.defineProperty(t, n, { value: o });
          }
          return Ty.wrap(t, n, r);
        }),
        (i.Rt = function (t, n) {
          return e.types.isProxy(t)
            ? Object.defineProperty(t, n, { value: t[n] })
            : Ty.unwrap(t, n);
        }),
        (i.At = function (t, n, e) {
          t
            ? (Array.isArray(t) || (t = [t]),
              n && Array.isArray(n)
                ? t.forEach(function (t) {
                    n.forEach(function (n) {
                      i.yt(t, n, e);
                    });
                  })
                : Pr.error(
                    "must provide one or more functions to wrap on modules"
                  ))
            : Pr.error("must provide one or more modules to patch");
        }),
        (i.Ot = function (t, n) {
          t
            ? (Array.isArray(t) || (t = [t]),
              n && Array.isArray(n)
                ? t.forEach(function (t) {
                    n.forEach(function (n) {
                      i.Rt(t, n);
                    });
                  })
                : Pr.error(
                    "must provide one or more functions to wrap on modules"
                  ))
            : Pr.error("must provide one or more modules to patch");
        });
      var s = i.init();
      return (
        s && !Array.isArray(s) && (s = [s]),
        (i.hn = s || []),
        0 === i.hn.length &&
          Pr.debug(
            "No modules instrumentation has been defined for '" +
              i.instrumentationName +
              "@" +
              i.instrumentationVersion +
              "', nothing will be patched"
          ),
        i.Nt.enabled && i.enable(),
        i
      );
    }
    return (
      GB(n, t),
      (n.prototype.pn = function () {
        var t = this;
        this.hn.forEach(function (n) {
          var e = n.name;
          try {
            var r = require.resolve(e);
            require.cache[r] &&
              t.Ct.warn(
                "Module " +
                  e +
                  " has been loaded before " +
                  t.instrumentationName +
                  " so it might not work, please initialize it before requiring " +
                  e
              );
          } catch (t) {}
        });
      }),
      (n.prototype.Sn = function (t) {
        try {
          var n = Lx(A.join(t, "package.json")).version;
          return "string" == typeof n ? n : void 0;
        } catch (n) {
          Pr.warn("Failed extracting version", t);
        }
      }),
      (n.prototype.En = function (t, n, e, r) {
        var o,
          i = this;
        if (!r)
          return "function" == typeof t.patch &&
            ((t.moduleExports = n), this.dn)
            ? t.patch(n)
            : n;
        var s = this.Sn(r);
        return (
          (t.moduleVersion = s),
          t.name === e
            ? WB(t.supportedVersions, s, t.includePrerelease) &&
              "function" == typeof t.patch &&
              ((t.moduleExports = n), this.dn)
              ? t.patch(n, t.moduleVersion)
              : n
            : (null !== (o = t.files) && void 0 !== o ? o : [])
                .filter(function (t) {
                  return t.name === e;
                })
                .filter(function (n) {
                  return WB(n.supportedVersions, s, t.includePrerelease);
                })
                .reduce(function (n, e) {
                  return (
                    (e.moduleExports = n),
                    i.dn ? e.patch(n, t.moduleVersion) : n
                  );
                }, n)
        );
      }),
      (n.prototype.enable = function () {
        var t,
          n,
          e,
          r,
          o,
          i,
          s = this;
        if (!this.dn)
          if (((this.dn = !0), this.ln.length > 0))
            try {
              for (var u = XB(this.hn), c = u.next(); !c.done; c = u.next()) {
                var a = c.value;
                "function" == typeof a.patch &&
                  a.moduleExports &&
                  a.patch(a.moduleExports, a.moduleVersion);
                try {
                  for (
                    var l = ((e = void 0), XB(a.files)), f = l.next();
                    !f.done;
                    f = l.next()
                  ) {
                    var d = f.value;
                    d.moduleExports &&
                      d.patch(d.moduleExports, a.moduleVersion);
                  }
                } catch (t) {
                  e = { error: t };
                } finally {
                  try {
                    f && !f.done && (r = l.return) && r.call(l);
                  } finally {
                    if (e) throw e.error;
                  }
                }
              }
            } catch (n) {
              t = { error: n };
            } finally {
              try {
                c && !c.done && (n = u.return) && n.call(u);
              } finally {
                if (t) throw t.error;
              }
            }
          else {
            this.pn();
            var h = function (t) {
                var n = function (n, e, r) {
                    return s.En(t, n, e, r);
                  },
                  e = A.isAbsolute(t.name)
                    ? new JR([t.name], { internals: !0 }, n)
                    : p.fn.register(t.name, n);
                p.ln.push(e);
                var r = new uk([t.name], { internals: !1 }, function (n, e, r) {
                  return s.En(t, n, e, r);
                });
                p.ln.push(r);
              },
              p = this;
            try {
              for (var S = XB(this.hn), E = S.next(); !E.done; E = S.next()) {
                h(E.value);
              }
            } catch (t) {
              o = { error: t };
            } finally {
              try {
                E && !E.done && (i = S.return) && i.call(S);
              } finally {
                if (o) throw o.error;
              }
            }
          }
      }),
      (n.prototype.disable = function () {
        var t, n, e, r;
        if (this.dn) {
          this.dn = !1;
          try {
            for (var o = XB(this.hn), i = o.next(); !i.done; i = o.next()) {
              var s = i.value;
              "function" == typeof s.unpatch &&
                s.moduleExports &&
                s.unpatch(s.moduleExports, s.moduleVersion);
              try {
                for (
                  var u = ((e = void 0), XB(s.files)), c = u.next();
                  !c.done;
                  c = u.next()
                ) {
                  var a = c.value;
                  a.moduleExports &&
                    a.unpatch(a.moduleExports, s.moduleVersion);
                }
              } catch (t) {
                e = { error: t };
              } finally {
                try {
                  c && !c.done && (r = u.return) && r.call(u);
                } finally {
                  if (e) throw e.error;
                }
              }
            }
          } catch (n) {
            t = { error: n };
          } finally {
            try {
              i && !i.done && (n = o.return) && n.call(o);
            } finally {
              if (t) throw t.error;
            }
          }
        }
      }),
      (n.prototype.isEnabled = function () {
        return this.dn;
      }),
      n
    );
  })(gB);
function WB(t, n, e) {
  return void 0 === n
    ? t.includes("*")
    : t.some(function (t) {
        return Qv.satisfies(n, t, { includePrerelease: e });
      });
}
var YB = function (t, n, e, r, o) {
    (this.name = t),
      (this.supportedVersions = n),
      (this.patch = e),
      (this.unpatch = r),
      (this.files = o || []);
  },
  HB = function (t, e, r, o) {
    (this.supportedVersions = e),
      (this.patch = r),
      (this.unpatch = o),
      (this.name = n.normalize(t));
  },
  DB = function (t, n, e, r) {
    return new (e || (e = Promise))(function (o, i) {
      function s(t) {
        try {
          c(r.next(t));
        } catch (t) {
          i(t);
        }
      }
      function u(t) {
        try {
          c(r.throw(t));
        } catch (t) {
          i(t);
        }
      }
      function c(t) {
        var n;
        t.done
          ? o(t.value)
          : ((n = t.value),
            n instanceof e
              ? n
              : new e(function (t) {
                  t(n);
                })).then(s, u);
      }
      c((r = r.apply(t, n || [])).next());
    });
  },
  jB = function (t, n) {
    var e,
      r,
      o,
      i,
      s = {
        label: 0,
        sent: function () {
          if (1 & o[0]) throw o[1];
          return o[1];
        },
        trys: [],
        ops: [],
      };
    return (
      (i = { next: u(0), throw: u(1), return: u(2) }),
      "function" == typeof Symbol &&
        (i[Symbol.iterator] = function () {
          return this;
        }),
      i
    );
    function u(i) {
      return function (u) {
        return (function (i) {
          if (e) throw new TypeError("Generator is already executing.");
          for (; s; )
            try {
              if (
                ((e = 1),
                r &&
                  (o =
                    2 & i[0]
                      ? r.return
                      : i[0]
                        ? r.throw || ((o = r.return) && o.call(r), 0)
                        : r.next) &&
                  !(o = o.call(r, i[1])).done)
              )
                return o;
              switch (((r = 0), o && (i = [2 & i[0], o.value]), i[0])) {
                case 0:
                case 1:
                  o = i;
                  break;
                case 4:
                  return s.label++, { value: i[1], done: !1 };
                case 5:
                  s.label++, (r = i[1]), (i = [0]);
                  continue;
                case 7:
                  (i = s.ops.pop()), s.trys.pop();
                  continue;
                default:
                  if (
                    !((o = s.trys),
                    (o = o.length > 0 && o[o.length - 1]) ||
                      (6 !== i[0] && 2 !== i[0]))
                  ) {
                    s = 0;
                    continue;
                  }
                  if (3 === i[0] && (!o || (i[1] > o[0] && i[1] < o[3]))) {
                    s.label = i[1];
                    break;
                  }
                  if (6 === i[0] && s.label < o[1]) {
                    (s.label = o[1]), (o = i);
                    break;
                  }
                  if (o && s.label < o[2]) {
                    (s.label = o[2]), s.ops.push(i);
                    break;
                  }
                  o[2] && s.ops.pop(), s.trys.pop();
                  continue;
              }
              i = n.call(t, s);
            } catch (t) {
              (i = [6, t]), (r = 0);
            } finally {
              e = o = 0;
            }
          if (5 & i[0]) throw i[1];
          return { value: i[0] ? i[1] : void 0, done: !0 };
        })([i, u]);
      };
    }
  };
var xB = Object.freeze({
    __proto__: null,
    InstrumentationBase: UB,
    InstrumentationNodeModuleDefinition: YB,
    InstrumentationNodeModuleFile: HB,
    isWrapped: function (t) {
      return (
        "function" == typeof t &&
        "function" == typeof t.__original &&
        "function" == typeof t.__unwrap &&
        !0 === t.__wrapped
      );
    },
    registerInstrumentations: function (t) {
      var n = AB(t.instrumentations).instrumentations,
        e = t.tracerProvider || Qr.getTracerProvider(),
        r = t.meterProvider || Ur.getMeterProvider();
      return (
        (function (t, n, e) {
          for (var r = 0, o = t.length; r < o; r++) {
            var i = t[r];
            n && i.setTracerProvider(n),
              e && i.setMeterProvider(e),
              i.getConfig().enabled || i.enable();
          }
        })(n, e, r),
        function () {
          !(function (t) {
            t.forEach(function (t) {
              return t.disable();
            });
          })(n);
        }
      );
    },
    safeExecuteInTheMiddle: function (t, n, e) {
      var r, o;
      try {
        o = t();
      } catch (t) {
        r = t;
      } finally {
        if ((n(r, o), r && !e)) throw r;
        return o;
      }
    },
    safeExecuteInTheMiddleAsync: function (t, n, e) {
      return DB(this, void 0, void 0, function () {
        var r, o, i;
        return jB(this, function (s) {
          switch (s.label) {
            case 0:
              return s.trys.push([0, 2, 3, 4]), [4, t()];
            case 1:
              return (o = s.sent()), [3, 4];
            case 2:
              return (i = s.sent()), (r = i), [3, 4];
            case 3:
              if ((n(r, o), r && !e)) throw r;
              return [2, o];
            case 4:
              return [2];
          }
        });
      });
    },
  }),
  kB = Ht(xB),
  KB = Ht(TU);
Object.defineProperty(hB, "__esModule", { value: !0 }),
  (hB.ExpressInstrumentation = void 0);
const BB = pB,
  FB = no,
  JB = SB,
  zB = EB,
  QB = mB,
  $B = RB,
  qB = kB,
  tF = KB,
  nF = TB;
class eF extends qB.InstrumentationBase {
  constructor(t = {}) {
    super(
      "@opentelemetry/instrumentation-express",
      $B.VERSION,
      Object.assign({}, t)
    );
  }
  setConfig(t = {}) {
    this.Nt = Object.assign({}, t);
  }
  getConfig() {
    return this.Nt;
  }
  init() {
    return [
      new qB.InstrumentationNodeModuleDefinition(
        "express",
        ["^4.0.0"],
        (t, n) => {
          FB.diag.debug(`Applying patch for express@${n}`);
          const e = t.Router;
          return (
            (0, qB.isWrapped)(e.route) && this.Rt(e, "route"),
            this.yt(e, "route", this.To()),
            (0, qB.isWrapped)(e.use) && this.Rt(e, "use"),
            this.yt(e, "use", this._o()),
            (0, qB.isWrapped)(t.application.use) &&
              this.Rt(t.application, "use"),
            this.yt(t.application, "use", this.bo()),
            t
          );
        },
        (t, n) => {
          if (void 0 === t) return;
          FB.diag.debug(`Removing patch for express@${n}`);
          const e = t.Router;
          this.Rt(e, "route"), this.Rt(e, "use"), this.Rt(t.application, "use");
        }
      ),
    ];
  }
  To() {
    const t = this;
    return function (n) {
      return function (...e) {
        const r = n.apply(this, e),
          o = this.stack[this.stack.length - 1];
        return t.vo(o, "string" == typeof e[0] ? e[0] : void 0), r;
      };
    };
  }
  _o() {
    const t = this;
    return function (n) {
      return function (...e) {
        const r = n.apply(this, e),
          o = this.stack[this.stack.length - 1];
        return t.vo(o, "string" == typeof e[0] ? e[0] : void 0), r;
      };
    };
  }
  bo() {
    const t = this;
    return function (n) {
      return function (...e) {
        const r = n.apply(this, e),
          o = this.yo.stack[this.yo.stack.length - 1];
        return t.vo.call(t, o, "string" == typeof e[0] ? e[0] : void 0), r;
      };
    };
  }
  vo(t, n) {
    const e = this;
    !0 !== t[nF.kLayerPatched] &&
      ((t[nF.kLayerPatched] = !0),
      this.yt(t, "handle", (r) =>
        4 === r.length
          ? r
          : function (o, i) {
              (0, QB.storeLayerPath)(o, n);
              const s = o[nF.mo]
                  .filter((t) => "/" !== t && "/*" !== t)
                  .join(""),
                u = {
                  [tF.SemanticAttributes.HTTP_ROUTE]: s.length > 0 ? s : "/",
                },
                c = (0, QB.getLayerMetadata)(t, n),
                a = c.attributes[zB.AttributeNames.EXPRESS_TYPE],
                l = (0, BB.getRPCMetadata)(FB.context.active());
              if (
                ((null == l ? void 0 : l.type) === BB.RPCType.HTTP &&
                  (l.route = s || "/"),
                (0, QB.isLayerIgnored)(c.name, a, e.Nt))
              )
                return (
                  a === JB.ExpressLayerType.MIDDLEWARE && o[nF.mo].pop(),
                  r.apply(this, arguments)
                );
              if (void 0 === FB.trace.getSpan(FB.context.active()))
                return r.apply(this, arguments);
              const f = e.Ro({ request: o, layerType: a, route: s }, c.name),
                d = e.tracer.startSpan(f, {
                  attributes: Object.assign(u, c.attributes),
                });
              e.getConfig().requestHook &&
                (0, qB.safeExecuteInTheMiddle)(
                  () =>
                    e
                      .getConfig()
                      .requestHook(d, { request: o, layerType: a, route: s }),
                  (t) => {
                    t &&
                      FB.diag.error(
                        "express instrumentation: request hook failed",
                        t
                      );
                  },
                  !0
                );
              let h = !1;
              c.attributes[zB.AttributeNames.EXPRESS_TYPE] !==
                JB.ExpressLayerType.MIDDLEWARE && (d.end(), (h = !0));
              const p = () => {
                  !1 === h && ((h = !0), d.end());
                },
                S = Array.from(arguments),
                E = S.findIndex((t) => "function" == typeof t);
              E >= 0 &&
                (arguments[E] = function () {
                  var t;
                  const n = arguments[0],
                    e = ![void 0, null, "route", "router"].includes(n);
                  if (!h && e) {
                    const [t, e] = (0, QB.asErrorAndMessage)(n);
                    d.recordException(t),
                      d.setStatus({
                        code: FB.SpanStatusCode.ERROR,
                        message: e,
                      });
                  }
                  !1 === h &&
                    ((h = !0),
                    null === (t = o.res) ||
                      void 0 === t ||
                      t.removeListener("finish", p),
                    d.end()),
                    (o.route && e) || o[nF.mo].pop();
                  return S[E].apply(this, arguments);
                });
              try {
                return r.apply(this, arguments);
              } catch (t) {
                const [n, e] = (0, QB.asErrorAndMessage)(t);
                throw (
                  (d.recordException(n),
                  d.setStatus({ code: FB.SpanStatusCode.ERROR, message: e }),
                  t)
                );
              } finally {
                h || i.once("finish", p);
              }
            }
      ));
  }
  Ro(t, n) {
    var e;
    const r = this.getConfig().spanNameHook;
    if (!(r instanceof Function)) return n;
    try {
      return null !== (e = r(t, n)) && void 0 !== e ? e : n;
    } catch (t) {
      return (
        FB.diag.error(
          "express instrumentation: error calling span name rewrite hook",
          t
        ),
        n
      );
    }
  }
}
hB.ExpressInstrumentation = eF;
var rF = {};
function oF(t) {
  return (
    "function" == typeof t &&
    "function" == typeof t.__original &&
    "function" == typeof t.__unwrap &&
    !0 === t.__wrapped
  );
}
Object.defineProperty(rF, "__esModule", { value: !0 }),
  (function (t) {
    var n =
        (Wt && Wt.__createBinding) ||
        (Object.create
          ? function (t, n, e, r) {
              void 0 === r && (r = e),
                Object.defineProperty(t, r, {
                  enumerable: !0,
                  get: function () {
                    return n[e];
                  },
                });
            }
          : function (t, n, e, r) {
              void 0 === r && (r = e), (t[r] = n[e]);
            }),
      e =
        (Wt && Wt.__exportStar) ||
        function (t, e) {
          for (var r in t)
            "default" === r ||
              Object.prototype.hasOwnProperty.call(e, r) ||
              n(e, t, r);
        };
    Object.defineProperty(t, "__esModule", { value: !0 }),
      e(hB, t),
      e(SB, t),
      e(EB, t),
      e(rF, t);
  })(dB);
const iF = () => ({
  name: "Express",
  setupOnce() {
    AK(
      new dB.ExpressInstrumentation({
        requestHook(t) {
          OK(t, "auto.http.otel.express");
        },
        spanNameHook(t, n) {
          if (wU() === IU()) return n;
          if ("request_handler" === t.layerType) {
            const n = t.request,
              e = n.method ? n.method.toUpperCase() : "GET";
            wU().setTransactionName(`${e} ${t.route}`);
          }
          return n;
        },
      })
    );
  },
});
function sF(t) {
  return function (n, e, r, o) {
    if ((Fn([t, "optionalAccess", (t) => t.shouldHandleError]) || uF)(n)) {
      const t = GU();
      if (t && t.getOptions().autoSessionTracking) {
        if (void 0 !== t.je) {
          const t = wU().getRequestSession();
          t && void 0 !== t.status && (t.status = "crashed");
        }
      }
      const e = captureException(n, {
        mechanism: { type: "middleware", handled: !1 },
      });
      return (r.sentry = e), void o(n);
    }
    o(n);
  };
}
function uF(t) {
  const n = (function (t) {
    const n =
      t.status ||
      t.statusCode ||
      t.status_code ||
      (t.output && t.output.statusCode);
    return n ? parseInt(n, 10) : 500;
  })(t);
  return n >= 500;
}
var cF = {},
  aF = {};
!(function (t) {
  var n, e;
  Object.defineProperty(t, "__esModule", { value: !0 }),
    (t.FastifyNames = t.FastifyTypes = t.AttributeNames = void 0),
    (function (t) {
      (t.FASTIFY_NAME = "fastify.name"),
        (t.FASTIFY_TYPE = "fastify.type"),
        (t.HOOK_NAME = "hook.name"),
        (t.PLUGIN_NAME = "plugin.name");
    })(t.AttributeNames || (t.AttributeNames = {})),
    ((n = t.FastifyTypes || (t.FastifyTypes = {})).MIDDLEWARE = "middleware"),
    (n.REQUEST_HANDLER = "request_handler"),
    ((e = t.FastifyNames || (t.FastifyNames = {})).MIDDLEWARE = "middleware"),
    (e.REQUEST_HANDLER = "request handler");
})(aF);
var lF = {};
Object.defineProperty(lF, "__esModule", { value: !0 });
var fF = {},
  dF = Ht(Ek),
  hF = {};
Object.defineProperty(hF, "__esModule", { value: !0 }),
  (hF.hooksNamesToWrap = hF.spanRequestSymbol = void 0),
  (hF.spanRequestSymbol = Symbol(
    "opentelemetry.instrumentation.fastify.request_active_span"
  )),
  (hF.hooksNamesToWrap = new Set([
    "onTimeout",
    "onRequest",
    "preParsing",
    "preValidation",
    "preSerialization",
    "preHandler",
    "onSend",
    "onResponse",
    "onError",
  ]));
var pF = {};
Object.defineProperty(pF, "__esModule", { value: !0 }),
  (pF.safeExecuteInTheMiddleMaybePromise = pF.endSpan = pF.startSpan = void 0);
const SF = no,
  EF = hF;
function mF(t) {
  var n;
  return (
    ("object" == typeof t &&
      t &&
      "function" ==
        typeof (null === (n = Object.getOwnPropertyDescriptor(t, "then")) ||
        void 0 === n
          ? void 0
          : n.value)) ||
    !1
  );
}
(pF.startSpan = function (t, n, e, r = {}) {
  const o = n.startSpan(e, { attributes: r }),
    i = t[EF.spanRequestSymbol] || [];
  return (
    i.push(o),
    Object.defineProperty(t, EF.spanRequestSymbol, {
      enumerable: !1,
      configurable: !0,
      value: i,
    }),
    o
  );
}),
  (pF.endSpan = function (t, n) {
    const e = t[EF.spanRequestSymbol] || [];
    e.length &&
      (e.forEach((t) => {
        n &&
          (t.setStatus({ code: SF.SpanStatusCode.ERROR, message: n.message }),
          t.recordException(n)),
          t.end();
      }),
      delete t[EF.spanRequestSymbol]);
  }),
  (pF.safeExecuteInTheMiddleMaybePromise = function (t, n, e) {
    let r, o;
    try {
      (o = t()),
        mF(o) &&
          o.then(
            (t) => n(void 0, t),
            (t) => n(t)
          );
    } catch (t) {
      r = t;
    } finally {
      if (!mF(o) && (n(r, o), r && !e)) throw r;
      return o;
    }
  });
var TF = {};
Object.defineProperty(TF, "__esModule", { value: !0 }),
  (TF.VERSION = void 0),
  (TF.VERSION = "0.35.0"),
  (function (t) {
    Object.defineProperty(t, "__esModule", { value: !0 }),
      (t.FastifyInstrumentation = t.ANONYMOUS_NAME = void 0);
    const n = no,
      e = pB,
      r = dF,
      o = KB,
      i = hF,
      s = aF,
      u = pF,
      c = TF;
    t.ANONYMOUS_NAME = "anonymous";
    class a extends r.InstrumentationBase {
      constructor(t = {}) {
        super(
          "@opentelemetry/instrumentation-fastify",
          c.VERSION,
          Object.assign({}, t)
        );
      }
      setConfig(t = {}) {
        this.Nt = Object.assign({}, t);
      }
      getConfig() {
        return this.Nt;
      }
      init() {
        return [
          new r.InstrumentationNodeModuleDefinition(
            "fastify",
            ["^3.0.0", "^4.0.0"],
            (t, n) => (
              this.Ct.debug(`Applying patch for fastify@${n}`), this.Ao(t)
            )
          ),
        ];
      }
      Oo() {
        const t = this;
        return function (r, o, i) {
          if (!t.isEnabled()) return i();
          t.yt(o, "send", t.No());
          const s = r,
            u = (0, e.getRPCMetadata)(n.context.active()),
            c = s.routeOptions ? s.routeOptions.url : r.routerPath;
          c &&
            (null == u ? void 0 : u.type) === e.RPCType.HTTP &&
            (u.route = c),
            i();
        };
      }
      Co(e, r, o, i) {
        const c = this;
        return (
          this.Ct.debug("Patching fastify route.handler function"),
          function (...a) {
            if (!c.isEnabled()) return o.apply(this, a);
            const l = o.name || e || t.ANONYMOUS_NAME,
              f = `${s.FastifyNames.MIDDLEWARE} - ${l}`,
              d = a[1],
              h = (0, u.startSpan)(d, c.tracer, f, {
                [s.AttributeNames.FASTIFY_TYPE]: s.FastifyTypes.MIDDLEWARE,
                [s.AttributeNames.PLUGIN_NAME]: e,
                [s.AttributeNames.HOOK_NAME]: r,
              }),
              p = i && a[a.length - 1];
            return (
              p &&
                (a[a.length - 1] = function (...t) {
                  (0, u.endSpan)(d), p.apply(this, t);
                }),
              n.context.with(n.trace.setSpan(n.context.active(), h), () =>
                (0, u.safeExecuteInTheMiddleMaybePromise)(
                  () => o.apply(this, a),
                  (t) => {
                    t instanceof Error &&
                      (h.setStatus({
                        code: n.SpanStatusCode.ERROR,
                        message: t.message,
                      }),
                      h.recordException(t)),
                      i || (0, u.endSpan)(d);
                  }
                )
              )
            );
          }
        );
      }
      Lo() {
        const t = this;
        return (
          this.Ct.debug("Patching fastify server.addHook function"),
          function (n) {
            return function (...e) {
              const r = e[0],
                o = e[1],
                s = this.pluginName;
              if (!i.hooksNamesToWrap.has(r)) return n.apply(this, e);
              const u =
                "function" == typeof e[e.length - 1] &&
                "AsyncFunction" !== o.constructor.name;
              return n.apply(this, [r, t.Co(s, r, o, u)]);
            };
          }
        );
      }
      Ao(t) {
        const n = this;
        function e(...e) {
          const r = t.fastify.apply(this, e);
          return (
            r.addHook("onRequest", n.Oo()),
            r.addHook("preHandler", n.Io()),
            n.yt(r, "addHook", n.Lo()),
            r
          );
        }
        return (
          this.Ct.debug("Patching fastify constructor function"),
          (e.fastify = e),
          (e.default = e),
          e
        );
      }
      No() {
        const t = this;
        return (
          this.Ct.debug("Patching fastify reply.send function"),
          function (n) {
            return function (...e) {
              const o = e[0];
              return t.isEnabled()
                ? (0, r.safeExecuteInTheMiddle)(
                    () => n.apply(this, e),
                    (t) => {
                      !t && o instanceof Error && (t = o),
                        (0, u.endSpan)(this, t);
                    }
                  )
                : n.apply(this, e);
            };
          }
        );
      }
      Io() {
        const e = this;
        return (
          this.Ct.debug("Patching fastify preHandler function"),
          function (i, c, a) {
            var l, f;
            if (!e.isEnabled()) return a();
            const d = i,
              h =
                (null === (l = d.routeOptions) || void 0 === l
                  ? void 0
                  : l.handler) ||
                (null === (f = d.context) || void 0 === f ? void 0 : f.handler),
              p = (null == h ? void 0 : h.name.startsWith("bound "))
                ? h.name.substr(6)
                : null == h
                  ? void 0
                  : h.name,
              S = `${s.FastifyNames.REQUEST_HANDLER} - ${
                p || this.pluginName || t.ANONYMOUS_NAME
              }`,
              E = {
                [s.AttributeNames.PLUGIN_NAME]: this.pluginName,
                [s.AttributeNames.FASTIFY_TYPE]: s.FastifyTypes.REQUEST_HANDLER,
                [o.SemanticAttributes.HTTP_ROUTE]: d.routeOptions
                  ? d.routeOptions.url
                  : i.routerPath,
              };
            p && (E[s.AttributeNames.FASTIFY_NAME] = p);
            const m = (0, u.startSpan)(c, e.tracer, S, E);
            return (
              e.getConfig().requestHook &&
                (0, r.safeExecuteInTheMiddle)(
                  () => e.getConfig().requestHook(m, { request: i }),
                  (t) => {
                    t && e.Ct.error("request hook failed", t);
                  },
                  !0
                ),
              n.context.with(n.trace.setSpan(n.context.active(), m), () => {
                a();
              })
            );
          }
        );
      }
    }
    t.FastifyInstrumentation = a;
  })(fF),
  (function (t) {
    var n =
        (Wt && Wt.__createBinding) ||
        (Object.create
          ? function (t, n, e, r) {
              void 0 === r && (r = e),
                Object.defineProperty(t, r, {
                  enumerable: !0,
                  get: function () {
                    return n[e];
                  },
                });
            }
          : function (t, n, e, r) {
              void 0 === r && (r = e), (t[r] = n[e]);
            }),
      e =
        (Wt && Wt.__exportStar) ||
        function (t, e) {
          for (var r in t)
            "default" === r ||
              Object.prototype.hasOwnProperty.call(e, r) ||
              n(e, t, r);
        };
    Object.defineProperty(t, "__esModule", { value: !0 }),
      e(aF, t),
      e(lF, t),
      e(fF, t);
  })(cF);
const _F = () => ({
  name: "Fastify",
  setupOnce() {
    AK(
      new cF.FastifyInstrumentation({
        requestHook(t) {
          OK(t, "auto.http.otel.fastify");
        },
      })
    );
  },
});
var bF = {},
  vF = {},
  yF = {};
!(function (t) {
  var n, e;
  Object.defineProperty(t, "__esModule", { value: !0 }),
    (t.SpanNames = t.TokenKind = t.AllowedOperationTypes = void 0),
    ((n = t.AllowedOperationTypes || (t.AllowedOperationTypes = {})).QUERY =
      "query"),
    (n.MUTATION = "mutation"),
    (n.SUBSCRIPTION = "subscription"),
    ((e = t.TokenKind || (t.TokenKind = {})).SOF = "<SOF>"),
    (e.EOF = "<EOF>"),
    (e.BANG = "!"),
    (e.DOLLAR = "$"),
    (e.AMP = "&"),
    (e.PAREN_L = "("),
    (e.PAREN_R = ")"),
    (e.SPREAD = "..."),
    (e.COLON = ":"),
    (e.EQUALS = "="),
    (e.AT = "@"),
    (e.BRACKET_L = "["),
    (e.BRACKET_R = "]"),
    (e.BRACE_L = "{"),
    (e.PIPE = "|"),
    (e.BRACE_R = "}"),
    (e.NAME = "Name"),
    (e.INT = "Int"),
    (e.FLOAT = "Float"),
    (e.STRING = "String"),
    (e.BLOCK_STRING = "BlockString"),
    (e.COMMENT = "Comment"),
    (function (t) {
      (t.EXECUTE = "graphql.execute"),
        (t.PARSE = "graphql.parse"),
        (t.RESOLVE = "graphql.resolve"),
        (t.VALIDATE = "graphql.validate"),
        (t.SCHEMA_VALIDATE = "graphql.validateSchema"),
        (t.SCHEMA_PARSE = "graphql.parseSchema");
    })(t.SpanNames || (t.SpanNames = {}));
})(yF);
var RF = {};
!(function (t) {
  Object.defineProperty(t, "__esModule", { value: !0 }),
    (t.AttributeNames = void 0),
    (function (t) {
      (t.SOURCE = "graphql.source"),
        (t.FIELD_NAME = "graphql.field.name"),
        (t.FIELD_PATH = "graphql.field.path"),
        (t.FIELD_TYPE = "graphql.field.type"),
        (t.OPERATION_TYPE = "graphql.operation.type"),
        (t.OPERATION_NAME = "graphql.operation.name"),
        (t.VARIABLES = "graphql.variables."),
        (t.ERROR_VALIDATION_NAME = "graphql.validation.error");
    })(t.AttributeNames || (t.AttributeNames = {}));
})(RF);
var AF = {};
Object.defineProperty(AF, "__esModule", { value: !0 }),
  (AF.OTEL_GRAPHQL_DATA_SYMBOL = AF.OTEL_PATCHED_SYMBOL = void 0),
  (AF.OTEL_PATCHED_SYMBOL = Symbol.for("opentelemetry.patched")),
  (AF.OTEL_GRAPHQL_DATA_SYMBOL = Symbol.for("opentelemetry.graphql_data"));
var OF = {};
Object.defineProperty(OF, "__esModule", { value: !0 }),
  (OF.OPERATION_NOT_SUPPORTED = void 0),
  (OF.OPERATION_NOT_SUPPORTED = "Operation$operationName$not supported");
var gF = {};
!(function (t) {
  Object.defineProperty(t, "__esModule", { value: !0 }),
    (t.wrapFieldResolver =
      t.wrapFields =
      t.getSourceFromLocation =
      t.getOperation =
      t.endSpan =
      t.addSpanSource =
      t.addInputVariableAttributes =
      t.isPromise =
        void 0);
  const n = no,
    e = yF,
    r = RF,
    o = AF,
    i = Object.values(e.AllowedOperationTypes);
  t.isPromise = (t) => "function" == typeof (null == t ? void 0 : t.then);
  const s = (t) => "object" == typeof t && null !== t;
  function u(t, n, e) {
    Array.isArray(e)
      ? e.forEach((e, r) => {
          u(t, `${n}.${r}`, e);
        })
      : e instanceof Object
        ? Object.entries(e).forEach(([e, r]) => {
            u(t, `${n}.${e}`, r);
          })
        : t.setAttribute(`${r.AttributeNames.VARIABLES}${String(n)}`, e);
  }
  function c(t, n, e, o, i) {
    const s = E(n, e, o, i);
    t.setAttribute(r.AttributeNames.SOURCE, s);
  }
  function a(t, n, e, r, i) {
    let s = f(e, i),
      u = !1;
    if (!s) {
      u = !0;
      const c = d(e, i);
      (s = { parent: c, span: l(t, n, e, r, i, c.span), error: null }),
        (function (t, n, e) {
          t[o.OTEL_GRAPHQL_DATA_SYMBOL].fields[n.join(".")] = e;
        })(e, i, s);
    }
    return { spanAdded: u, field: s };
  }
  function l(t, i, s, u, a, l) {
    var f, d;
    const h = {
        [r.AttributeNames.FIELD_NAME]: u.fieldName,
        [r.AttributeNames.FIELD_PATH]: a.join("."),
        [r.AttributeNames.FIELD_TYPE]: u.returnType.toString(),
      },
      p = t.startSpan(
        `${e.SpanNames.RESOLVE} ${h[r.AttributeNames.FIELD_PATH]}`,
        { attributes: h },
        l ? n.trace.setSpan(n.context.active(), l) : void 0
      ),
      S = s[o.OTEL_GRAPHQL_DATA_SYMBOL].source,
      E = u.fieldNodes.find((t) => "Field" === t.kind);
    return (
      E &&
        c(
          p,
          S.loc,
          i().allowValues,
          null === (f = E.loc) || void 0 === f ? void 0 : f.start,
          null === (d = E.loc) || void 0 === d ? void 0 : d.end
        ),
      p
    );
  }
  function f(t, n) {
    return t[o.OTEL_GRAPHQL_DATA_SYMBOL].fields[n.join(".")];
  }
  function d(t, n) {
    for (let e = n.length - 1; e > 0; e--) {
      const r = f(t, n.slice(0, e));
      if (r) return r;
    }
    return { span: t[o.OTEL_GRAPHQL_DATA_SYMBOL].span };
  }
  function h(t) {
    return p(" ", t);
  }
  function p(t, n) {
    let e = "";
    for (let r = 0; r < n; r++) e += t;
    return e;
  }
  (t.addInputVariableAttributes = function (t, n) {
    Object.entries(n).forEach(([n, e]) => {
      u(t, n, e);
    });
  }),
    (t.addSpanSource = c),
    (t.endSpan = function (t, n) {
      n && t.recordException(n), t.end();
    }),
    (t.getOperation = function (t, n) {
      if (t && Array.isArray(t.definitions))
        return n
          ? t.definitions
              .filter((t) => {
                var n;
                return (
                  -1 !==
                  i.indexOf(
                    null === (n = t) || void 0 === n ? void 0 : n.operation
                  )
                );
              })
              .find((t) => {
                var e, r;
                return (
                  n ===
                  (null ===
                    (r = null === (e = t) || void 0 === e ? void 0 : e.name) ||
                  void 0 === r
                    ? void 0
                    : r.value)
                );
              })
          : t.definitions.find((t) => {
              var n;
              return (
                -1 !==
                i.indexOf(
                  null === (n = t) || void 0 === n ? void 0 : n.operation
                )
              );
            });
    });
  const S = [
    e.TokenKind.FLOAT,
    e.TokenKind.STRING,
    e.TokenKind.INT,
    e.TokenKind.BLOCK_STRING,
  ];
  function E(t, n = !1, r, o) {
    var i, s;
    let u = "";
    if (null == t ? void 0 : t.startToken) {
      const c = "number" == typeof r ? r : t.start,
        a = "number" == typeof o ? o : t.end;
      let l = t.startToken.next,
        f = 1;
      for (; l; ) {
        if (l.start < c) {
          (l = l.next), (f = null == l ? void 0 : l.line);
          continue;
        }
        if (l.end > a) {
          (l = l.next), (f = null == l ? void 0 : l.line);
          continue;
        }
        let t = l.value || l.kind,
          r = "";
        !n && S.indexOf(l.kind) >= 0 && (t = "*"),
          l.kind === e.TokenKind.STRING && (t = `"${t}"`),
          l.kind === e.TokenKind.EOF && (t = ""),
          l.line > f
            ? ((u += p("\n", l.line - f)), (f = l.line), (r = h(l.column - 1)))
            : l.line ===
                (null === (i = l.prev) || void 0 === i ? void 0 : i.line) &&
              (r = h(
                l.start -
                  ((null === (s = l.prev) || void 0 === s ? void 0 : s.end) ||
                    0)
              )),
          (u += r + t),
          l && (l = l.next);
      }
    }
    return u;
  }
  (t.getSourceFromLocation = E),
    (t.wrapFields = function t(n, e, r) {
      if (!n || "function" != typeof n.getFields || n[o.OTEL_PATCHED_SYMBOL])
        return;
      const i = n.getFields();
      (n[o.OTEL_PATCHED_SYMBOL] = !0),
        Object.keys(i).forEach((n) => {
          const o = i[n];
          if (o && (o.resolve && (o.resolve = _(e, r, o.resolve)), o.type)) {
            let n = o.type;
            for (; n.ofType; ) n = n.ofType;
            t(n, e, r);
          }
        });
    });
  const m = (t, e, r) => {
      r &&
        (t.recordException(e),
        t.setStatus({ code: n.SpanStatusCode.ERROR, message: e.message }),
        t.end());
    },
    T = (t, n) => {
      n && t.end();
    };
  function _(e, r, i, u = !1) {
    if (c[o.OTEL_PATCHED_SYMBOL] || "function" != typeof i) return i;
    function c(c, l, f, h) {
      if (!i) return;
      const p = r();
      if (
        p.ignoreTrivialResolveSpans &&
        u &&
        (s(c) || "function" == typeof c)
      ) {
        if ("function" != typeof c[h.fieldName])
          return i.call(this, c, l, f, h);
      }
      if (!f[o.OTEL_GRAPHQL_DATA_SYMBOL]) return i.call(this, c, l, f, h);
      const S = (function (t, n) {
          const e = [];
          let r = n;
          for (; r; ) {
            let n = r.key;
            t && "number" == typeof n && (n = "*"),
              e.push(String(n)),
              (r = r.prev);
          }
          return e.reverse();
        })(p.mergeItems, h && h.path),
        E = S.filter((t) => "string" == typeof t).length;
      let _,
        b = !1;
      if (p.depth >= 0 && p.depth < E) _ = d(f, S);
      else {
        const t = a(e, r, f, h, S);
        (_ = t.field), (b = t.spanAdded);
      }
      return n.context.with(n.trace.setSpan(n.context.active(), _.span), () => {
        try {
          const n = i.call(this, c, l, f, h);
          return (0, t.isPromise)(n)
            ? n.then(
                (t) => (T(_.span, b), t),
                (t) => {
                  throw (m(_.span, t, b), t);
                }
              )
            : (T(_.span, b), n);
        } catch (t) {
          throw (m(_.span, t, b), t);
        }
      });
    }
    return (c[o.OTEL_PATCHED_SYMBOL] = !0), c;
  }
  t.wrapFieldResolver = _;
})(gF);
var NF = {};
Object.defineProperty(NF, "__esModule", { value: !0 }),
  (NF.VERSION = void 0),
  (NF.VERSION = "0.39.0"),
  Object.defineProperty(vF, "__esModule", { value: !0 }),
  (vF.GraphQLInstrumentation = void 0);
const CF = no,
  LF = dF,
  IF = yF,
  MF = RF,
  wF = AF,
  ZF = OF,
  PF = gF,
  VF = NF,
  GF = { mergeItems: !1, depth: -1, allowValues: !1, ignoreResolveSpans: !1 },
  XF = [">=14 <17"];
class UF extends LF.InstrumentationBase {
  constructor(t = {}) {
    super(
      "@opentelemetry/instrumentation-graphql",
      VF.VERSION,
      Object.assign({}, GF, t)
    );
  }
  yn() {
    return this.Nt;
  }
  setConfig(t = {}) {
    this.Nt = Object.assign({}, GF, t);
  }
  init() {
    const t = new LF.InstrumentationNodeModuleDefinition("graphql", XF);
    return (
      t.files.push(this.Mo()),
      t.files.push(this.wo()),
      t.files.push(this.Zo()),
      t
    );
  }
  Mo() {
    return new LF.InstrumentationNodeModuleFile(
      "graphql/execution/execute.js",
      XF,
      (t, n) => (
        this.Ct.debug(`Applying patch for graphql@${n} execute`),
        (0, LF.isWrapped)(t.execute) && this.Rt(t, "execute"),
        this.yt(t, "execute", this.Po(t.defaultFieldResolver)),
        t
      ),
      (t, n) => {
        t &&
          (this.Ct.debug(`Removing patch for graphql@${n} execute`),
          this.Rt(t, "execute"));
      }
    );
  }
  wo() {
    return new LF.InstrumentationNodeModuleFile(
      "graphql/language/parser.js",
      XF,
      (t, n) => (
        this.Ct.debug(`Applying patch for graphql@${n} parse`),
        (0, LF.isWrapped)(t.parse) && this.Rt(t, "parse"),
        this.yt(t, "parse", this.Vo()),
        t
      ),
      (t, n) => {
        t &&
          (this.Ct.debug(`Removing patch for graphql@${n} parse`),
          this.Rt(t, "parse"));
      }
    );
  }
  Zo() {
    return new LF.InstrumentationNodeModuleFile(
      "graphql/validation/validate.js",
      XF,
      (t, n) => (
        this.Ct.debug(`Applying patch for graphql@${n} validate`),
        (0, LF.isWrapped)(t.validate) && this.Rt(t, "validate"),
        this.yt(t, "validate", this.Go()),
        t
      ),
      (t, n) => {
        t &&
          (this.Ct.debug(`Removing patch for graphql@${n} validate`),
          this.Rt(t, "validate"));
      }
    );
  }
  Po(t) {
    const n = this;
    return function (e) {
      return function () {
        let r;
        if (arguments.length >= 2) {
          const e = arguments;
          r = n.Xo(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], t);
        } else {
          const e = arguments[0];
          r = n.Xo(
            e.schema,
            e.document,
            e.rootValue,
            e.contextValue,
            e.variableValues,
            e.operationName,
            e.fieldResolver,
            e.typeResolver,
            t
          );
        }
        const o = (0, PF.getOperation)(r.document, r.operationName),
          i = n.Uo(o, r);
        return (
          (r.contextValue[wF.OTEL_GRAPHQL_DATA_SYMBOL] = {
            source: r.document
              ? r.document || r.document[wF.OTEL_GRAPHQL_DATA_SYMBOL]
              : void 0,
            span: i,
            fields: {},
          }),
          CF.context.with(CF.trace.setSpan(CF.context.active(), i), () =>
            (0, LF.safeExecuteInTheMiddle)(
              () => e.apply(this, [r]),
              (t, e) => {
                n.Wo(i, t, e);
              }
            )
          )
        );
      };
    };
  }
  Wo(t, n, e) {
    const r = this.yn();
    if (void 0 === e || n) (0, PF.endSpan)(t, n);
    else if ((0, PF.isPromise)(e))
      e.then(
        (n) => {
          "function" == typeof r.responseHook
            ? this.Yo(t, n)
            : (0, PF.endSpan)(t);
        },
        (n) => {
          (0, PF.endSpan)(t, n);
        }
      );
    else {
      if ("function" != typeof r.responseHook) return void (0, PF.endSpan)(t);
      this.Yo(t, e);
    }
  }
  Yo(t, n) {
    const e = this.yn();
    (0, LF.safeExecuteInTheMiddle)(
      () => {
        e.responseHook(t, n);
      },
      (n) => {
        n && this.Ct.error("Error running response hook", n),
          (0, PF.endSpan)(t, void 0);
      },
      !0
    );
  }
  Vo() {
    const t = this;
    return function (n) {
      return function (e, r) {
        return t.W(this, n, e, r);
      };
    };
  }
  Go() {
    const t = this;
    return function (n) {
      return function (e, r, o, i, s) {
        return t.Ho(this, n, e, r, o, s, i);
      };
    };
  }
  W(t, n, e, r) {
    const o = this.yn(),
      i = this.tracer.startSpan(IF.SpanNames.PARSE);
    return CF.context.with(CF.trace.setSpan(CF.context.active(), i), () =>
      (0, LF.safeExecuteInTheMiddle)(
        () => n.call(t, e, r),
        (t, n) => {
          if (n) {
            (0, PF.getOperation)(n)
              ? n.loc && (0, PF.addSpanSource)(i, n.loc, o.allowValues)
              : i.updateName(IF.SpanNames.SCHEMA_PARSE);
          }
          (0, PF.endSpan)(i, t);
        }
      )
    );
  }
  Ho(t, n, e, r, o, i, s) {
    const u = this.tracer.startSpan(IF.SpanNames.VALIDATE, {});
    return CF.context.with(CF.trace.setSpan(CF.context.active(), u), () =>
      (0, LF.safeExecuteInTheMiddle)(
        () => n.call(t, e, r, o, s, i),
        (t, n) => {
          r.loc || u.updateName(IF.SpanNames.SCHEMA_VALIDATE),
            n &&
              n.length &&
              u.recordException({
                name: MF.AttributeNames.ERROR_VALIDATION_NAME,
                message: JSON.stringify(n),
              }),
            (0, PF.endSpan)(u, t);
        }
      )
    );
  }
  Uo(t, n) {
    var e;
    const r = this.yn(),
      o = this.tracer.startSpan(IF.SpanNames.EXECUTE, {});
    if (t) {
      const { operation: n, name: e } = t;
      o.setAttribute(MF.AttributeNames.OPERATION_TYPE, n);
      const r = null == e ? void 0 : e.value;
      r
        ? (o.setAttribute(MF.AttributeNames.OPERATION_NAME, r),
          o.updateName(`${n} ${r}`))
        : o.updateName(n);
    } else {
      let t = " ";
      n.operationName && (t = ` "${n.operationName}" `),
        (t = ZF.OPERATION_NOT_SUPPORTED.replace("$operationName$", t)),
        o.setAttribute(MF.AttributeNames.OPERATION_NAME, t);
    }
    return (
      (null === (e = n.document) || void 0 === e ? void 0 : e.loc) &&
        (0, PF.addSpanSource)(o, n.document.loc, r.allowValues),
      n.variableValues &&
        r.allowValues &&
        (0, PF.addInputVariableAttributes)(o, n.variableValues),
      o
    );
  }
  Xo(t, n, e, r, o, i, s, u, c) {
    if (
      (r || (r = {}),
      r[wF.OTEL_GRAPHQL_DATA_SYMBOL] || this.yn().ignoreResolveSpans)
    )
      return {
        schema: t,
        document: n,
        rootValue: e,
        contextValue: r,
        variableValues: o,
        operationName: i,
        fieldResolver: s,
        typeResolver: u,
      };
    const a = null == s,
      l = null != s ? s : c;
    return (
      (s = (0, PF.wrapFieldResolver)(this.tracer, this.yn.bind(this), l, a)),
      t &&
        ((0, PF.wrapFields)(t.getQueryType(), this.tracer, this.yn.bind(this)),
        (0, PF.wrapFields)(
          t.getMutationType(),
          this.tracer,
          this.yn.bind(this)
        )),
      {
        schema: t,
        document: n,
        rootValue: e,
        contextValue: r,
        variableValues: o,
        operationName: i,
        fieldResolver: s,
        typeResolver: u,
      }
    );
  }
}
vF.GraphQLInstrumentation = UF;
var WF = {};
Object.defineProperty(WF, "__esModule", { value: !0 }),
  (function (t) {
    var n =
        (Wt && Wt.__createBinding) ||
        (Object.create
          ? function (t, n, e, r) {
              void 0 === r && (r = e),
                Object.defineProperty(t, r, {
                  enumerable: !0,
                  get: function () {
                    return n[e];
                  },
                });
            }
          : function (t, n, e, r) {
              void 0 === r && (r = e), (t[r] = n[e]);
            }),
      e =
        (Wt && Wt.__exportStar) ||
        function (t, e) {
          for (var r in t)
            "default" === r ||
              Object.prototype.hasOwnProperty.call(e, r) ||
              n(e, t, r);
        };
    Object.defineProperty(t, "__esModule", { value: !0 }), e(vF, t), e(WF, t);
  })(bF);
const YF = () => ({
  name: "Graphql",
  setupOnce() {
    AK(
      new bF.GraphQLInstrumentation({
        ignoreTrivialResolveSpans: !0,
        responseHook(t) {
          OK(t, "auto.graphql.otel.graphql");
        },
      })
    );
  },
});
var HF = {},
  DF = {};
function jF(t) {
  void 0 === t && (t = []);
  for (var n = [], e = 0, r = t.length; e < r; e++) {
    var o = t[e];
    if (Array.isArray(o)) {
      var i = jF(o);
      n = n.concat(i.instrumentations);
    } else
      "function" == typeof o
        ? n.push(new o())
        : o.instrumentationName && n.push(o);
  }
  return { instrumentations: n };
}
var xF = function () {
    return (
      (xF =
        Object.assign ||
        function (t) {
          for (var n, e = 1, r = arguments.length; e < r; e++)
            for (var o in (n = arguments[e]))
              Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
          return t;
        }),
      xF.apply(this, arguments)
    );
  },
  kF = (function () {
    function t(t, n, e) {
      void 0 === e && (e = {}),
        (this.instrumentationName = t),
        (this.instrumentationVersion = n),
        (this.yt = Ty.wrap),
        (this.Rt = Ty.unwrap),
        (this.At = Ty.massWrap),
        (this.Ot = Ty.massUnwrap),
        (this.Nt = xF({ enabled: !0 }, e)),
        (this.Ct = Pr.createComponentLogger({ namespace: t })),
        (this.Lt = Qr.getTracer(t, n)),
        (this.It = Ur.getMeter(t, n)),
        this.wt();
    }
    return (
      Object.defineProperty(t.prototype, "meter", {
        get: function () {
          return this.It;
        },
        enumerable: !1,
        configurable: !0,
      }),
      (t.prototype.setMeterProvider = function (t) {
        (this.It = t.getMeter(
          this.instrumentationName,
          this.instrumentationVersion
        )),
          this.wt();
      }),
      (t.prototype.wt = function () {}),
      (t.prototype.getConfig = function () {
        return this.Nt;
      }),
      (t.prototype.setConfig = function (t) {
        void 0 === t && (t = {}), (this.Nt = Object.assign({}, t));
      }),
      (t.prototype.setTracerProvider = function (t) {
        this.Lt = t.getTracer(
          this.instrumentationName,
          this.instrumentationVersion
        );
      }),
      Object.defineProperty(t.prototype, "tracer", {
        get: function () {
          return this.Lt;
        },
        enumerable: !1,
        configurable: !0,
      }),
      t
    );
  })(),
  KF = function (t) {
    var n = "function" == typeof Symbol && Symbol.iterator,
      e = n && t[n],
      r = 0;
    if (e) return e.call(t);
    if (t && "number" == typeof t.length)
      return {
        next: function () {
          return (
            t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t }
          );
        },
      };
    throw new TypeError(
      n ? "Object is not iterable." : "Symbol.iterator is not defined."
    );
  },
  BF = function (t, n) {
    var e = "function" == typeof Symbol && t[Symbol.iterator];
    if (!e) return t;
    var r,
      o,
      i = e.call(t),
      s = [];
    try {
      for (; (void 0 === n || n-- > 0) && !(r = i.next()).done; )
        s.push(r.value);
    } catch (t) {
      o = { error: t };
    } finally {
      try {
        r && !r.done && (e = i.return) && e.call(i);
      } finally {
        if (o) throw o.error;
      }
    }
    return s;
  },
  FF = function (t, n, e) {
    if (e || 2 === arguments.length)
      for (var r, o = 0, i = n.length; o < i; o++)
        (!r && o in n) ||
          (r || (r = Array.prototype.slice.call(n, 0, o)), (r[o] = n[o]));
    return t.concat(r || Array.prototype.slice.call(n));
  },
  JF = "/",
  zF = function () {
    (this.hooks = []), (this.children = new Map());
  },
  QF = (function () {
    function t() {
      (this.rn = new zF()), (this.sn = 0);
    }
    return (
      (t.prototype.insert = function (t) {
        var n,
          e,
          r = this.rn;
        try {
          for (
            var o = KF(t.moduleName.split(JF)), i = o.next();
            !i.done;
            i = o.next()
          ) {
            var s = i.value,
              u = r.children.get(s);
            u || ((u = new zF()), r.children.set(s, u)), (r = u);
          }
        } catch (t) {
          n = { error: t };
        } finally {
          try {
            i && !i.done && (e = o.return) && e.call(o);
          } finally {
            if (n) throw n.error;
          }
        }
        r.hooks.push({ hook: t, insertedId: this.sn++ });
      }),
      (t.prototype.search = function (t, n) {
        var e,
          r,
          o = void 0 === n ? {} : n,
          i = o.maintainInsertionOrder,
          s = o.fullOnly,
          u = this.rn,
          c = [],
          a = !0;
        try {
          for (var l = KF(t.split(JF)), f = l.next(); !f.done; f = l.next()) {
            var d = f.value,
              h = u.children.get(d);
            if (!h) {
              a = !1;
              break;
            }
            s || c.push.apply(c, FF([], BF(h.hooks), !1)), (u = h);
          }
        } catch (t) {
          e = { error: t };
        } finally {
          try {
            f && !f.done && (r = l.return) && r.call(l);
          } finally {
            if (e) throw e.error;
          }
        }
        return (
          s && a && c.push.apply(c, FF([], BF(u.hooks), !1)),
          0 === c.length
            ? []
            : 1 === c.length
              ? [c[0].hook]
              : (i &&
                  c.sort(function (t, n) {
                    return t.insertedId - n.insertedId;
                  }),
                c.map(function (t) {
                  return t.hook;
                }))
        );
      }),
      t
    );
  })(),
  $F = function (t) {
    var n = "function" == typeof Symbol && Symbol.iterator,
      e = n && t[n],
      r = 0;
    if (e) return e.call(t);
    if (t && "number" == typeof t.length)
      return {
        next: function () {
          return (
            t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t }
          );
        },
      };
    throw new TypeError(
      n ? "Object is not iterable." : "Symbol.iterator is not defined."
    );
  },
  qF = ["afterEach", "after", "beforeEach", "before", "describe", "it"].every(
    function (t) {
      return "function" == typeof global[t];
    }
  ),
  tJ = (function () {
    function t() {
      (this.un = new QF()), this.cn();
    }
    return (
      (t.prototype.cn = function () {
        var t = this;
        new JR(null, { internals: !0 }, function (n, e, r) {
          var o,
            i,
            s,
            u = ((s = e), A.sep !== JF ? s.split(A.sep).join(JF) : s),
            c = t.un.search(u, {
              maintainInsertionOrder: !0,
              fullOnly: void 0 === r,
            });
          try {
            for (var a = $F(c), l = a.next(); !l.done; l = a.next()) {
              n = (0, l.value.onRequire)(n, e, r);
            }
          } catch (t) {
            o = { error: t };
          } finally {
            try {
              l && !l.done && (i = a.return) && i.call(a);
            } finally {
              if (o) throw o.error;
            }
          }
          return n;
        });
      }),
      (t.prototype.register = function (t, n) {
        var e = { moduleName: t, onRequire: n };
        return this.un.insert(e), e;
      }),
      (t.getInstance = function () {
        var n;
        return qF
          ? new t()
          : (this.L = null !== (n = this.L) && void 0 !== n ? n : new t());
      }),
      t
    );
  })();
var nJ = (function () {
    var t = function (n, e) {
      return (
        (t =
          Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array &&
            function (t, n) {
              t.__proto__ = n;
            }) ||
          function (t, n) {
            for (var e in n)
              Object.prototype.hasOwnProperty.call(n, e) && (t[e] = n[e]);
          }),
        t(n, e)
      );
    };
    return function (n, e) {
      if ("function" != typeof e && null !== e)
        throw new TypeError(
          "Class extends value " + String(e) + " is not a constructor or null"
        );
      function r() {
        this.constructor = n;
      }
      t(n, e),
        (n.prototype =
          null === e
            ? Object.create(e)
            : ((r.prototype = e.prototype), new r()));
    };
  })(),
  eJ = function (t) {
    var n = "function" == typeof Symbol && Symbol.iterator,
      e = n && t[n],
      r = 0;
    if (e) return e.call(t);
    if (t && "number" == typeof t.length)
      return {
        next: function () {
          return (
            t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t }
          );
        },
      };
    throw new TypeError(
      n ? "Object is not iterable." : "Symbol.iterator is not defined."
    );
  },
  rJ = (function (t) {
    function n(n, r, o) {
      void 0 === o && (o = {});
      var i = t.call(this, n, r, o) || this;
      (i.ln = []),
        (i.fn = tJ.getInstance()),
        (i.dn = !1),
        (i.yt = function (t, n, r) {
          if (e.types.isProxy(t)) {
            var o = Ty.wrap(Object.assign({}, t), n, r);
            return Object.defineProperty(t, n, { value: o });
          }
          return Ty.wrap(t, n, r);
        }),
        (i.Rt = function (t, n) {
          return e.types.isProxy(t)
            ? Object.defineProperty(t, n, { value: t[n] })
            : Ty.unwrap(t, n);
        }),
        (i.At = function (t, n, e) {
          t
            ? (Array.isArray(t) || (t = [t]),
              n && Array.isArray(n)
                ? t.forEach(function (t) {
                    n.forEach(function (n) {
                      i.yt(t, n, e);
                    });
                  })
                : Pr.error(
                    "must provide one or more functions to wrap on modules"
                  ))
            : Pr.error("must provide one or more modules to patch");
        }),
        (i.Ot = function (t, n) {
          t
            ? (Array.isArray(t) || (t = [t]),
              n && Array.isArray(n)
                ? t.forEach(function (t) {
                    n.forEach(function (n) {
                      i.Rt(t, n);
                    });
                  })
                : Pr.error(
                    "must provide one or more functions to wrap on modules"
                  ))
            : Pr.error("must provide one or more modules to patch");
        });
      var s = i.init();
      return (
        s && !Array.isArray(s) && (s = [s]),
        (i.hn = s || []),
        0 === i.hn.length &&
          Pr.debug(
            "No modules instrumentation has been defined for '" +
              i.instrumentationName +
              "@" +
              i.instrumentationVersion +
              "', nothing will be patched"
          ),
        i.Nt.enabled && i.enable(),
        i
      );
    }
    return (
      nJ(n, t),
      (n.prototype.pn = function () {
        var t = this;
        this.hn.forEach(function (n) {
          var e = n.name;
          try {
            var r = require.resolve(e);
            require.cache[r] &&
              t.Ct.warn(
                "Module " +
                  e +
                  " has been loaded before " +
                  t.instrumentationName +
                  " so it might not work, please initialize it before requiring " +
                  e
              );
          } catch (t) {}
        });
      }),
      (n.prototype.Sn = function (t) {
        try {
          var n = Lx(A.join(t, "package.json")).version;
          return "string" == typeof n ? n : void 0;
        } catch (n) {
          Pr.warn("Failed extracting version", t);
        }
      }),
      (n.prototype.En = function (t, n, e, r) {
        var o,
          i = this;
        if (!r)
          return "function" == typeof t.patch &&
            ((t.moduleExports = n), this.dn)
            ? t.patch(n)
            : n;
        var s = this.Sn(r);
        return (
          (t.moduleVersion = s),
          t.name === e
            ? oJ(t.supportedVersions, s, t.includePrerelease) &&
              "function" == typeof t.patch &&
              ((t.moduleExports = n), this.dn)
              ? t.patch(n, t.moduleVersion)
              : n
            : (null !== (o = t.files) && void 0 !== o ? o : [])
                .filter(function (t) {
                  return t.name === e;
                })
                .filter(function (n) {
                  return oJ(n.supportedVersions, s, t.includePrerelease);
                })
                .reduce(function (n, e) {
                  return (
                    (e.moduleExports = n),
                    i.dn ? e.patch(n, t.moduleVersion) : n
                  );
                }, n)
        );
      }),
      (n.prototype.enable = function () {
        var t,
          n,
          e,
          r,
          o,
          i,
          s = this;
        if (!this.dn)
          if (((this.dn = !0), this.ln.length > 0))
            try {
              for (var u = eJ(this.hn), c = u.next(); !c.done; c = u.next()) {
                var a = c.value;
                "function" == typeof a.patch &&
                  a.moduleExports &&
                  a.patch(a.moduleExports, a.moduleVersion);
                try {
                  for (
                    var l = ((e = void 0), eJ(a.files)), f = l.next();
                    !f.done;
                    f = l.next()
                  ) {
                    var d = f.value;
                    d.moduleExports &&
                      d.patch(d.moduleExports, a.moduleVersion);
                  }
                } catch (t) {
                  e = { error: t };
                } finally {
                  try {
                    f && !f.done && (r = l.return) && r.call(l);
                  } finally {
                    if (e) throw e.error;
                  }
                }
              }
            } catch (n) {
              t = { error: n };
            } finally {
              try {
                c && !c.done && (n = u.return) && n.call(u);
              } finally {
                if (t) throw t.error;
              }
            }
          else {
            this.pn();
            var h = function (t) {
                var n = function (n, e, r) {
                    return s.En(t, n, e, r);
                  },
                  e = A.isAbsolute(t.name)
                    ? new JR([t.name], { internals: !0 }, n)
                    : p.fn.register(t.name, n);
                p.ln.push(e);
                var r = new uk([t.name], { internals: !1 }, function (n, e, r) {
                  return s.En(t, n, e, r);
                });
                p.ln.push(r);
              },
              p = this;
            try {
              for (var S = eJ(this.hn), E = S.next(); !E.done; E = S.next()) {
                h(E.value);
              }
            } catch (t) {
              o = { error: t };
            } finally {
              try {
                E && !E.done && (i = S.return) && i.call(S);
              } finally {
                if (o) throw o.error;
              }
            }
          }
      }),
      (n.prototype.disable = function () {
        var t, n, e, r;
        if (this.dn) {
          this.dn = !1;
          try {
            for (var o = eJ(this.hn), i = o.next(); !i.done; i = o.next()) {
              var s = i.value;
              "function" == typeof s.unpatch &&
                s.moduleExports &&
                s.unpatch(s.moduleExports, s.moduleVersion);
              try {
                for (
                  var u = ((e = void 0), eJ(s.files)), c = u.next();
                  !c.done;
                  c = u.next()
                ) {
                  var a = c.value;
                  a.moduleExports &&
                    a.unpatch(a.moduleExports, s.moduleVersion);
                }
              } catch (t) {
                e = { error: t };
              } finally {
                try {
                  c && !c.done && (r = u.return) && r.call(u);
                } finally {
                  if (e) throw e.error;
                }
              }
            }
          } catch (n) {
            t = { error: n };
          } finally {
            try {
              i && !i.done && (n = o.return) && n.call(o);
            } finally {
              if (t) throw t.error;
            }
          }
        }
      }),
      (n.prototype.isEnabled = function () {
        return this.dn;
      }),
      n
    );
  })(kF);
function oJ(t, n, e) {
  return void 0 === n
    ? t.includes("*")
    : t.some(function (t) {
        return Qv.satisfies(n, t, { includePrerelease: e });
      });
}
var iJ = function (t, n, e, r, o) {
    (this.name = t),
      (this.supportedVersions = n),
      (this.patch = e),
      (this.unpatch = r),
      (this.files = o || []);
  },
  sJ = function (t, e, r, o) {
    (this.supportedVersions = e),
      (this.patch = r),
      (this.unpatch = o),
      (this.name = n.normalize(t));
  },
  uJ = function (t, n, e, r) {
    return new (e || (e = Promise))(function (o, i) {
      function s(t) {
        try {
          c(r.next(t));
        } catch (t) {
          i(t);
        }
      }
      function u(t) {
        try {
          c(r.throw(t));
        } catch (t) {
          i(t);
        }
      }
      function c(t) {
        var n;
        t.done
          ? o(t.value)
          : ((n = t.value),
            n instanceof e
              ? n
              : new e(function (t) {
                  t(n);
                })).then(s, u);
      }
      c((r = r.apply(t, n || [])).next());
    });
  },
  cJ = function (t, n) {
    var e,
      r,
      o,
      i,
      s = {
        label: 0,
        sent: function () {
          if (1 & o[0]) throw o[1];
          return o[1];
        },
        trys: [],
        ops: [],
      };
    return (
      (i = { next: u(0), throw: u(1), return: u(2) }),
      "function" == typeof Symbol &&
        (i[Symbol.iterator] = function () {
          return this;
        }),
      i
    );
    function u(i) {
      return function (u) {
        return (function (i) {
          if (e) throw new TypeError("Generator is already executing.");
          for (; s; )
            try {
              if (
                ((e = 1),
                r &&
                  (o =
                    2 & i[0]
                      ? r.return
                      : i[0]
                        ? r.throw || ((o = r.return) && o.call(r), 0)
                        : r.next) &&
                  !(o = o.call(r, i[1])).done)
              )
                return o;
              switch (((r = 0), o && (i = [2 & i[0], o.value]), i[0])) {
                case 0:
                case 1:
                  o = i;
                  break;
                case 4:
                  return s.label++, { value: i[1], done: !1 };
                case 5:
                  s.label++, (r = i[1]), (i = [0]);
                  continue;
                case 7:
                  (i = s.ops.pop()), s.trys.pop();
                  continue;
                default:
                  if (
                    !((o = s.trys),
                    (o = o.length > 0 && o[o.length - 1]) ||
                      (6 !== i[0] && 2 !== i[0]))
                  ) {
                    s = 0;
                    continue;
                  }
                  if (3 === i[0] && (!o || (i[1] > o[0] && i[1] < o[3]))) {
                    s.label = i[1];
                    break;
                  }
                  if (6 === i[0] && s.label < o[1]) {
                    (s.label = o[1]), (o = i);
                    break;
                  }
                  if (o && s.label < o[2]) {
                    (s.label = o[2]), s.ops.push(i);
                    break;
                  }
                  o[2] && s.ops.pop(), s.trys.pop();
                  continue;
              }
              i = n.call(t, s);
            } catch (t) {
              (i = [6, t]), (r = 0);
            } finally {
              e = o = 0;
            }
          if (5 & i[0]) throw i[1];
          return { value: i[0] ? i[1] : void 0, done: !0 };
        })([i, u]);
      };
    }
  };
var aJ = Object.freeze({
    __proto__: null,
    InstrumentationBase: rJ,
    InstrumentationNodeModuleDefinition: iJ,
    InstrumentationNodeModuleFile: sJ,
    isWrapped: function (t) {
      return (
        "function" == typeof t &&
        "function" == typeof t.__original &&
        "function" == typeof t.__unwrap &&
        !0 === t.__wrapped
      );
    },
    registerInstrumentations: function (t) {
      var n = jF(t.instrumentations).instrumentations,
        e = t.tracerProvider || Qr.getTracerProvider(),
        r = t.meterProvider || Ur.getMeterProvider();
      return (
        (function (t, n, e) {
          for (var r = 0, o = t.length; r < o; r++) {
            var i = t[r];
            n && i.setTracerProvider(n),
              e && i.setMeterProvider(e),
              i.getConfig().enabled || i.enable();
          }
        })(n, e, r),
        function () {
          !(function (t) {
            t.forEach(function (t) {
              return t.disable();
            });
          })(n);
        }
      );
    },
    safeExecuteInTheMiddle: function (t, n, e) {
      var r, o;
      try {
        o = t();
      } catch (t) {
        r = t;
      } finally {
        if ((n(r, o), r && !e)) throw r;
        return o;
      }
    },
    safeExecuteInTheMiddleAsync: function (t, n, e) {
      return uJ(this, void 0, void 0, function () {
        var r, o, i;
        return cJ(this, function (s) {
          switch (s.label) {
            case 0:
              return s.trys.push([0, 2, 3, 4]), [4, t()];
            case 1:
              return (o = s.sent()), [3, 4];
            case 2:
              return (i = s.sent()), (r = i), [3, 4];
            case 3:
              if ((n(r, o), r && !e)) throw r;
              return [2, o];
            case 4:
              return [2];
          }
        });
      });
    },
  }),
  lJ = Ht(aJ),
  fJ = {};
!(function (t) {
  var n;
  Object.defineProperty(t, "__esModule", { value: !0 }),
    (t.MongodbCommandType = void 0),
    ((n = t.MongodbCommandType || (t.MongodbCommandType = {})).CREATE_INDEXES =
      "createIndexes"),
    (n.FIND_AND_MODIFY = "findAndModify"),
    (n.IS_MASTER = "isMaster"),
    (n.COUNT = "count"),
    (n.UNKNOWN = "unknown");
})(fJ);
var dJ = {};
Object.defineProperty(dJ, "__esModule", { value: !0 }),
  (dJ.VERSION = void 0),
  (dJ.VERSION = "0.39.0"),
  Object.defineProperty(DF, "__esModule", { value: !0 }),
  (DF.MongoDBInstrumentation = void 0);
const hJ = no,
  pJ = lJ,
  SJ = KB,
  EJ = fJ,
  mJ = dJ;
class TJ extends pJ.InstrumentationBase {
  constructor(t = {}) {
    super("@opentelemetry/instrumentation-mongodb", mJ.VERSION, t),
      (this.Nt = t);
  }
  wt() {
    this.Do = this.meter.createUpDownCounter("db.client.connections.usage", {
      description:
        "The number of connections that are currently in state described by the state attribute.",
      unit: "{connection}",
    });
  }
  init() {
    const { v3PatchConnection: t, v3UnpatchConnection: n } = this.jo(),
      { v4PatchConnect: e, v4UnpatchConnect: r } = this.xo(),
      { v4PatchConnection: o, v4UnpatchConnection: i } = this.ko(),
      { v4PatchConnectionPool: s, v4UnpatchConnectionPool: u } = this.Ko(),
      { v4PatchSessions: c, v4UnpatchSessions: a } = this.Bo();
    return [
      new pJ.InstrumentationNodeModuleDefinition(
        "mongodb",
        [">=3.3 <4"],
        void 0,
        void 0,
        [
          new pJ.InstrumentationNodeModuleFile(
            "mongodb/lib/core/wireprotocol/index.js",
            [">=3.3 <4"],
            t,
            n
          ),
        ]
      ),
      new pJ.InstrumentationNodeModuleDefinition(
        "mongodb",
        ["4.*", "5.*", "6.*"],
        void 0,
        void 0,
        [
          new pJ.InstrumentationNodeModuleFile(
            "mongodb/lib/cmap/connection.js",
            ["4.*", "5.*", "6.*"],
            o,
            i
          ),
          new pJ.InstrumentationNodeModuleFile(
            "mongodb/lib/cmap/connection_pool.js",
            ["4.*", "5.*", "6.*"],
            s,
            u
          ),
          new pJ.InstrumentationNodeModuleFile(
            "mongodb/lib/cmap/connect.js",
            ["4.*", "5.*", "6.*"],
            e,
            r
          ),
          new pJ.InstrumentationNodeModuleFile(
            "mongodb/lib/sessions.js",
            ["4.*", "5.*", "6.*"],
            c,
            a
          ),
        ]
      ),
    ];
  }
  jo() {
    return {
      v3PatchConnection: (t, n) => (
        hJ.diag.debug(`Applying patch for mongodb@${n}`),
        (0, pJ.isWrapped)(t.insert) && this.Rt(t, "insert"),
        this.yt(t, "insert", this.Fo("insert")),
        (0, pJ.isWrapped)(t.remove) && this.Rt(t, "remove"),
        this.yt(t, "remove", this.Fo("remove")),
        (0, pJ.isWrapped)(t.update) && this.Rt(t, "update"),
        this.yt(t, "update", this.Fo("update")),
        (0, pJ.isWrapped)(t.command) && this.Rt(t, "command"),
        this.yt(t, "command", this.Jo()),
        (0, pJ.isWrapped)(t.query) && this.Rt(t, "query"),
        this.yt(t, "query", this.zo()),
        (0, pJ.isWrapped)(t.getMore) && this.Rt(t, "getMore"),
        this.yt(t, "getMore", this.Qo()),
        t
      ),
      v3UnpatchConnection: (t, n) => {
        void 0 !== t &&
          (hJ.diag.debug(`Removing internal patch for mongodb@${n}`),
          this.Rt(t, "insert"),
          this.Rt(t, "remove"),
          this.Rt(t, "update"),
          this.Rt(t, "command"),
          this.Rt(t, "query"),
          this.Rt(t, "getMore"));
      },
    };
  }
  Bo() {
    return {
      v4PatchSessions: (t, n) => (
        hJ.diag.debug(`Applying patch for mongodb@${n}`),
        (0, pJ.isWrapped)(t.acquire) && this.Rt(t, "acquire"),
        this.yt(t.ServerSessionPool.prototype, "acquire", this.$o()),
        (0, pJ.isWrapped)(t.release) && this.Rt(t, "release"),
        this.yt(t.ServerSessionPool.prototype, "release", this.qo()),
        t
      ),
      v4UnpatchSessions: (t, n) => {
        hJ.diag.debug(`Removing internal patch for mongodb@${n}`),
          void 0 !== t &&
            ((0, pJ.isWrapped)(t.acquire) && this.Rt(t, "acquire"),
            (0, pJ.isWrapped)(t.release) && this.Rt(t, "release"));
      },
    };
  }
  $o() {
    const t = this;
    return (n) =>
      function () {
        const e = this.sessions.length,
          r = n.call(this),
          o = this.sessions.length;
        return (
          e === o
            ? t.Do.add(1, { state: "used", "pool.name": t.ti })
            : e - 1 === o &&
              (t.Do.add(-1, { state: "idle", "pool.name": t.ti }),
              t.Do.add(1, { state: "used", "pool.name": t.ti })),
          r
        );
      };
  }
  qo() {
    const t = this;
    return (n) =>
      function (e) {
        const r = n.call(this, e);
        return (
          t.Do.add(-1, { state: "used", "pool.name": t.ti }),
          t.Do.add(1, { state: "idle", "pool.name": t.ti }),
          r
        );
      };
  }
  Ko() {
    return {
      v4PatchConnectionPool: (t, n) => {
        hJ.diag.debug(`Applying patch for mongodb@${n}`);
        const e = t.ConnectionPool.prototype;
        return (
          (0, pJ.isWrapped)(e.checkOut) && this.Rt(e, "checkOut"),
          this.yt(e, "checkOut", this.ni()),
          t
        );
      },
      v4UnpatchConnectionPool: (t, n) => {
        hJ.diag.debug(`Removing internal patch for mongodb@${n}`),
          void 0 !== t && this.Rt(t.ConnectionPool.prototype, "checkOut");
      },
    };
  }
  xo() {
    return {
      v4PatchConnect: (t, n) => (
        hJ.diag.debug(`Applying patch for mongodb@${n}`),
        (0, pJ.isWrapped)(t.connect) && this.Rt(t, "connect"),
        this.yt(t, "connect", this.ei()),
        t
      ),
      v4UnpatchConnect: (t, n) => {
        hJ.diag.debug(`Removing internal patch for mongodb@${n}`),
          void 0 !== t && this.Rt(t, "connect");
      },
    };
  }
  ni() {
    return (t) =>
      function (n) {
        const e = hJ.context.bind(hJ.context.active(), n);
        return t.call(this, e);
      };
  }
  ei() {
    const t = this;
    return (n) =>
      function (e, r) {
        return n.call(this, e, function (n, o) {
          !n && o ? (t.setPoolName(e), r(n, o)) : r(n, o);
        });
      };
  }
  ko() {
    return {
      v4PatchConnection: (t, n) => (
        hJ.diag.debug(`Applying patch for mongodb@${n}`),
        (0, pJ.isWrapped)(t.Connection.prototype.command) &&
          this.Rt(t.Connection.prototype, "command"),
        this.yt(t.Connection.prototype, "command", this.ri()),
        t
      ),
      v4UnpatchConnection: (t, n) => {
        void 0 !== t &&
          (hJ.diag.debug(`Removing internal patch for mongodb@${n}`),
          this.Rt(t.Connection.prototype, "command"));
      },
    };
  }
  Fo(t) {
    const n = this;
    return (e) =>
      function (r, o, i, s, u) {
        const c = "function" == typeof s ? s : u;
        if (
          !hJ.trace.getSpan(hJ.context.active()) ||
          "function" != typeof c ||
          "object" != typeof i
        )
          return "function" == typeof s
            ? e.call(this, r, o, i, s)
            : e.call(this, r, o, i, s, u);
        const a = n.tracer.startSpan(`mongodb.${t}`, {
          kind: hJ.SpanKind.CLIENT,
        });
        n.oi(a, o, r, i[0], t);
        const l = n.ii(a, c);
        return "function" == typeof s
          ? e.call(this, r, o, i, l)
          : e.call(this, r, o, i, s, l);
      };
  }
  Jo() {
    const t = this;
    return (n) =>
      function (e, r, o, i, s) {
        const u = "function" == typeof i ? i : s;
        if (
          !hJ.trace.getSpan(hJ.context.active()) ||
          "function" != typeof u ||
          "object" != typeof o
        )
          return "function" == typeof i
            ? n.call(this, e, r, o, i)
            : n.call(this, e, r, o, i, s);
        const c = TJ.si(o),
          a = c === EJ.MongodbCommandType.UNKNOWN ? "command" : c,
          l = t.tracer.startSpan(`mongodb.${a}`, { kind: hJ.SpanKind.CLIENT }),
          f = c === EJ.MongodbCommandType.UNKNOWN ? void 0 : c;
        t.oi(l, r, e, o, f);
        const d = t.ii(l, u);
        return "function" == typeof i
          ? n.call(this, e, r, o, d)
          : n.call(this, e, r, o, i, d);
      };
  }
  ri() {
    const t = this;
    return (n) =>
      function (e, r, o, i) {
        const s = hJ.trace.getSpan(hJ.context.active()),
          u = i,
          c = Object.keys(r)[0];
        if (
          "function" != typeof u ||
          "object" != typeof r ||
          r.ismaster ||
          r.hello
        )
          return n.call(this, e, r, o, i);
        if (s) {
          const i = t.tracer.startSpan(`mongodb.${c}`, {
            kind: hJ.SpanKind.CLIENT,
          });
          t.ui(i, this, e, r, c);
          const s = t.ii(i, u, this.id, c);
          return n.call(this, e, r, o, s);
        }
        {
          const i = t.ii(void 0, u, this.id, c);
          return n.call(this, e, r, o, i);
        }
      };
  }
  zo() {
    const t = this;
    return (n) =>
      function (e, r, o, i, s, u) {
        const c = "function" == typeof s ? s : u;
        if (
          !hJ.trace.getSpan(hJ.context.active()) ||
          "function" != typeof c ||
          "object" != typeof o
        )
          return "function" == typeof s
            ? n.call(this, e, r, o, i, s)
            : n.call(this, e, r, o, i, s, u);
        const a = t.tracer.startSpan("mongodb.find", {
          kind: hJ.SpanKind.CLIENT,
        });
        t.oi(a, r, e, o, "find");
        const l = t.ii(a, c);
        return "function" == typeof s
          ? n.call(this, e, r, o, i, l)
          : n.call(this, e, r, o, i, s, l);
      };
  }
  Qo() {
    const t = this;
    return (n) =>
      function (e, r, o, i, s, u) {
        const c = "function" == typeof s ? s : u;
        if (!hJ.trace.getSpan(hJ.context.active()) || "function" != typeof c)
          return "function" == typeof s
            ? n.call(this, e, r, o, i, s)
            : n.call(this, e, r, o, i, s, u);
        const a = t.tracer.startSpan("mongodb.getMore", {
          kind: hJ.SpanKind.CLIENT,
        });
        t.oi(a, r, e, o.cmd, "getMore");
        const l = t.ii(a, c);
        return "function" == typeof s
          ? n.call(this, e, r, o, i, l)
          : n.call(this, e, r, o, i, s, l);
      };
  }
  static si(t) {
    return void 0 !== t.createIndexes
      ? EJ.MongodbCommandType.CREATE_INDEXES
      : void 0 !== t.findandmodify
        ? EJ.MongodbCommandType.FIND_AND_MODIFY
        : void 0 !== t.ismaster
          ? EJ.MongodbCommandType.IS_MASTER
          : void 0 !== t.count
            ? EJ.MongodbCommandType.COUNT
            : EJ.MongodbCommandType.UNKNOWN;
  }
  ui(t, n, e, r, o) {
    let i, s, u;
    if (n) {
      const t = "string" == typeof n.address ? n.address.split(":") : "";
      2 === t.length && ((i = t[0]), (s = t[1]));
    }
    (u =
      (null == r ? void 0 : r.documents) && r.documents[0]
        ? r.documents[0]
        : (null == r ? void 0 : r.cursors)
          ? r.cursors
          : r),
      this.ci(t, e.db, e.collection, i, s, u, o);
  }
  oi(t, n, e, r, o) {
    var i, s, u, c, a, l, f, d;
    let h, p;
    if (
      e &&
      e.s &&
      ((h =
        null !==
          (s = null === (i = e.s.options) || void 0 === i ? void 0 : i.host) &&
        void 0 !== s
          ? s
          : e.s.host),
      (p =
        null ===
          (a =
            null !==
              (c =
                null === (u = e.s.options) || void 0 === u ? void 0 : u.port) &&
            void 0 !== c
              ? c
              : e.s.port) || void 0 === a
          ? void 0
          : a.toString()),
      null == h || null == p)
    ) {
      const t =
        null === (l = e.description) || void 0 === l ? void 0 : l.address;
      if (t) {
        const n = t.split(":");
        (h = n[0]), (p = n[1]);
      }
    }
    const [S, E] = n.toString().split("."),
      m =
        null !==
          (d =
            null !== (f = null == r ? void 0 : r.query) && void 0 !== f
              ? f
              : null == r
                ? void 0
                : r.q) && void 0 !== d
          ? d
          : r;
    this.ci(t, S, E, h, p, m, o);
  }
  ci(t, n, e, r, o, i, s) {
    if (
      (t.setAttributes({
        [SJ.SemanticAttributes.DB_SYSTEM]: SJ.DbSystemValues.MONGODB,
        [SJ.SemanticAttributes.DB_NAME]: n,
        [SJ.SemanticAttributes.DB_MONGODB_COLLECTION]: e,
        [SJ.SemanticAttributes.DB_OPERATION]: s,
        [SJ.SemanticAttributes.DB_CONNECTION_STRING]:
          `mongodb://${r}:${o}/${n}`,
      }),
      r &&
        o &&
        t.setAttributes({
          [SJ.SemanticAttributes.NET_PEER_NAME]: r,
          [SJ.SemanticAttributes.NET_PEER_PORT]: o,
        }),
      !i)
    )
      return;
    const u =
      "function" == typeof this.Nt.dbStatementSerializer
        ? this.Nt.dbStatementSerializer
        : this.ai.bind(this);
    (0, pJ.safeExecuteInTheMiddle)(
      () => {
        const n = u(i);
        t.setAttribute(SJ.SemanticAttributes.DB_STATEMENT, n);
      },
      (t) => {
        t && this.Ct.error("Error running dbStatementSerializer hook", t);
      },
      !0
    );
  }
  ai(t) {
    var n;
    const e = !!(null === (n = this.Nt) || void 0 === n
      ? void 0
      : n.enhancedDatabaseReporting)
      ? t
      : Object.keys(t).reduce((t, n) => ((t[n] = "?"), t), {});
    return JSON.stringify(e);
  }
  Wo(t, n) {
    const e = this.getConfig();
    "function" == typeof e.responseHook &&
      (0, pJ.safeExecuteInTheMiddle)(
        () => {
          e.responseHook(t, { data: n });
        },
        (t) => {
          t && this.Ct.error("Error running response hook", t);
        },
        !0
      );
  }
  ii(t, n, e, r) {
    const o = hJ.context.active(),
      i = this;
    return function (...e) {
      const s = e[0];
      if (t) {
        if (s instanceof Error)
          null == t ||
            t.setStatus({ code: hJ.SpanStatusCode.ERROR, message: s.message });
        else {
          const n = e[1];
          i.Wo(t, n);
        }
        t.end();
      }
      return hJ.context.with(
        o,
        () => (
          "endSessions" === r &&
            i.Do.add(-1, { state: "idle", "pool.name": i.ti }),
          n.apply(this, e)
        )
      );
    };
  }
  setPoolName(t) {
    var n, e;
    const r = `mongodb://${
      null === (n = t.hostAddress) || void 0 === n ? void 0 : n.host
    }:${null === (e = t.hostAddress) || void 0 === e ? void 0 : e.port}/${
      t.dbName
    }`;
    this.ti = r;
  }
}
DF.MongoDBInstrumentation = TJ;
var _J = {};
!(function (t) {
  var n;
  Object.defineProperty(t, "__esModule", { value: !0 }),
    (t.MongodbCommandType = void 0),
    ((n = t.MongodbCommandType || (t.MongodbCommandType = {})).CREATE_INDEXES =
      "createIndexes"),
    (n.FIND_AND_MODIFY = "findAndModify"),
    (n.IS_MASTER = "isMaster"),
    (n.COUNT = "count"),
    (n.UNKNOWN = "unknown");
})(_J),
  (function (t) {
    var n =
        (Wt && Wt.__createBinding) ||
        (Object.create
          ? function (t, n, e, r) {
              void 0 === r && (r = e),
                Object.defineProperty(t, r, {
                  enumerable: !0,
                  get: function () {
                    return n[e];
                  },
                });
            }
          : function (t, n, e, r) {
              void 0 === r && (r = e), (t[r] = n[e]);
            }),
      e =
        (Wt && Wt.__exportStar) ||
        function (t, e) {
          for (var r in t)
            "default" === r ||
              Object.prototype.hasOwnProperty.call(e, r) ||
              n(e, t, r);
        };
    Object.defineProperty(t, "__esModule", { value: !0 }), e(DF, t), e(_J, t);
  })(HF);
const bJ = () => ({
  name: "Mongo",
  setupOnce() {
    AK(
      new HF.MongoDBInstrumentation({
        responseHook(t) {
          OK(t, "auto.db.otel.mongo");
        },
      })
    );
  },
});
var vJ = {},
  yJ = {},
  RJ = {};
Object.defineProperty(RJ, "__esModule", { value: !0 }),
  (RJ.handleCallbackResponse =
    RJ.handlePromiseResponse =
    RJ.getAttributesFromCollection =
      void 0);
const AJ = no,
  OJ = dF,
  gJ = KB;
function NJ(t, n = {}) {
  t.recordException(n),
    t.setStatus({
      code: AJ.SpanStatusCode.ERROR,
      message: `${n.message} ${
        n.code ? `\nMongoose Error Code: ${n.code}` : ""
      }`,
    });
}
function CJ(t, n, e, r = void 0) {
  e &&
    (0, OJ.safeExecuteInTheMiddle)(
      () => e(t, { moduleVersion: r, response: n }),
      (t) => {
        t && AJ.diag.error("mongoose instrumentation: responseHook error", t);
      },
      !0
    );
}
(RJ.getAttributesFromCollection = function (t) {
  return {
    [gJ.SemanticAttributes.DB_MONGODB_COLLECTION]: t.name,
    [gJ.SemanticAttributes.DB_NAME]: t.conn.name,
    [gJ.SemanticAttributes.DB_USER]: t.conn.user,
    [gJ.SemanticAttributes.NET_PEER_NAME]: t.conn.host,
    [gJ.SemanticAttributes.NET_PEER_PORT]: t.conn.port,
  };
}),
  (RJ.handlePromiseResponse = function (t, n, e, r = void 0) {
    return t instanceof Promise
      ? t
          .then((t) => (CJ(n, t, e, r), t))
          .catch((t) => {
            throw (NJ(n, t), t);
          })
          .finally(() => n.end())
      : (CJ(n, t, e, r), n.end(), t);
  }),
  (RJ.handleCallbackResponse = function (t, n, e, r, o, i = void 0) {
    return n.apply(e, [
      (n, e) => (n ? NJ(r, n) : CJ(r, e, o, i), r.end(), t(n, e)),
    ]);
  });
var LJ = {};
Object.defineProperty(LJ, "__esModule", { value: !0 }),
  (LJ.VERSION = void 0),
  (LJ.VERSION = "0.37.0"),
  (function (t) {
    Object.defineProperty(t, "__esModule", { value: !0 }),
      (t.MongooseInstrumentation = t.li = void 0);
    const n = no,
      e = pB,
      r = RJ,
      o = dF,
      i = LJ,
      s = KB,
      u = [
        "remove",
        "deleteOne",
        "deleteMany",
        "find",
        "findOne",
        "estimatedDocumentCount",
        "countDocuments",
        "count",
        "distinct",
        "where",
        "$where",
        "findOneAndUpdate",
        "findOneAndDelete",
        "findOneAndReplace",
        "findOneAndRemove",
      ];
    t.li = Symbol("stored-parent-span");
    class c extends o.InstrumentationBase {
      constructor(t = {}) {
        super(
          "@opentelemetry/instrumentation-mongoose",
          i.VERSION,
          Object.assign({}, t)
        );
      }
      setConfig(t = {}) {
        this.Nt = Object.assign({}, t);
      }
      init() {
        return new o.InstrumentationNodeModuleDefinition(
          "mongoose",
          [">=5.9.7 <7"],
          this.patch.bind(this),
          this.unpatch.bind(this)
        );
      }
      patch(t, n) {
        return (
          this.yt(
            t.Model.prototype,
            "save",
            this.patchOnModelMethods("save", n)
          ),
          (t.Model.prototype.$save = t.Model.prototype.save),
          this.yt(
            t.Model.prototype,
            "remove",
            this.patchOnModelMethods("remove", n)
          ),
          this.yt(t.Query.prototype, "exec", this.patchQueryExec(n)),
          this.yt(t.Aggregate.prototype, "exec", this.patchAggregateExec(n)),
          u.forEach((n) => {
            this.yt(t.Query.prototype, n, this.patchAndCaptureSpanContext(n));
          }),
          this.yt(t.Model, "aggregate", this.patchModelAggregate()),
          t
        );
      }
      unpatch(t) {
        this.Ct.debug("mongoose instrumentation: unpatch mongoose"),
          this.Rt(t.Model.prototype, "save"),
          (t.Model.prototype.$save = t.Model.prototype.save),
          this.Rt(t.Model.prototype, "remove"),
          this.Rt(t.Query.prototype, "exec"),
          this.Rt(t.Aggregate.prototype, "exec"),
          u.forEach((n) => {
            this.Rt(t.Query.prototype, n);
          }),
          this.Rt(t.Model, "aggregate");
      }
      patchAggregateExec(e) {
        const r = this;
        return (
          this.Ct.debug("patched mongoose Aggregate exec function"),
          (o) =>
            function (i) {
              var u;
              if (
                r.Nt.requireParentSpan &&
                void 0 === n.trace.getSpan(n.context.active())
              )
                return o.apply(this, arguments);
              const c = this[t.li],
                a = {};
              r.Nt.dbStatementSerializer &&
                (a[s.SemanticAttributes.DB_STATEMENT] =
                  r.Nt.dbStatementSerializer("aggregate", {
                    options: this.options,
                    aggregatePipeline: this.fi,
                  }));
              const l = r.di(
                this.hi.collection,
                null === (u = this.hi) || void 0 === u ? void 0 : u.modelName,
                "aggregate",
                a,
                c
              );
              return r.pi(l, o, this, arguments, i, e);
            }
        );
      }
      patchQueryExec(e) {
        const r = this;
        return (
          this.Ct.debug("patched mongoose Query exec function"),
          (o) =>
            function (i) {
              if (
                r.Nt.requireParentSpan &&
                void 0 === n.trace.getSpan(n.context.active())
              )
                return o.apply(this, arguments);
              const u = this[t.li],
                c = {};
              r.Nt.dbStatementSerializer &&
                (c[s.SemanticAttributes.DB_STATEMENT] =
                  r.Nt.dbStatementSerializer(this.op, {
                    condition: this.Si,
                    updates: this.Ei,
                    options: this.options,
                    fields: this.nt,
                  }));
              const a = r.di(
                this.mongooseCollection,
                this.model.modelName,
                this.op,
                c,
                u
              );
              return r.pi(a, o, this, arguments, i, e);
            }
        );
      }
      patchOnModelMethods(t, e) {
        const r = this;
        return (
          this.Ct.debug(`patching mongoose Model '${t}' operation`),
          (o) =>
            function (i, u) {
              if (
                r.Nt.requireParentSpan &&
                void 0 === n.trace.getSpan(n.context.active())
              )
                return o.apply(this, arguments);
              const c = { document: this };
              !i || i instanceof Function || (c.options = i);
              const a = {};
              r.Nt.dbStatementSerializer &&
                (a[s.SemanticAttributes.DB_STATEMENT] =
                  r.Nt.dbStatementSerializer(t, c));
              const l = r.di(
                this.constructor.collection,
                this.constructor.modelName,
                t,
                a
              );
              return (
                i instanceof Function && ((u = i), (i = void 0)),
                r.pi(l, o, this, arguments, u, e)
              );
            }
        );
      }
      patchModelAggregate() {
        const e = this;
        return (
          this.Ct.debug("patched mongoose model aggregate function"),
          (r) =>
            function () {
              const o = n.trace.getSpan(n.context.active()),
                i = e.mi(() => r.apply(this, arguments));
              return i && (i[t.li] = o), i;
            }
        );
      }
      patchAndCaptureSpanContext(e) {
        const r = this;
        return (
          this.Ct.debug(`patching mongoose query ${e} function`),
          (e) =>
            function () {
              return (
                (this[t.li] = n.trace.getSpan(n.context.active())),
                r.mi(() => e.apply(this, arguments))
              );
            }
        );
      }
      di(t, e, o, i, u) {
        return this.tracer.startSpan(
          `mongoose.${e}.${o}`,
          {
            kind: n.SpanKind.CLIENT,
            attributes: Object.assign(
              Object.assign(
                Object.assign({}, i),
                (0, r.getAttributesFromCollection)(t)
              ),
              {
                [s.SemanticAttributes.DB_OPERATION]: o,
                [s.SemanticAttributes.DB_SYSTEM]: "mongoose",
              }
            ),
          },
          u ? n.trace.setSpan(n.context.active(), u) : void 0
        );
      }
      pi(t, n, e, o, i, s = void 0) {
        const u = this;
        if (i instanceof Function)
          return u.mi(() =>
            (0, r.handleCallbackResponse)(i, n, e, t, u.Nt.responseHook, s)
          );
        {
          const i = u.mi(() => n.apply(e, o));
          return (0, r.handlePromiseResponse)(i, t, u.Nt.responseHook, s);
        }
      }
      mi(t) {
        var r;
        return (
          null === (r = this.Nt) || void 0 === r
            ? void 0
            : r.suppressInternalInstrumentation
        )
          ? n.context.with((0, e.suppressTracing)(n.context.active()), t)
          : t();
      }
    }
    t.MongooseInstrumentation = c;
  })(yJ);
var IJ = {};
Object.defineProperty(IJ, "__esModule", { value: !0 }),
  (function (t) {
    var n =
        (Wt && Wt.__createBinding) ||
        (Object.create
          ? function (t, n, e, r) {
              void 0 === r && (r = e),
                Object.defineProperty(t, r, {
                  enumerable: !0,
                  get: function () {
                    return n[e];
                  },
                });
            }
          : function (t, n, e, r) {
              void 0 === r && (r = e), (t[r] = n[e]);
            }),
      e =
        (Wt && Wt.__exportStar) ||
        function (t, e) {
          for (var r in t)
            "default" === r ||
              Object.prototype.hasOwnProperty.call(e, r) ||
              n(e, t, r);
        };
    Object.defineProperty(t, "__esModule", { value: !0 }), e(yJ, t), e(IJ, t);
  })(vJ);
const MJ = () => ({
  name: "Mongoose",
  setupOnce() {
    AK(
      new vJ.MongooseInstrumentation({
        responseHook(t) {
          OK(t, "auto.db.otel.mongoose");
        },
      })
    );
  },
});
var wJ = {},
  ZJ = {},
  PJ = {};
!(function (t) {
  Object.defineProperty(t, "__esModule", { value: !0 }),
    (t.AttributeNames = void 0),
    (function (t) {
      t.MYSQL_VALUES = "db.mysql.values";
    })(t.AttributeNames || (t.AttributeNames = {}));
})(PJ);
var VJ = {};
Object.defineProperty(VJ, "__esModule", { value: !0 }),
  (VJ.getPoolName =
    VJ.arrayStringifyHelper =
    VJ.getSpanName =
    VJ.getDbValues =
    VJ.getDbStatement =
    VJ.getConnectionAttributes =
      void 0);
const GJ = KB;
function XJ(t, n, e) {
  let r = `jdbc:mysql://${t || "localhost"}`;
  return (
    "number" == typeof n && (r += `:${n}`),
    "string" == typeof e && (r += `/${e}`),
    r
  );
}
function UJ(t) {
  return t ? `[${t.toString()}]` : "";
}
(VJ.getConnectionAttributes = function (t) {
  const {
      host: n,
      port: e,
      database: r,
      user: o,
    } = (function (t) {
      const {
        host: n,
        port: e,
        database: r,
        user: o,
      } = (t && t.connectionConfig) || t || {};
      return { host: n, port: e, database: r, user: o };
    })(t),
    i = parseInt(e, 10);
  return isNaN(i)
    ? {
        [GJ.SemanticAttributes.NET_PEER_NAME]: n,
        [GJ.SemanticAttributes.DB_CONNECTION_STRING]: XJ(n, e, r),
        [GJ.SemanticAttributes.DB_NAME]: r,
        [GJ.SemanticAttributes.DB_USER]: o,
      }
    : {
        [GJ.SemanticAttributes.NET_PEER_NAME]: n,
        [GJ.SemanticAttributes.NET_PEER_PORT]: i,
        [GJ.SemanticAttributes.DB_CONNECTION_STRING]: XJ(n, e, r),
        [GJ.SemanticAttributes.DB_NAME]: r,
        [GJ.SemanticAttributes.DB_USER]: o,
      };
}),
  (VJ.getDbStatement = function (t) {
    return "string" == typeof t ? t : t.sql;
  }),
  (VJ.getDbValues = function (t, n) {
    return UJ("string" == typeof t ? n : n || t.values);
  }),
  (VJ.getSpanName = function (t) {
    return "object" == typeof t ? t.sql : t.split(" ")[0];
  }),
  (VJ.arrayStringifyHelper = UJ),
  (VJ.getPoolName = function (t) {
    const n = t.config.connectionConfig;
    let e = "";
    return (
      (e += n.host ? `host: '${n.host}', ` : ""),
      (e += n.port ? `port: ${n.port}, ` : ""),
      (e += n.database ? `database: '${n.database}', ` : ""),
      (e += n.user ? `user: '${n.user}'` : ""),
      n.user || (e = e.substring(0, e.length - 2)),
      e.trim()
    );
  });
var WJ = {};
Object.defineProperty(WJ, "__esModule", { value: !0 }),
  (WJ.VERSION = void 0),
  (WJ.VERSION = "0.37.0"),
  Object.defineProperty(ZJ, "__esModule", { value: !0 }),
  (ZJ.MySQLInstrumentation = void 0);
const YJ = no,
  HJ = dF,
  DJ = KB,
  jJ = PJ,
  xJ = VJ,
  kJ = WJ;
class KJ extends HJ.InstrumentationBase {
  constructor(t) {
    super("@opentelemetry/instrumentation-mysql", kJ.VERSION, t), this.Ti();
  }
  setMeterProvider(t) {
    super.setMeterProvider(t), this.Ti();
  }
  Ti() {
    this.Do = this.meter.createUpDownCounter("db.client.connections.usage", {
      description:
        "The number of connections that are currently in state described by the state attribute.",
      unit: "{connection}",
    });
  }
  init() {
    return [
      new HJ.InstrumentationNodeModuleDefinition(
        "mysql",
        ["2.*"],
        (t, n) => (
          YJ.diag.debug(`Patching mysql@${n}`),
          YJ.diag.debug("Patching mysql.createConnection"),
          (0, HJ.isWrapped)(t.createConnection) &&
            this.Rt(t, "createConnection"),
          this.yt(t, "createConnection", this._i()),
          YJ.diag.debug("Patching mysql.createPool"),
          (0, HJ.isWrapped)(t.createPool) && this.Rt(t, "createPool"),
          this.yt(t, "createPool", this.bi()),
          YJ.diag.debug("Patching mysql.createPoolCluster"),
          (0, HJ.isWrapped)(t.createPoolCluster) &&
            this.Rt(t, "createPoolCluster"),
          this.yt(t, "createPoolCluster", this.vi()),
          t
        ),
        (t) => {
          void 0 !== t &&
            (this.Rt(t, "createConnection"),
            this.Rt(t, "createPool"),
            this.Rt(t, "createPoolCluster"));
        }
      ),
    ];
  }
  _i() {
    return (t) => {
      const n = this;
      return (
        YJ.diag.debug(
          "MySQLInstrumentation#patch: patched mysql createConnection"
        ),
        function (e) {
          const r = t(...arguments);
          return n.yt(r, "query", n.yi(r)), r;
        }
      );
    };
  }
  bi() {
    return (t) => {
      const n = this;
      return (
        YJ.diag.debug("MySQLInstrumentation#patch: patched mysql createPool"),
        function (e) {
          const r = t(...arguments);
          return (
            n.yt(r, "query", n.yi(r)),
            n.yt(r, "getConnection", n.Ri(r)),
            n.yt(r, "end", n.Ai(r)),
            n.Oi(r, n, ""),
            r
          );
        }
      );
    };
  }
  Ai(t) {
    return (n) => {
      const e = this;
      return (
        YJ.diag.debug("MySQLInstrumentation#patch: patched mysql pool end"),
        function (r) {
          const o = t.gi.length,
            i = t.Ni.length,
            s = o - i,
            u = (0, xJ.getPoolName)(t);
          e.Do.add(-s, { state: "used", name: u }),
            e.Do.add(-i, { state: "idle", name: u }),
            n.apply(t, arguments);
        }
      );
    };
  }
  vi() {
    return (t) => {
      const n = this;
      return (
        YJ.diag.debug(
          "MySQLInstrumentation#patch: patched mysql createPoolCluster"
        ),
        function (e) {
          const r = t(...arguments);
          return n.yt(r, "getConnection", n.Ri(r)), n.yt(r, "add", n.Ci(r)), r;
        }
      );
    };
  }
  Ci(t) {
    return (n) => {
      const e = this;
      return (
        YJ.diag.debug(
          "MySQLInstrumentation#patch: patched mysql pool cluster add"
        ),
        function (r, o) {
          if (!e.dn) return e.Rt(t, "add"), n.apply(t, arguments);
          n.apply(t, arguments);
          const i = t.Li;
          if (i) {
            const n =
              i["object" == typeof r ? "CLUSTER::" + t.Ii : String(r)].pool;
            e.Oi(n, e, r);
          }
        }
      );
    };
  }
  Ri(t) {
    return (n) => {
      const e = this;
      return (
        YJ.diag.debug(
          "MySQLInstrumentation#patch: patched mysql pool getConnection"
        ),
        function (r, o, i) {
          if (!e.dn) return e.Rt(t, "getConnection"), n.apply(t, arguments);
          if (1 === arguments.length && "function" == typeof r) {
            const o = e.Mi(r);
            return n.call(t, o);
          }
          if (2 === arguments.length && "function" == typeof o) {
            const i = e.Mi(o);
            return n.call(t, r, i);
          }
          if (3 === arguments.length && "function" == typeof i) {
            const s = e.Mi(i);
            return n.call(t, r, o, s);
          }
          return n.apply(t, arguments);
        }
      );
    };
  }
  Mi(t) {
    const n = this,
      e = YJ.context.active();
    return function (r, o) {
      o && ((0, HJ.isWrapped)(o.query) || n.yt(o, "query", n.yi(o))),
        "function" == typeof t && YJ.context.with(e, t, this, r, o);
    };
  }
  yi(t) {
    return (n) => {
      const e = this;
      return (
        YJ.diag.debug("MySQLInstrumentation: patched mysql query"),
        function (r, o, i) {
          if (!e.dn) return e.Rt(t, "query"), n.apply(t, arguments);
          const s = e.tracer.startSpan((0, xJ.getSpanName)(r), {
            kind: YJ.SpanKind.CLIENT,
            attributes: Object.assign(
              Object.assign({}, KJ.COMMON_ATTRIBUTES),
              (0, xJ.getConnectionAttributes)(t.config)
            ),
          });
          s.setAttribute(
            DJ.SemanticAttributes.DB_STATEMENT,
            (0, xJ.getDbStatement)(r)
          );
          if (e.getConfig().enhancedDatabaseReporting) {
            let t;
            Array.isArray(o) ? (t = o) : arguments[2] && (t = [o]),
              s.setAttribute(
                jJ.AttributeNames.MYSQL_VALUES,
                (0, xJ.getDbValues)(r, t)
              );
          }
          const u = Array.from(arguments).findIndex(
              (t) => "function" == typeof t
            ),
            c = YJ.context.active();
          if (-1 === u) {
            const e = YJ.context.with(
              YJ.trace.setSpan(YJ.context.active(), s),
              () => n.apply(t, arguments)
            );
            return (
              YJ.context.bind(c, e),
              e
                .on("error", (t) =>
                  s.setStatus({
                    code: YJ.SpanStatusCode.ERROR,
                    message: t.message,
                  })
                )
                .on("end", () => {
                  s.end();
                })
            );
          }
          return (
            e.yt(arguments, u, e.wi(s, c)),
            YJ.context.with(YJ.trace.setSpan(YJ.context.active(), s), () =>
              n.apply(t, arguments)
            )
          );
        }
      );
    };
  }
  wi(t, n) {
    return (e) =>
      function (r, o, i) {
        return (
          r &&
            t.setStatus({ code: YJ.SpanStatusCode.ERROR, message: r.message }),
          t.end(),
          YJ.context.with(n, () => e(...arguments))
        );
      };
  }
  Oi(t, n, e) {
    const r = e || (0, xJ.getPoolName)(t);
    t.on("connection", (t) => {
      n.Do.add(1, { state: "idle", name: r });
    }),
      t.on("acquire", (t) => {
        n.Do.add(-1, { state: "idle", name: r }),
          n.Do.add(1, { state: "used", name: r });
      }),
      t.on("release", (t) => {
        n.Do.add(-1, { state: "used", name: r }),
          n.Do.add(1, { state: "idle", name: r });
      });
  }
}
(ZJ.MySQLInstrumentation = KJ),
  (KJ.COMMON_ATTRIBUTES = {
    [DJ.SemanticAttributes.DB_SYSTEM]: DJ.DbSystemValues.MYSQL,
  });
var BJ = {};
Object.defineProperty(BJ, "__esModule", { value: !0 }),
  (function (t) {
    var n =
        (Wt && Wt.__createBinding) ||
        (Object.create
          ? function (t, n, e, r) {
              void 0 === r && (r = e),
                Object.defineProperty(t, r, {
                  enumerable: !0,
                  get: function () {
                    return n[e];
                  },
                });
            }
          : function (t, n, e, r) {
              void 0 === r && (r = e), (t[r] = n[e]);
            }),
      e =
        (Wt && Wt.__exportStar) ||
        function (t, e) {
          for (var r in t)
            "default" === r ||
              Object.prototype.hasOwnProperty.call(e, r) ||
              n(e, t, r);
        };
    Object.defineProperty(t, "__esModule", { value: !0 }), e(ZJ, t), e(BJ, t);
  })(wJ);
const FJ = () => ({
  name: "Mysql",
  setupOnce() {
    AK(new wJ.MySQLInstrumentation({}));
  },
});
var JJ = {},
  zJ = {},
  QJ = {};
Object.defineProperty(QJ, "__esModule", { value: !0 }),
  (QJ.addSqlCommenterComment = void 0);
const $J = no,
  qJ = pB;
QJ.addSqlCommenterComment = function (t, n) {
  if ("string" != typeof n || 0 === n.length) return n;
  if (
    (function (t) {
      const n = t.indexOf("--");
      return n >= 0 || (!(t.indexOf("/*") < 0) && n < t.indexOf("*/"));
    })(n)
  )
    return n;
  const e = new qJ.W3CTraceContextPropagator(),
    r = {};
  e.inject($J.trace.setSpan($J.ROOT_CONTEXT, t), r, $J.defaultTextMapSetter);
  const o = Object.keys(r).sort();
  return 0 === o.length
    ? n
    : `${n} /*${o
        .map(
          (t) =>
            `${t}='${encodeURIComponent(r[t]).replace(
              /[!'()*]/g,
              (t) => `%${t.charCodeAt(0).toString(16).toUpperCase()}`
            )}'`
        )
        .join(",")}*/`;
};
var tz = {};
Object.defineProperty(tz, "__esModule", { value: !0 }),
  (tz.once =
    tz.getSpanName =
    tz.getDbStatement =
    tz.getConnectionAttributes =
      void 0);
const nz = KB;
function ez(t, n, e) {
  let r = `jdbc:mysql://${t || "localhost"}`;
  return (
    "number" == typeof n && (r += `:${n}`),
    "string" == typeof e && (r += `/${e}`),
    r
  );
}
(tz.getConnectionAttributes = function (t) {
  const {
      host: n,
      port: e,
      database: r,
      user: o,
    } = (function (t) {
      const {
        host: n,
        port: e,
        database: r,
        user: o,
      } = (t && t.connectionConfig) || t || {};
      return { host: n, port: e, database: r, user: o };
    })(t),
    i = parseInt(e, 10);
  return isNaN(i)
    ? {
        [nz.SemanticAttributes.NET_PEER_NAME]: n,
        [nz.SemanticAttributes.DB_CONNECTION_STRING]: ez(n, e, r),
        [nz.SemanticAttributes.DB_NAME]: r,
        [nz.SemanticAttributes.DB_USER]: o,
      }
    : {
        [nz.SemanticAttributes.NET_PEER_NAME]: n,
        [nz.SemanticAttributes.NET_PEER_PORT]: i,
        [nz.SemanticAttributes.DB_CONNECTION_STRING]: ez(n, e, r),
        [nz.SemanticAttributes.DB_NAME]: r,
        [nz.SemanticAttributes.DB_USER]: o,
      };
}),
  (tz.getDbStatement = function (t, n, e) {
    return "string" == typeof t
      ? e
        ? n(t, e)
        : t
      : e || t.values
        ? n(t.sql, e || t.values)
        : t.sql;
  }),
  (tz.getSpanName = function (t) {
    var n;
    const e = "object" == typeof t ? t.sql : t;
    return null === (n = null == e ? void 0 : e.split(" ")) || void 0 === n
      ? void 0
      : n[0];
  });
tz.once = (t) => {
  let n = !1;
  return (...e) => {
    if (!n) return (n = !0), t(...e);
  };
};
var rz = {};
Object.defineProperty(rz, "__esModule", { value: !0 }),
  (rz.VERSION = void 0),
  (rz.VERSION = "0.37.0"),
  Object.defineProperty(zJ, "__esModule", { value: !0 }),
  (zJ.MySQL2Instrumentation = void 0);
const oz = no,
  iz = dF,
  sz = KB,
  uz = QJ,
  cz = tz,
  az = rz;
class lz extends iz.InstrumentationBase {
  constructor(t) {
    super("@opentelemetry/instrumentation-mysql2", az.VERSION, t);
  }
  init() {
    return [
      new iz.InstrumentationNodeModuleDefinition(
        "mysql2",
        [">= 1.4.2 < 4.0"],
        (t, n) => {
          oz.diag.debug(`Patching mysql2@${n}`);
          const e = t.Connection.prototype;
          return (
            oz.diag.debug("Patching Connection.prototype.query"),
            (0, iz.isWrapped)(e.query) && this.Rt(e, "query"),
            this.yt(e, "query", this.yi(t.format, !1)),
            (0, iz.isWrapped)(e.execute) && this.Rt(e, "execute"),
            this.yt(e, "execute", this.yi(t.format, !0)),
            t
          );
        },
        (t) => {
          if (void 0 === t) return;
          const n = t.Connection.prototype;
          this.Rt(n, "query"), this.Rt(n, "execute");
        }
      ),
    ];
  }
  yi(t, n) {
    return (e) => {
      const r = this;
      return (
        oz.diag.debug("MySQL2Instrumentation: patched mysql query/execute"),
        function (o, i, s) {
          const u = r.Nt;
          let c;
          Array.isArray(i) ? (c = i) : arguments[2] && (c = [i]);
          const a = r.tracer.startSpan((0, cz.getSpanName)(o), {
            kind: oz.SpanKind.CLIENT,
            attributes: Object.assign(
              Object.assign(
                Object.assign({}, lz.COMMON_ATTRIBUTES),
                (0, cz.getConnectionAttributes)(this.config)
              ),
              {
                [sz.SemanticAttributes.DB_STATEMENT]: (0, cz.getDbStatement)(
                  o,
                  t,
                  c
                ),
              }
            ),
          });
          !n &&
            u.addSqlCommenterCommentToQueries &&
            (arguments[0] = o =
              "string" == typeof o
                ? (0, uz.addSqlCommenterComment)(a, o)
                : Object.assign(o, {
                    sql: (0, uz.addSqlCommenterComment)(a, o.sql),
                  }));
          const l = (0, cz.once)((t, n) => {
            t
              ? a.setStatus({
                  code: oz.SpanStatusCode.ERROR,
                  message: t.message,
                })
              : "function" == typeof u.responseHook &&
                (0, iz.safeExecuteInTheMiddle)(
                  () => {
                    u.responseHook(a, { queryResults: n });
                  },
                  (t) => {
                    t && r.Ct.warn("Failed executing responseHook", t);
                  },
                  !0
                ),
              a.end();
          });
          if (1 === arguments.length) {
            "function" == typeof o.onResult && r.yt(o, "onResult", r.wi(l));
            const t = e.apply(this, arguments);
            return (
              t
                .once("error", (t) => {
                  l(t);
                })
                .once("result", (t) => {
                  l(void 0, t);
                }),
              t
            );
          }
          return (
            "function" == typeof arguments[1]
              ? r.yt(arguments, 1, r.wi(l))
              : "function" == typeof arguments[2] &&
                r.yt(arguments, 2, r.wi(l)),
            e.apply(this, arguments)
          );
        }
      );
    };
  }
  wi(t) {
    return (n) =>
      function (e, r, o) {
        return t(e, r), n(...arguments);
      };
  }
}
(zJ.MySQL2Instrumentation = lz),
  (lz.COMMON_ATTRIBUTES = {
    [sz.SemanticAttributes.DB_SYSTEM]: sz.DbSystemValues.MYSQL,
  });
var fz = {};
Object.defineProperty(fz, "__esModule", { value: !0 }),
  (function (t) {
    var n =
        (Wt && Wt.__createBinding) ||
        (Object.create
          ? function (t, n, e, r) {
              void 0 === r && (r = e),
                Object.defineProperty(t, r, {
                  enumerable: !0,
                  get: function () {
                    return n[e];
                  },
                });
            }
          : function (t, n, e, r) {
              void 0 === r && (r = e), (t[r] = n[e]);
            }),
      e =
        (Wt && Wt.__exportStar) ||
        function (t, e) {
          for (var r in t)
            "default" === r ||
              Object.prototype.hasOwnProperty.call(e, r) ||
              n(e, t, r);
        };
    Object.defineProperty(t, "__esModule", { value: !0 });
    const r = zJ;
    e(zJ, t), (t.default = r.MySQL2Instrumentation), e(fz, t);
  })(JJ);
const dz = () => ({
  name: "Mysql2",
  setupOnce() {
    AK(
      new JJ.MySQL2Instrumentation({
        responseHook(t) {
          OK(t, "auto.db.otel.mysql2");
        },
      })
    );
  },
});
var hz = {},
  pz = {},
  Sz = (function () {
    function t() {}
    return (t.prototype.emit = function (t) {}), t;
  })(),
  Ez = (function () {
    function t() {}
    return (
      (t.prototype.getLogger = function (t, n, e) {
        return new Sz();
      }),
      t
    );
  })(),
  mz = new Ez(),
  Tz = "object" == typeof globalThis ? globalThis : global,
  _z = Symbol.for("io.opentelemetry.js.api.logs"),
  bz = Tz;
var vz = (function () {
    function t() {}
    return (
      (t.getInstance = function () {
        return this.L || (this.L = new t()), this.L;
      }),
      (t.prototype.setGlobalLoggerProvider = function (t) {
        return bz[_z]
          ? this.getLoggerProvider()
          : ((bz[_z] =
              ((n = 1),
              (e = t),
              (r = mz),
              function (t) {
                return t === n ? e : r;
              })),
            t);
        var n, e, r;
      }),
      (t.prototype.getLoggerProvider = function () {
        var t, n;
        return null !==
          (n =
            null === (t = bz[_z]) || void 0 === t ? void 0 : t.call(bz, 1)) &&
          void 0 !== n
          ? n
          : mz;
      }),
      (t.prototype.getLogger = function (t, n, e) {
        return this.getLoggerProvider().getLogger(t, n, e);
      }),
      (t.prototype.disable = function () {
        delete bz[_z];
      }),
      t
    );
  })(),
  yz = vz.getInstance();
function Rz(t) {
  void 0 === t && (t = []);
  for (var n = [], e = 0, r = t.length; e < r; e++) {
    var o = t[e];
    if (Array.isArray(o)) {
      var i = Rz(o);
      n = n.concat(i.instrumentations);
    } else
      "function" == typeof o
        ? n.push(new o())
        : o.instrumentationName && n.push(o);
  }
  return { instrumentations: n };
}
var Az = function () {
    return (
      (Az =
        Object.assign ||
        function (t) {
          for (var n, e = 1, r = arguments.length; e < r; e++)
            for (var o in (n = arguments[e]))
              Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
          return t;
        }),
      Az.apply(this, arguments)
    );
  },
  Oz = (function () {
    function t(t, n, e) {
      void 0 === e && (e = {}),
        (this.instrumentationName = t),
        (this.instrumentationVersion = n),
        (this.yt = Ty.wrap),
        (this.Rt = Ty.unwrap),
        (this.At = Ty.massWrap),
        (this.Ot = Ty.massUnwrap),
        (this.Nt = Az({ enabled: !0 }, e)),
        (this.Ct = Pr.createComponentLogger({ namespace: t })),
        (this.Lt = Qr.getTracer(t, n)),
        (this.It = Ur.getMeter(t, n)),
        (this.Mt = yz.getLogger(t, n)),
        this.wt();
    }
    return (
      Object.defineProperty(t.prototype, "meter", {
        get: function () {
          return this.It;
        },
        enumerable: !1,
        configurable: !0,
      }),
      (t.prototype.setMeterProvider = function (t) {
        (this.It = t.getMeter(
          this.instrumentationName,
          this.instrumentationVersion
        )),
          this.wt();
      }),
      Object.defineProperty(t.prototype, "logger", {
        get: function () {
          return this.Mt;
        },
        enumerable: !1,
        configurable: !0,
      }),
      (t.prototype.setLoggerProvider = function (t) {
        this.Mt = t.getLogger(
          this.instrumentationName,
          this.instrumentationVersion
        );
      }),
      (t.prototype.getModuleDefinitions = function () {
        var t,
          n = null !== (t = this.init()) && void 0 !== t ? t : [];
        return Array.isArray(n) ? n : [n];
      }),
      (t.prototype.wt = function () {}),
      (t.prototype.getConfig = function () {
        return this.Nt;
      }),
      (t.prototype.setConfig = function (t) {
        void 0 === t && (t = {}), (this.Nt = Object.assign({}, t));
      }),
      (t.prototype.setTracerProvider = function (t) {
        this.Lt = t.getTracer(
          this.instrumentationName,
          this.instrumentationVersion
        );
      }),
      Object.defineProperty(t.prototype, "tracer", {
        get: function () {
          return this.Lt;
        },
        enumerable: !1,
        configurable: !0,
      }),
      t
    );
  })(),
  gz = function (t) {
    var n = "function" == typeof Symbol && Symbol.iterator,
      e = n && t[n],
      r = 0;
    if (e) return e.call(t);
    if (t && "number" == typeof t.length)
      return {
        next: function () {
          return (
            t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t }
          );
        },
      };
    throw new TypeError(
      n ? "Object is not iterable." : "Symbol.iterator is not defined."
    );
  },
  Nz = function (t, n) {
    var e = "function" == typeof Symbol && t[Symbol.iterator];
    if (!e) return t;
    var r,
      o,
      i = e.call(t),
      s = [];
    try {
      for (; (void 0 === n || n-- > 0) && !(r = i.next()).done; )
        s.push(r.value);
    } catch (t) {
      o = { error: t };
    } finally {
      try {
        r && !r.done && (e = i.return) && e.call(i);
      } finally {
        if (o) throw o.error;
      }
    }
    return s;
  },
  Cz = function (t, n, e) {
    if (e || 2 === arguments.length)
      for (var r, o = 0, i = n.length; o < i; o++)
        (!r && o in n) ||
          (r || (r = Array.prototype.slice.call(n, 0, o)), (r[o] = n[o]));
    return t.concat(r || Array.prototype.slice.call(n));
  },
  Lz = "/",
  Iz = function () {
    (this.hooks = []), (this.children = new Map());
  },
  Mz = (function () {
    function t() {
      (this.rn = new Iz()), (this.sn = 0);
    }
    return (
      (t.prototype.insert = function (t) {
        var n,
          e,
          r = this.rn;
        try {
          for (
            var o = gz(t.moduleName.split(Lz)), i = o.next();
            !i.done;
            i = o.next()
          ) {
            var s = i.value,
              u = r.children.get(s);
            u || ((u = new Iz()), r.children.set(s, u)), (r = u);
          }
        } catch (t) {
          n = { error: t };
        } finally {
          try {
            i && !i.done && (e = o.return) && e.call(o);
          } finally {
            if (n) throw n.error;
          }
        }
        r.hooks.push({ hook: t, insertedId: this.sn++ });
      }),
      (t.prototype.search = function (t, n) {
        var e,
          r,
          o = void 0 === n ? {} : n,
          i = o.maintainInsertionOrder,
          s = o.fullOnly,
          u = this.rn,
          c = [],
          a = !0;
        try {
          for (var l = gz(t.split(Lz)), f = l.next(); !f.done; f = l.next()) {
            var d = f.value,
              h = u.children.get(d);
            if (!h) {
              a = !1;
              break;
            }
            s || c.push.apply(c, Cz([], Nz(h.hooks), !1)), (u = h);
          }
        } catch (t) {
          e = { error: t };
        } finally {
          try {
            f && !f.done && (r = l.return) && r.call(l);
          } finally {
            if (e) throw e.error;
          }
        }
        return (
          s && a && c.push.apply(c, Cz([], Nz(u.hooks), !1)),
          0 === c.length
            ? []
            : 1 === c.length
              ? [c[0].hook]
              : (i &&
                  c.sort(function (t, n) {
                    return t.insertedId - n.insertedId;
                  }),
                c.map(function (t) {
                  return t.hook;
                }))
        );
      }),
      t
    );
  })(),
  wz = function (t) {
    var n = "function" == typeof Symbol && Symbol.iterator,
      e = n && t[n],
      r = 0;
    if (e) return e.call(t);
    if (t && "number" == typeof t.length)
      return {
        next: function () {
          return (
            t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t }
          );
        },
      };
    throw new TypeError(
      n ? "Object is not iterable." : "Symbol.iterator is not defined."
    );
  },
  Zz = ["afterEach", "after", "beforeEach", "before", "describe", "it"].every(
    function (t) {
      return "function" == typeof global[t];
    }
  ),
  Pz = (function () {
    function t() {
      (this.un = new Mz()), this.cn();
    }
    return (
      (t.prototype.cn = function () {
        var t = this;
        new JR(null, { internals: !0 }, function (n, e, r) {
          var o,
            i,
            s,
            u = ((s = e), A.sep !== Lz ? s.split(A.sep).join(Lz) : s),
            c = t.un.search(u, {
              maintainInsertionOrder: !0,
              fullOnly: void 0 === r,
            });
          try {
            for (var a = wz(c), l = a.next(); !l.done; l = a.next()) {
              n = (0, l.value.onRequire)(n, e, r);
            }
          } catch (t) {
            o = { error: t };
          } finally {
            try {
              l && !l.done && (i = a.return) && i.call(a);
            } finally {
              if (o) throw o.error;
            }
          }
          return n;
        });
      }),
      (t.prototype.register = function (t, n) {
        var e = { moduleName: t, onRequire: n };
        return this.un.insert(e), e;
      }),
      (t.getInstance = function () {
        var n;
        return Zz
          ? new t()
          : (this.L = null !== (n = this.L) && void 0 !== n ? n : new t());
      }),
      t
    );
  })();
var Vz = (function () {
    var t = function (n, e) {
      return (
        (t =
          Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array &&
            function (t, n) {
              t.__proto__ = n;
            }) ||
          function (t, n) {
            for (var e in n)
              Object.prototype.hasOwnProperty.call(n, e) && (t[e] = n[e]);
          }),
        t(n, e)
      );
    };
    return function (n, e) {
      if ("function" != typeof e && null !== e)
        throw new TypeError(
          "Class extends value " + String(e) + " is not a constructor or null"
        );
      function r() {
        this.constructor = n;
      }
      t(n, e),
        (n.prototype =
          null === e
            ? Object.create(e)
            : ((r.prototype = e.prototype), new r()));
    };
  })(),
  Gz = function (t) {
    var n = "function" == typeof Symbol && Symbol.iterator,
      e = n && t[n],
      r = 0;
    if (e) return e.call(t);
    if (t && "number" == typeof t.length)
      return {
        next: function () {
          return (
            t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t }
          );
        },
      };
    throw new TypeError(
      n ? "Object is not iterable." : "Symbol.iterator is not defined."
    );
  },
  Xz = (function (t) {
    function n(n, r, o) {
      void 0 === o && (o = {});
      var i = t.call(this, n, r, o) || this;
      (i.ln = []),
        (i.fn = Pz.getInstance()),
        (i.dn = !1),
        (i.yt = function (t, n, r) {
          if (e.types.isProxy(t)) {
            var o = Ty.wrap(Object.assign({}, t), n, r);
            return Object.defineProperty(t, n, { value: o });
          }
          return Ty.wrap(t, n, r);
        }),
        (i.Rt = function (t, n) {
          return e.types.isProxy(t)
            ? Object.defineProperty(t, n, { value: t[n] })
            : Ty.unwrap(t, n);
        }),
        (i.At = function (t, n, e) {
          t
            ? (Array.isArray(t) || (t = [t]),
              n && Array.isArray(n)
                ? t.forEach(function (t) {
                    n.forEach(function (n) {
                      i.yt(t, n, e);
                    });
                  })
                : Pr.error(
                    "must provide one or more functions to wrap on modules"
                  ))
            : Pr.error("must provide one or more modules to patch");
        }),
        (i.Ot = function (t, n) {
          t
            ? (Array.isArray(t) || (t = [t]),
              n && Array.isArray(n)
                ? t.forEach(function (t) {
                    n.forEach(function (n) {
                      i.Rt(t, n);
                    });
                  })
                : Pr.error(
                    "must provide one or more functions to wrap on modules"
                  ))
            : Pr.error("must provide one or more modules to patch");
        });
      var s = i.init();
      return (
        s && !Array.isArray(s) && (s = [s]),
        (i.hn = s || []),
        0 === i.hn.length &&
          Pr.debug(
            "No modules instrumentation has been defined for '" +
              i.instrumentationName +
              "@" +
              i.instrumentationVersion +
              "', nothing will be patched"
          ),
        i.Nt.enabled && i.enable(),
        i
      );
    }
    return (
      Vz(n, t),
      (n.prototype.pn = function () {
        var t = this;
        this.hn.forEach(function (n) {
          var e = n.name;
          try {
            var r = require.resolve(e);
            require.cache[r] &&
              t.Ct.warn(
                "Module " +
                  e +
                  " has been loaded before " +
                  t.instrumentationName +
                  " so it might not work, please initialize it before requiring " +
                  e
              );
          } catch (t) {}
        });
      }),
      (n.prototype.Sn = function (t) {
        try {
          var n = o.readFileSync(A.join(t, "package.json"), {
              encoding: "utf8",
            }),
            e = JSON.parse(n).version;
          return "string" == typeof e ? e : void 0;
        } catch (n) {
          Pr.warn("Failed extracting version", t);
        }
      }),
      (n.prototype.En = function (t, n, e, r) {
        var o,
          i = this;
        if (!r)
          return "function" == typeof t.patch &&
            ((t.moduleExports = n), this.dn)
            ? (this.Ct.debug(
                "Applying instrumentation patch for nodejs core module on require hook",
                { module: t.name }
              ),
              t.patch(n))
            : n;
        var s = this.Sn(r);
        if (((t.moduleVersion = s), t.name === e))
          return Uz(t.supportedVersions, s, t.includePrerelease) &&
            "function" == typeof t.patch &&
            ((t.moduleExports = n), this.dn)
            ? (this.Ct.debug(
                "Applying instrumentation patch for module on require hook",
                { module: t.name, version: t.moduleVersion, baseDir: r }
              ),
              t.patch(n, t.moduleVersion))
            : n;
        var u = null !== (o = t.files) && void 0 !== o ? o : [],
          c = A.normalize(e);
        return u
          .filter(function (t) {
            return t.name === c;
          })
          .filter(function (n) {
            return Uz(n.supportedVersions, s, t.includePrerelease);
          })
          .reduce(function (n, e) {
            return (
              (e.moduleExports = n),
              i.dn
                ? (i.Ct.debug(
                    "Applying instrumentation patch for nodejs module file on require hook",
                    {
                      module: t.name,
                      version: t.moduleVersion,
                      fileName: e.name,
                      baseDir: r,
                    }
                  ),
                  e.patch(n, t.moduleVersion))
                : n
            );
          }, n);
      }),
      (n.prototype.enable = function () {
        var t,
          n,
          e,
          r,
          o,
          i,
          s = this;
        if (!this.dn)
          if (((this.dn = !0), this.ln.length > 0))
            try {
              for (var u = Gz(this.hn), c = u.next(); !c.done; c = u.next()) {
                var a = c.value;
                "function" == typeof a.patch &&
                  a.moduleExports &&
                  (this.Ct.debug(
                    "Applying instrumentation patch for nodejs module on instrumentation enabled",
                    { module: a.name, version: a.moduleVersion }
                  ),
                  a.patch(a.moduleExports, a.moduleVersion));
                try {
                  for (
                    var l = ((e = void 0), Gz(a.files)), f = l.next();
                    !f.done;
                    f = l.next()
                  ) {
                    var d = f.value;
                    d.moduleExports &&
                      (this.Ct.debug(
                        "Applying instrumentation patch for nodejs module file on instrumentation enabled",
                        {
                          module: a.name,
                          version: a.moduleVersion,
                          fileName: d.name,
                        }
                      ),
                      d.patch(d.moduleExports, a.moduleVersion));
                  }
                } catch (t) {
                  e = { error: t };
                } finally {
                  try {
                    f && !f.done && (r = l.return) && r.call(l);
                  } finally {
                    if (e) throw e.error;
                  }
                }
              }
            } catch (n) {
              t = { error: n };
            } finally {
              try {
                c && !c.done && (n = u.return) && n.call(u);
              } finally {
                if (t) throw t.error;
              }
            }
          else {
            this.pn();
            var h = function (t) {
                var n = function (n, e, r) {
                    return s.En(t, n, e, r);
                  },
                  e = A.isAbsolute(t.name)
                    ? new JR([t.name], { internals: !0 }, n)
                    : p.fn.register(t.name, n);
                p.ln.push(e);
                var r = new uk([t.name], { internals: !1 }, function (n, e, r) {
                  return s.En(t, n, e, r);
                });
                p.ln.push(r);
              },
              p = this;
            try {
              for (var S = Gz(this.hn), E = S.next(); !E.done; E = S.next()) {
                h(E.value);
              }
            } catch (t) {
              o = { error: t };
            } finally {
              try {
                E && !E.done && (i = S.return) && i.call(S);
              } finally {
                if (o) throw o.error;
              }
            }
          }
      }),
      (n.prototype.disable = function () {
        var t, n, e, r;
        if (this.dn) {
          this.dn = !1;
          try {
            for (var o = Gz(this.hn), i = o.next(); !i.done; i = o.next()) {
              var s = i.value;
              "function" == typeof s.unpatch &&
                s.moduleExports &&
                (this.Ct.debug(
                  "Removing instrumentation patch for nodejs module on instrumentation disabled",
                  { module: s.name, version: s.moduleVersion }
                ),
                s.unpatch(s.moduleExports, s.moduleVersion));
              try {
                for (
                  var u = ((e = void 0), Gz(s.files)), c = u.next();
                  !c.done;
                  c = u.next()
                ) {
                  var a = c.value;
                  a.moduleExports &&
                    (this.Ct.debug(
                      "Removing instrumentation patch for nodejs module file on instrumentation disabled",
                      {
                        module: s.name,
                        version: s.moduleVersion,
                        fileName: a.name,
                      }
                    ),
                    a.unpatch(a.moduleExports, s.moduleVersion));
                }
              } catch (t) {
                e = { error: t };
              } finally {
                try {
                  c && !c.done && (r = u.return) && r.call(u);
                } finally {
                  if (e) throw e.error;
                }
              }
            }
          } catch (n) {
            t = { error: n };
          } finally {
            try {
              i && !i.done && (n = o.return) && n.call(o);
            } finally {
              if (t) throw t.error;
            }
          }
        }
      }),
      (n.prototype.isEnabled = function () {
        return this.dn;
      }),
      n
    );
  })(Oz);
function Uz(t, n, e) {
  return void 0 === n
    ? t.includes("*")
    : t.some(function (t) {
        return Qv.satisfies(n, t, { includePrerelease: e });
      });
}
var Wz = function (t, n, e, r, o) {
    (this.name = t),
      (this.supportedVersions = n),
      (this.patch = e),
      (this.unpatch = r),
      (this.files = o || []);
  },
  Yz = function (t, e, r, o) {
    (this.supportedVersions = e),
      (this.patch = r),
      (this.unpatch = o),
      (this.name = n.normalize(t));
  },
  Hz = function (t, n, e, r) {
    return new (e || (e = Promise))(function (o, i) {
      function s(t) {
        try {
          c(r.next(t));
        } catch (t) {
          i(t);
        }
      }
      function u(t) {
        try {
          c(r.throw(t));
        } catch (t) {
          i(t);
        }
      }
      function c(t) {
        var n;
        t.done
          ? o(t.value)
          : ((n = t.value),
            n instanceof e
              ? n
              : new e(function (t) {
                  t(n);
                })).then(s, u);
      }
      c((r = r.apply(t, n || [])).next());
    });
  },
  Dz = function (t, n) {
    var e,
      r,
      o,
      i,
      s = {
        label: 0,
        sent: function () {
          if (1 & o[0]) throw o[1];
          return o[1];
        },
        trys: [],
        ops: [],
      };
    return (
      (i = { next: u(0), throw: u(1), return: u(2) }),
      "function" == typeof Symbol &&
        (i[Symbol.iterator] = function () {
          return this;
        }),
      i
    );
    function u(i) {
      return function (u) {
        return (function (i) {
          if (e) throw new TypeError("Generator is already executing.");
          for (; s; )
            try {
              if (
                ((e = 1),
                r &&
                  (o =
                    2 & i[0]
                      ? r.return
                      : i[0]
                        ? r.throw || ((o = r.return) && o.call(r), 0)
                        : r.next) &&
                  !(o = o.call(r, i[1])).done)
              )
                return o;
              switch (((r = 0), o && (i = [2 & i[0], o.value]), i[0])) {
                case 0:
                case 1:
                  o = i;
                  break;
                case 4:
                  return s.label++, { value: i[1], done: !1 };
                case 5:
                  s.label++, (r = i[1]), (i = [0]);
                  continue;
                case 7:
                  (i = s.ops.pop()), s.trys.pop();
                  continue;
                default:
                  if (
                    !((o = s.trys),
                    (o = o.length > 0 && o[o.length - 1]) ||
                      (6 !== i[0] && 2 !== i[0]))
                  ) {
                    s = 0;
                    continue;
                  }
                  if (3 === i[0] && (!o || (i[1] > o[0] && i[1] < o[3]))) {
                    s.label = i[1];
                    break;
                  }
                  if (6 === i[0] && s.label < o[1]) {
                    (s.label = o[1]), (o = i);
                    break;
                  }
                  if (o && s.label < o[2]) {
                    (s.label = o[2]), s.ops.push(i);
                    break;
                  }
                  o[2] && s.ops.pop(), s.trys.pop();
                  continue;
              }
              i = n.call(t, s);
            } catch (t) {
              (i = [6, t]), (r = 0);
            } finally {
              e = o = 0;
            }
          if (5 & i[0]) throw i[1];
          return { value: i[0] ? i[1] : void 0, done: !0 };
        })([i, u]);
      };
    }
  };
var jz = Object.freeze({
    __proto__: null,
    InstrumentationBase: Xz,
    InstrumentationNodeModuleDefinition: Wz,
    InstrumentationNodeModuleFile: Yz,
    isWrapped: function (t) {
      return (
        "function" == typeof t &&
        "function" == typeof t.__original &&
        "function" == typeof t.__unwrap &&
        !0 === t.__wrapped
      );
    },
    registerInstrumentations: function (t) {
      var n = Rz(t.instrumentations).instrumentations,
        e = t.tracerProvider || Qr.getTracerProvider(),
        r = t.meterProvider || Ur.getMeterProvider(),
        o = t.loggerProvider || yz.getLoggerProvider();
      return (
        (function (t, n, e, r) {
          for (var o = 0, i = t.length; o < i; o++) {
            var s = t[o];
            n && s.setTracerProvider(n),
              e && s.setMeterProvider(e),
              r && s.setLoggerProvider && s.setLoggerProvider(r),
              s.getConfig().enabled || s.enable();
          }
        })(n, e, r, o),
        function () {
          !(function (t) {
            t.forEach(function (t) {
              return t.disable();
            });
          })(n);
        }
      );
    },
    safeExecuteInTheMiddle: function (t, n, e) {
      var r, o;
      try {
        o = t();
      } catch (t) {
        r = t;
      } finally {
        if ((n(r, o), r && !e)) throw r;
        return o;
      }
    },
    safeExecuteInTheMiddleAsync: function (t, n, e) {
      return Hz(this, void 0, void 0, function () {
        var r, o, i;
        return Dz(this, function (s) {
          switch (s.label) {
            case 0:
              return s.trys.push([0, 2, 3, 4]), [4, t()];
            case 1:
              return (o = s.sent()), [3, 4];
            case 2:
              return (i = s.sent()), (r = i), [3, 4];
            case 3:
              if ((n(r, o), r && !e)) throw r;
              return [2, o];
            case 4:
              return [2];
          }
        });
      });
    },
  }),
  xz = Ht(jz),
  kz = {};
Object.defineProperty(kz, "__esModule", { value: !0 }), (kz.endSpan = void 0);
const Kz = no;
kz.endSpan = (t, n) => {
  n &&
    (t.recordException(n),
    t.setStatus({ code: Kz.SpanStatusCode.ERROR, message: n.message })),
    t.end();
};
var Bz = {};
Object.defineProperty(Bz, "__esModule", { value: !0 }),
  (Bz.defaultDbStatementSerializer = void 0);
const Fz = [
  { regex: /^ECHO/i, args: 0 },
  {
    regex: /^(LPUSH|MSET|PFA|PUBLISH|RPUSH|SADD|SET|SPUBLISH|XADD|ZADD)/i,
    args: 1,
  },
  { regex: /^(HSET|HMSET|LSET|LINSERT)/i, args: 2 },
  {
    regex:
      /^(ACL|BIT|B[LRZ]|CLIENT|CLUSTER|CONFIG|COMMAND|DECR|DEL|EVAL|EX|FUNCTION|GEO|GET|HINCR|HMGET|HSCAN|INCR|L[TRLM]|MEMORY|P[EFISTU]|RPOP|S[CDIMORSU]|XACK|X[CDGILPRT]|Z[CDILMPRS])/i,
    args: -1,
  },
];
Bz.defaultDbStatementSerializer = (t, n) => {
  var e, r;
  if (Array.isArray(n) && n.length) {
    const o =
        null !==
          (r =
            null === (e = Fz.find(({ regex: n }) => n.test(t))) || void 0 === e
              ? void 0
              : e.args) && void 0 !== r
          ? r
          : 0,
      i = o >= 0 ? n.slice(0, o) : n;
    return (
      n.length > i.length && i.push(`[${n.length - o} other arguments]`),
      `${t} ${i.join(" ")}`
    );
  }
  return t;
};
var Jz = {};
Object.defineProperty(Jz, "__esModule", { value: !0 }),
  (Jz.VERSION = void 0),
  (Jz.VERSION = "0.40.0"),
  Object.defineProperty(pz, "__esModule", { value: !0 }),
  (pz.IORedisInstrumentation = void 0);
const zz = no,
  Qz = xz,
  $z = KB,
  qz = xz,
  tQ = kz,
  nQ = Bz,
  eQ = Jz,
  rQ = { requireParentSpan: !0 };
class oQ extends Qz.InstrumentationBase {
  constructor(t = {}) {
    super(
      "@opentelemetry/instrumentation-ioredis",
      eQ.VERSION,
      Object.assign({}, rQ, t)
    );
  }
  init() {
    return [
      new Qz.InstrumentationNodeModuleDefinition(
        "ioredis",
        [">1", "<6"],
        (t, n) => {
          const e = "Module" === t[Symbol.toStringTag] ? t.default : t;
          return (
            (0, Qz.isWrapped)(e.prototype.sendCommand) &&
              this.Rt(e.prototype, "sendCommand"),
            this.yt(e.prototype, "sendCommand", this.Zi(n)),
            (0, Qz.isWrapped)(e.prototype.connect) &&
              this.Rt(e.prototype, "connect"),
            this.yt(e.prototype, "connect", this.Pi()),
            t
          );
        },
        (t) => {
          if (void 0 === t) return;
          const n = "Module" === t[Symbol.toStringTag] ? t.default : t;
          this.Rt(n.prototype, "sendCommand"), this.Rt(n.prototype, "connect");
        }
      ),
    ];
  }
  Zi(t) {
    return (n) => this.Vi(n, t);
  }
  Pi() {
    return (t) => this.Gi(t);
  }
  Vi(t, n) {
    const e = this;
    return function (r) {
      if (arguments.length < 1 || "object" != typeof r)
        return t.apply(this, arguments);
      const o = e.getConfig(),
        i =
          (null == o ? void 0 : o.dbStatementSerializer) ||
          nQ.defaultDbStatementSerializer,
        s = void 0 === zz.trace.getSpan(zz.context.active());
      if (!0 === (null == o ? void 0 : o.requireParentSpan) && s)
        return t.apply(this, arguments);
      const u = e.tracer.startSpan(r.name, {
        kind: zz.SpanKind.CLIENT,
        attributes: {
          [$z.SemanticAttributes.DB_SYSTEM]: $z.DbSystemValues.REDIS,
          [$z.SemanticAttributes.DB_STATEMENT]: i(r.name, r.args),
        },
      });
      (null == o ? void 0 : o.requestHook) &&
        (0, qz.safeExecuteInTheMiddle)(
          () =>
            null == o
              ? void 0
              : o.requestHook(u, {
                  moduleVersion: n,
                  cmdName: r.name,
                  cmdArgs: r.args,
                }),
          (t) => {
            t &&
              zz.diag.error("ioredis instrumentation: request hook failed", t);
          },
          !0
        );
      const { host: c, port: a } = this.options;
      u.setAttributes({
        [$z.SemanticAttributes.NET_PEER_NAME]: c,
        [$z.SemanticAttributes.NET_PEER_PORT]: a,
        [$z.SemanticAttributes.DB_CONNECTION_STRING]: `redis://${c}:${a}`,
      });
      try {
        const n = t.apply(this, arguments),
          e = r.resolve;
        r.resolve = function (t) {
          (0, qz.safeExecuteInTheMiddle)(
            () => {
              var n;
              return null === (n = null == o ? void 0 : o.responseHook) ||
                void 0 === n
                ? void 0
                : n.call(o, u, r.name, r.args, t);
            },
            (t) => {
              t &&
                zz.diag.error(
                  "ioredis instrumentation: response hook failed",
                  t
                );
            },
            !0
          ),
            (0, tQ.endSpan)(u, null),
            e(t);
        };
        const i = r.reject;
        return (
          (r.reject = function (t) {
            (0, tQ.endSpan)(u, t), i(t);
          }),
          n
        );
      } catch (t) {
        throw ((0, tQ.endSpan)(u, t), t);
      }
    };
  }
  Gi(t) {
    const n = this;
    return function () {
      const e = n.getConfig(),
        r = void 0 === zz.trace.getSpan(zz.context.active());
      if (!0 === (null == e ? void 0 : e.requireParentSpan) && r)
        return t.apply(this, arguments);
      const o = n.tracer.startSpan("connect", {
          kind: zz.SpanKind.CLIENT,
          attributes: {
            [$z.SemanticAttributes.DB_SYSTEM]: $z.DbSystemValues.REDIS,
            [$z.SemanticAttributes.DB_STATEMENT]: "connect",
          },
        }),
        { host: i, port: s } = this.options;
      o.setAttributes({
        [$z.SemanticAttributes.NET_PEER_NAME]: i,
        [$z.SemanticAttributes.NET_PEER_PORT]: s,
        [$z.SemanticAttributes.DB_CONNECTION_STRING]: `redis://${i}:${s}`,
      });
      try {
        const n = t.apply(this, arguments);
        return (0, tQ.endSpan)(o, null), n;
      } catch (t) {
        throw ((0, tQ.endSpan)(o, t), t);
      }
    };
  }
}
pz.IORedisInstrumentation = oQ;
var iQ = {};
Object.defineProperty(iQ, "__esModule", { value: !0 }),
  (function (t) {
    var n =
        (Wt && Wt.__createBinding) ||
        (Object.create
          ? function (t, n, e, r) {
              void 0 === r && (r = e),
                Object.defineProperty(t, r, {
                  enumerable: !0,
                  get: function () {
                    return n[e];
                  },
                });
            }
          : function (t, n, e, r) {
              void 0 === r && (r = e), (t[r] = n[e]);
            }),
      e =
        (Wt && Wt.__exportStar) ||
        function (t, e) {
          for (var r in t)
            "default" === r ||
              Object.prototype.hasOwnProperty.call(e, r) ||
              n(e, t, r);
        };
    Object.defineProperty(t, "__esModule", { value: !0 }), e(pz, t), e(iQ, t);
  })(hz);
const sQ = (t) => ({
  name: "Redis",
  setupOnce() {
    AK([
      new hz.IORedisInstrumentation({
        responseHook: (n, e, r, o) => {
          const i = r[0];
          if (
            !Fn([t, "optionalAccess", (t) => t.cachePrefixes]) ||
            !(function (t, n, e) {
              return (
                ("get" === t || "set" === t) &&
                "string" == typeof n &&
                (function (t, n) {
                  return n.some((n) => t.startsWith(n));
                })(n, e)
              );
            })(e, i, t.cachePrefixes)
          )
            return;
          const s = Fn([
              hW,
              "call",
              (t) => t(n),
              "access",
              (t) => t.data,
              "optionalAccess",
              (t) => t["net.peer.name"],
            ]),
            u = Fn([
              hW,
              "call",
              (t) => t(n),
              "access",
              (t) => t.data,
              "optionalAccess",
              (t) => t["net.peer.port"],
            ]);
          u &&
            s &&
            n.setAttributes({
              "network.peer.address": s,
              "network.peer.port": u,
            });
          const c = (function (t) {
            try {
              return Buffer.isBuffer(t)
                ? t.byteLength
                : "string" == typeof t
                  ? t.length
                  : "number" == typeof t
                    ? t.toString().length
                    : null == t
                      ? 0
                      : JSON.stringify(t).length;
            } catch (t) {
              return;
            }
          })(o);
          if ((c && n.setAttribute("cache.item_size", c), "string" == typeof i))
            switch (e) {
              case "get":
                n.setAttributes({ [FU]: "cache.get_item", [$U]: i }),
                  void 0 !== c && n.setAttribute("cache.hit", c > 0);
                break;
              case "set":
                n.setAttributes({ [FU]: "cache.put", [$U]: i });
            }
        },
      }),
    ]);
  },
});
var uQ = {},
  cQ = {},
  aQ = {};
Object.defineProperty(aQ, "__esModule", { value: !0 }),
  (aQ.VERSION = void 0),
  (aQ.VERSION = "0.36.0");
var lQ = {},
  fQ = {};
!(function (t) {
  Object.defineProperty(t, "__esModule", { value: !0 }),
    (t.AttributeNames = void 0),
    (function (t) {
      (t.VERSION = "nestjs.version"),
        (t.TYPE = "nestjs.type"),
        (t.MODULE = "nestjs.module"),
        (t.CONTROLLER = "nestjs.controller"),
        (t.CALLBACK = "nestjs.callback"),
        (t.PIPES = "nestjs.pipes"),
        (t.INTERCEPTORS = "nestjs.interceptors"),
        (t.GUARDS = "nestjs.guards");
    })(t.AttributeNames || (t.AttributeNames = {}));
})(fQ);
var dQ = {};
!(function (t) {
  Object.defineProperty(t, "__esModule", { value: !0 }),
    (t.NestType = void 0),
    (function (t) {
      (t.APP_CREATION = "app_creation"),
        (t.REQUEST_CONTEXT = "request_context"),
        (t.REQUEST_HANDLER = "handler");
    })(t.NestType || (t.NestType = {}));
})(dQ),
  (function (t) {
    Object.defineProperty(t, "__esModule", { value: !0 }),
      (t.NestType = t.AttributeNames = void 0);
    var n = fQ;
    Object.defineProperty(t, "AttributeNames", {
      enumerable: !0,
      get: function () {
        return n.AttributeNames;
      },
    });
    var e = dQ;
    Object.defineProperty(t, "NestType", {
      enumerable: !0,
      get: function () {
        return e.NestType;
      },
    });
  })(lQ),
  Object.defineProperty(cQ, "__esModule", { value: !0 }),
  (cQ.Instrumentation = void 0);
const hQ = no,
  pQ = dF,
  SQ = KB,
  EQ = aQ,
  mQ = lQ;
class TQ extends pQ.InstrumentationBase {
  constructor(t = {}) {
    super("@opentelemetry/instrumentation-nestjs-core", EQ.VERSION);
  }
  init() {
    const t = new pQ.InstrumentationNodeModuleDefinition(
      TQ.COMPONENT,
      [">=4.0.0"],
      (t, n) => (this.Ct.debug(`Patching ${TQ.COMPONENT}@${n}`), t),
      (t, n) => {
        this.Ct.debug(`Unpatching ${TQ.COMPONENT}@${n}`);
      }
    );
    return (
      t.files.push(
        this.getNestFactoryFileInstrumentation([">=4.0.0"]),
        this.getRouterExecutionContextFileInstrumentation([">=4.0.0"])
      ),
      t
    );
  }
  getNestFactoryFileInstrumentation(t) {
    return new pQ.InstrumentationNodeModuleFile(
      "@nestjs/core/nest-factory.js",
      t,
      (t, n) => (
        this.ensureWrapped(
          n,
          t.NestFactoryStatic.prototype,
          "create",
          (function (t, n) {
            return function (e) {
              return function (r) {
                const o = t.startSpan("Create Nest App", {
                    attributes: Object.assign(
                      Object.assign({}, TQ.COMMON_ATTRIBUTES),
                      {
                        [mQ.AttributeNames.TYPE]: mQ.NestType.APP_CREATION,
                        [mQ.AttributeNames.VERSION]: n,
                        [mQ.AttributeNames.MODULE]: r.name,
                      }
                    ),
                  }),
                  i = hQ.trace.setSpan(hQ.context.active(), o);
                return hQ.context.with(i, async () => {
                  try {
                    return await e.apply(this, arguments);
                  } catch (t) {
                    throw _Q(o, t);
                  } finally {
                    o.end();
                  }
                });
              };
            };
          })(this.tracer, n)
        ),
        t
      ),
      (t) => {
        this.Rt(t.NestFactoryStatic.prototype, "create");
      }
    );
  }
  getRouterExecutionContextFileInstrumentation(t) {
    return new pQ.InstrumentationNodeModuleFile(
      "@nestjs/core/router/router-execution-context.js",
      t,
      (t, n) => (
        this.ensureWrapped(
          n,
          t.RouterExecutionContext.prototype,
          "create",
          (function (t, n) {
            return function (e) {
              return function (r, o) {
                arguments[1] = (function (t, n, e) {
                  const r = function () {
                    const r = t.startSpan(e.name || "anonymous nest handler", {
                        attributes: Object.assign(
                          Object.assign({}, TQ.COMMON_ATTRIBUTES),
                          {
                            [mQ.AttributeNames.VERSION]: n,
                            [mQ.AttributeNames.TYPE]:
                              mQ.NestType.REQUEST_HANDLER,
                            [mQ.AttributeNames.CALLBACK]: e.name,
                          }
                        ),
                      }),
                      o = hQ.trace.setSpan(hQ.context.active(), r);
                    return hQ.context.with(o, async () => {
                      try {
                        return await e.apply(this, arguments);
                      } catch (t) {
                        throw _Q(r, t);
                      } finally {
                        r.end();
                      }
                    });
                  };
                  e.name && Object.defineProperty(r, "name", { value: e.name });
                  return (
                    Reflect.getMetadataKeys(e).forEach((t) => {
                      Reflect.defineMetadata(t, Reflect.getMetadata(t, e), r);
                    }),
                    r
                  );
                })(t, n, o);
                const i = e.apply(this, arguments);
                return function (e, s, u) {
                  var c, a;
                  const l = o.name,
                    f =
                      r.constructor && r.constructor.name
                        ? r.constructor.name
                        : "UnnamedInstance",
                    d = l ? `${f}.${l}` : f,
                    h = t.startSpan(d, {
                      attributes: Object.assign(
                        Object.assign({}, TQ.COMMON_ATTRIBUTES),
                        {
                          [mQ.AttributeNames.VERSION]: n,
                          [mQ.AttributeNames.TYPE]: mQ.NestType.REQUEST_CONTEXT,
                          [SQ.SemanticAttributes.HTTP_METHOD]: e.method,
                          [SQ.SemanticAttributes.HTTP_URL]:
                            e.originalUrl || e.url,
                          [SQ.SemanticAttributes.HTTP_ROUTE]:
                            (null === (c = e.route) || void 0 === c
                              ? void 0
                              : c.path) ||
                            (null === (a = e.routeOptions) || void 0 === a
                              ? void 0
                              : a.url) ||
                            e.routerPath,
                          [mQ.AttributeNames.CONTROLLER]: f,
                          [mQ.AttributeNames.CALLBACK]: l,
                        }
                      ),
                    }),
                    p = hQ.trace.setSpan(hQ.context.active(), h);
                  return hQ.context.with(p, async () => {
                    try {
                      return await i.apply(this, arguments);
                    } catch (t) {
                      throw _Q(h, t);
                    } finally {
                      h.end();
                    }
                  });
                };
              };
            };
          })(this.tracer, n)
        ),
        t
      ),
      (t) => {
        this.Rt(t.RouterExecutionContext.prototype, "create");
      }
    );
  }
  ensureWrapped(t, n, e, r) {
    this.Ct.debug(`Applying ${e} patch for ${TQ.COMPONENT}@${t}`),
      (0, pQ.isWrapped)(n[e]) && this.Rt(n, e),
      this.yt(n, e, r);
  }
}
(cQ.Instrumentation = TQ),
  (TQ.COMPONENT = "@nestjs/core"),
  (TQ.COMMON_ATTRIBUTES = { component: TQ.COMPONENT });
const _Q = (t, n) => (
  t.recordException(n),
  t.setStatus({ code: hQ.SpanStatusCode.ERROR, message: n.message }),
  n
);
!(function (t) {
  var n =
      (Wt && Wt.__createBinding) ||
      (Object.create
        ? function (t, n, e, r) {
            void 0 === r && (r = e),
              Object.defineProperty(t, r, {
                enumerable: !0,
                get: function () {
                  return n[e];
                },
              });
          }
        : function (t, n, e, r) {
            void 0 === r && (r = e), (t[r] = n[e]);
          }),
    e =
      (Wt && Wt.__exportStar) ||
      function (t, e) {
        for (var r in t)
          "default" === r ||
            Object.prototype.hasOwnProperty.call(e, r) ||
            n(e, t, r);
      };
  Object.defineProperty(t, "__esModule", { value: !0 }),
    (t.NestInstrumentation = void 0);
  const r = cQ;
  Object.defineProperty(t, "NestInstrumentation", {
    enumerable: !0,
    get: function () {
      return r.Instrumentation;
    },
  }),
    e(cQ, t),
    e(fQ, t);
})(uQ);
const bQ = () => ({
  name: "Nest",
  setupOnce() {
    AK(new uQ.NestInstrumentation({}));
  },
});
var vQ = {},
  yQ = {},
  RQ = {},
  AQ = {};
!(function (t) {
  Object.defineProperty(t, "__esModule", { value: !0 }),
    (t.AttributeNames = void 0),
    (function (t) {
      (t.PG_VALUES = "db.postgresql.values"),
        (t.PG_PLAN = "db.postgresql.plan"),
        (t.IDLE_TIMEOUT_MILLIS = "db.postgresql.idle.timeout.millis"),
        (t.MAX_CLIENT = "db.postgresql.max.client");
    })(t.AttributeNames || (t.AttributeNames = {}));
})(AQ);
var OQ = {};
!(function (t) {
  Object.defineProperty(t, "__esModule", { value: !0 }),
    (t.SpanNames = void 0),
    (function (t) {
      (t.QUERY_PREFIX = "pg.query"),
        (t.CONNECT = "pg.connect"),
        (t.POOL_CONNECT = "pg-pool.connect");
    })(t.SpanNames || (t.SpanNames = {}));
})(OQ),
  Object.defineProperty(RQ, "__esModule", { value: !0 }),
  (RQ.isObjectWithTextString =
    RQ.getErrorMessage =
    RQ.patchClientConnectCallback =
    RQ.patchCallbackPGPool =
    RQ.patchCallback =
    RQ.handleExecutionResult =
    RQ.handleConfigQuery =
    RQ.shouldSkipInstrumentation =
    RQ.getSemanticAttributesFromPool =
    RQ.getSemanticAttributesFromConnection =
    RQ.getConnectionString =
    RQ.getQuerySpanName =
      void 0);
const gQ = no,
  NQ = AQ,
  CQ = KB,
  LQ = dF,
  IQ = OQ;
function MQ(t, n) {
  if (!n) return IQ.SpanNames.QUERY_PREFIX;
  const e =
    "string" == typeof n.name && n.name
      ? n.name
      : (function (t) {
          const n = t.split(" ")[0].toUpperCase();
          return n.endsWith(";") ? n.slice(0, -1) : n;
        })(n.text);
  return `${IQ.SpanNames.QUERY_PREFIX}:${e}${t ? ` ${t}` : ""}`;
}
function wQ(t) {
  return `postgresql://${t.host || "localhost"}:${t.port || 5432}/${
    t.database || ""
  }`;
}
function ZQ(t) {
  if (Number.isInteger(t)) return t;
}
function PQ(t) {
  return {
    [CQ.SEMATTRS_DB_SYSTEM]: CQ.DBSYSTEMVALUES_POSTGRESQL,
    [CQ.SEMATTRS_DB_NAME]: t.database,
    [CQ.SEMATTRS_DB_CONNECTION_STRING]: wQ(t),
    [CQ.SEMATTRS_NET_PEER_NAME]: t.host,
    [CQ.SEMATTRS_NET_PEER_PORT]: ZQ(t.port),
    [CQ.SEMATTRS_DB_USER]: t.user,
  };
}
function VQ(t, n, e) {
  "function" == typeof t.responseHook &&
    (0, LQ.safeExecuteInTheMiddle)(
      () => {
        t.responseHook(n, { data: e });
      },
      (t) => {
        t && gQ.diag.error("Error running response hook", t);
      },
      !0
    );
}
(RQ.getQuerySpanName = MQ),
  (RQ.getConnectionString = wQ),
  (RQ.getSemanticAttributesFromConnection = PQ),
  (RQ.getSemanticAttributesFromPool = function (t) {
    return {
      [CQ.SEMATTRS_DB_SYSTEM]: CQ.DBSYSTEMVALUES_POSTGRESQL,
      [CQ.SEMATTRS_DB_NAME]: t.database,
      [CQ.SEMATTRS_DB_CONNECTION_STRING]: wQ(t),
      [CQ.SEMATTRS_NET_PEER_NAME]: t.host,
      [CQ.SEMATTRS_NET_PEER_PORT]: ZQ(t.port),
      [CQ.SEMATTRS_DB_USER]: t.user,
      [NQ.AttributeNames.IDLE_TIMEOUT_MILLIS]: t.idleTimeoutMillis,
      [NQ.AttributeNames.MAX_CLIENT]: t.maxClient,
    };
  }),
  (RQ.shouldSkipInstrumentation = function (t) {
    return (
      !0 === t.requireParentSpan &&
      void 0 === gQ.trace.getSpan(gQ.context.active())
    );
  }),
  (RQ.handleConfigQuery = function (t, n, e) {
    const { connectionParameters: r } = this,
      o = MQ(r.database, e),
      i = t.startSpan(o, { kind: gQ.SpanKind.CLIENT, attributes: PQ(r) });
    if (!e) return i;
    if (
      (e.text && i.setAttribute(CQ.SEMATTRS_DB_STATEMENT, e.text),
      n.enhancedDatabaseReporting && Array.isArray(e.values))
    )
      try {
        const t = e.values.map((t) =>
          null == t
            ? "null"
            : t instanceof Buffer
              ? t.toString()
              : "object" == typeof t
                ? "function" == typeof t.toPostgres
                  ? t.toPostgres()
                  : JSON.stringify(t)
                : t.toString()
        );
        i.setAttribute(NQ.AttributeNames.PG_VALUES, t);
      } catch (t) {
        gQ.diag.error("failed to stringify ", e.values, t);
      }
    return (
      "string" == typeof e.name &&
        i.setAttribute(NQ.AttributeNames.PG_PLAN, e.name),
      i
    );
  }),
  (RQ.handleExecutionResult = VQ),
  (RQ.patchCallback = function (t, n, e) {
    return function (r, o) {
      r
        ? n.setStatus({ code: gQ.SpanStatusCode.ERROR, message: r.message })
        : VQ(t, n, o),
        n.end(),
        e.call(this, r, o);
    };
  }),
  (RQ.patchCallbackPGPool = function (t, n) {
    return function (e, r, o) {
      e && t.setStatus({ code: gQ.SpanStatusCode.ERROR, message: e.message }),
        t.end(),
        n.call(this, e, r, o);
    };
  }),
  (RQ.patchClientConnectCallback = function (t, n) {
    return function (e) {
      e && t.setStatus({ code: gQ.SpanStatusCode.ERROR, message: e.message }),
        t.end(),
        n.apply(this, arguments);
    };
  }),
  (RQ.getErrorMessage = function (t) {
    return "object" == typeof t && null !== t && "message" in t
      ? String(t.message)
      : void 0;
  }),
  (RQ.isObjectWithTextString = function (t) {
    var n;
    return (
      "object" == typeof t &&
      "string" == typeof (null === (n = t) || void 0 === n ? void 0 : n.text)
    );
  });
var GQ = {};
Object.defineProperty(GQ, "__esModule", { value: !0 }),
  (GQ.VERSION = void 0),
  (GQ.VERSION = "0.40.0"),
  Object.defineProperty(yQ, "__esModule", { value: !0 }),
  (yQ.PgInstrumentation = void 0);
const XQ = dF,
  UQ = no,
  WQ = RQ,
  YQ = QJ,
  HQ = GQ,
  DQ = OQ;
class jQ extends XQ.InstrumentationBase {
  constructor(t = {}) {
    super(
      "@opentelemetry/instrumentation-pg",
      HQ.VERSION,
      Object.assign({}, t)
    );
  }
  init() {
    return [
      new XQ.InstrumentationNodeModuleDefinition(
        "pg",
        ["8.*"],
        (t, n) => {
          this.Ct.debug(`Applying patch for pg@${n}`);
          const e = "Module" === t[Symbol.toStringTag] ? t.default : t;
          return (
            (0, XQ.isWrapped)(e.Client.prototype.query) &&
              this.Rt(e.Client.prototype, "query"),
            (0, XQ.isWrapped)(e.Client.prototype.connect) &&
              this.Rt(e.Client.prototype, "connect"),
            this.yt(e.Client.prototype, "query", this.Xi()),
            this.yt(e.Client.prototype, "connect", this.Ui()),
            t
          );
        },
        (t, n) => {
          const e = "Module" === t[Symbol.toStringTag] ? t.default : t;
          this.Ct.debug(`Removing patch for pg@${n}`),
            (0, XQ.isWrapped)(e.Client.prototype.query) &&
              this.Rt(e.Client.prototype, "query");
        }
      ),
      new XQ.InstrumentationNodeModuleDefinition(
        "pg-pool",
        ["2.*", "3.*"],
        (t, n) => (
          this.Ct.debug(`Applying patch for pg-pool@${n}`),
          (0, XQ.isWrapped)(t.prototype.connect) &&
            this.Rt(t.prototype, "connect"),
          this.yt(t.prototype, "connect", this.Wi()),
          t
        ),
        (t, n) => {
          this.Ct.debug(`Removing patch for pg-pool@${n}`),
            (0, XQ.isWrapped)(t.prototype.connect) &&
              this.Rt(t.prototype, "connect");
        }
      ),
    ];
  }
  setConfig(t = {}) {
    this.Nt = Object.assign({}, t);
  }
  getConfig() {
    return this.Nt;
  }
  Ui() {
    const t = this;
    return (n) =>
      function (e) {
        if (WQ.shouldSkipInstrumentation(t.getConfig())) return n.call(this, e);
        const r = t.tracer.startSpan(DQ.SpanNames.CONNECT, {
          kind: UQ.SpanKind.CLIENT,
          attributes: WQ.getSemanticAttributesFromConnection(this),
        });
        if (e) {
          const t = UQ.trace.getSpan(UQ.context.active());
          (e = WQ.patchClientConnectCallback(r, e)),
            t && (e = UQ.context.bind(UQ.context.active(), e));
        }
        return xQ(
          r,
          UQ.context.with(UQ.trace.setSpan(UQ.context.active(), r), () =>
            n.call(this, e)
          )
        );
      };
  }
  Xi() {
    const t = this;
    return (n) => (
      this.Ct.debug("Patching pg.Client.prototype.query"),
      function (...e) {
        if (WQ.shouldSkipInstrumentation(t.getConfig()))
          return n.apply(this, e);
        const r = e[0],
          o = "string" == typeof r,
          i = WQ.isObjectWithTextString(r),
          s = o
            ? { text: r, values: Array.isArray(e[1]) ? e[1] : void 0 }
            : i
              ? r
              : void 0,
          u = t.getConfig(),
          c = WQ.handleConfigQuery.call(this, t.tracer, u, s);
        if (
          (u.addSqlCommenterCommentToQueries &&
            (e[0] = o
              ? (0, YQ.addSqlCommenterComment)(c, r)
              : i
                ? Object.assign(Object.assign({}, r), {
                    text: (0, YQ.addSqlCommenterComment)(c, r.text),
                  })
                : e[0]),
          e.length > 0)
        ) {
          const n = UQ.trace.getSpan(UQ.context.active());
          if ("function" == typeof e[e.length - 1])
            (e[e.length - 1] = WQ.patchCallback(u, c, e[e.length - 1])),
              n &&
                (e[e.length - 1] = UQ.context.bind(
                  UQ.context.active(),
                  e[e.length - 1]
                ));
          else if ("function" == typeof (null == s ? void 0 : s.callback)) {
            let r = WQ.patchCallback(t.getConfig(), c, s.callback);
            n && (r = UQ.context.bind(UQ.context.active(), r)),
              (e[0].callback = r);
          }
        }
        let a;
        "function" == typeof u.requestHook &&
          s &&
          (0, XQ.safeExecuteInTheMiddle)(
            () => {
              const {
                  database: t,
                  host: n,
                  port: e,
                  user: r,
                } = this.connectionParameters,
                o = { database: t, host: n, port: e, user: r };
              u.requestHook(c, {
                connection: o,
                query: { text: s.text, values: s.values, name: s.name },
              });
            },
            (n) => {
              n && t.Ct.error("Error running query hook", n);
            },
            !0
          );
        try {
          a = n.apply(this, e);
        } catch (t) {
          throw (
            (c.setStatus({
              code: UQ.SpanStatusCode.ERROR,
              message: WQ.getErrorMessage(t),
            }),
            c.end(),
            t)
          );
        }
        return a instanceof Promise
          ? a
              .then(
                (n) =>
                  new Promise((e) => {
                    WQ.handleExecutionResult(t.getConfig(), c, n),
                      c.end(),
                      e(n);
                  })
              )
              .catch(
                (t) =>
                  new Promise((n, e) => {
                    c.setStatus({
                      code: UQ.SpanStatusCode.ERROR,
                      message: t.message,
                    }),
                      c.end(),
                      e(t);
                  })
              )
          : a;
      }
    );
  }
  Wi() {
    const t = this;
    return (n) =>
      function (e) {
        if (WQ.shouldSkipInstrumentation(t.getConfig())) return n.call(this, e);
        const r = t.tracer.startSpan(DQ.SpanNames.POOL_CONNECT, {
          kind: UQ.SpanKind.CLIENT,
          attributes: WQ.getSemanticAttributesFromPool(this.options),
        });
        if (e) {
          const t = UQ.trace.getSpan(UQ.context.active());
          (e = WQ.patchCallbackPGPool(r, e)),
            t && (e = UQ.context.bind(UQ.context.active(), e));
        }
        return xQ(
          r,
          UQ.context.with(UQ.trace.setSpan(UQ.context.active(), r), () =>
            n.call(this, e)
          )
        );
      };
  }
}
function xQ(t, n) {
  if (!(n instanceof Promise)) return n;
  const e = n;
  return UQ.context.bind(
    UQ.context.active(),
    e
      .then((n) => (t.end(), n))
      .catch(
        (n) => (
          t.setStatus({
            code: UQ.SpanStatusCode.ERROR,
            message: WQ.getErrorMessage(n),
          }),
          t.end(),
          Promise.reject(n)
        )
      )
  );
}
yQ.PgInstrumentation = jQ;
var kQ = {};
Object.defineProperty(kQ, "__esModule", { value: !0 }),
  (function (t) {
    var n =
        (Wt && Wt.__createBinding) ||
        (Object.create
          ? function (t, n, e, r) {
              void 0 === r && (r = e),
                Object.defineProperty(t, r, {
                  enumerable: !0,
                  get: function () {
                    return n[e];
                  },
                });
            }
          : function (t, n, e, r) {
              void 0 === r && (r = e), (t[r] = n[e]);
            }),
      e =
        (Wt && Wt.__exportStar) ||
        function (t, e) {
          for (var r in t)
            "default" === r ||
              Object.prototype.hasOwnProperty.call(e, r) ||
              n(e, t, r);
        };
    Object.defineProperty(t, "__esModule", { value: !0 }),
      e(yQ, t),
      e(kQ, t),
      e(AQ, t);
  })(vQ);
const KQ = () => ({
  name: "Postgres",
  setupOnce() {
    AK(
      new vQ.PgInstrumentation({
        requireParentSpan: !0,
        requestHook(t) {
          OK(t, "auto.db.otel.postgres");
        },
      })
    );
  },
});
var BQ = Ht(Tx);
function FQ(t, n) {
  return null != t ? t : n();
}
var JQ = Object.defineProperty,
  zQ = Object.getOwnPropertyDescriptor,
  QQ = Object.getOwnPropertyNames,
  $Q = Object.prototype.hasOwnProperty,
  qQ = {};
((t, n) => {
  for (var e in n) JQ(t, e, { get: n[e], enumerable: !0 });
})(qQ, { ActiveTracingHelper: () => o$ });
var t$ = ((t) =>
    ((t, n, e, r) => {
      if ((n && "object" == typeof n) || "function" == typeof n)
        for (let o of QQ(n))
          $Q.call(t, o) ||
            o === e ||
            JQ(t, o, {
              get: () => n[o],
              enumerable: !(r = zQ(n, o)) || r.enumerable,
            });
      return t;
    })(JQ({}, "__esModule", { value: !0 }), t))(qQ),
  n$ = no,
  e$ = BQ,
  r$ = "true" === process.env.PRISMA_SHOW_ALL_TRACES,
  o$ = class {
    constructor({ traceMiddleware: t }) {
      this.traceMiddleware = t;
    }
    isEnabled() {
      return !0;
    }
    getTraceParent(t) {
      const n = n$.trace.getSpanContext(FQ(t, () => n$.context.active()));
      return n ? `00-${n.traceId}-${n.spanId}-0${n.traceFlags}` : "00-10-10-00";
    }
    createEngineSpan(t) {
      const n = n$.trace.getTracer("prisma");
      t.spans.forEach((t) => {
        const e = {
            traceId: t.trace_id,
            spanId: t.span_id,
            traceFlags: n$.TraceFlags.SAMPLED,
          },
          r = (function (t) {
            let n,
              e = t[0],
              r = 1;
            for (; r < t.length; ) {
              const o = t[r],
                i = t[r + 1];
              if (
                ((r += 2),
                ("optionalAccess" === o || "optionalCall" === o) && null == e)
              )
                return;
              "access" === o || "optionalAccess" === o
                ? ((n = e), (e = i(e)))
                : ("call" !== o && "optionalCall" !== o) ||
                  ((e = i((...t) => e.call(n, ...t))), (n = void 0));
            }
            return e;
          })([
            t,
            "access",
            (t) => t.links,
            "optionalAccess",
            (t) => t.map,
            "call",
            (t) =>
              t((t) => ({
                context: {
                  traceId: t.trace_id,
                  spanId: t.span_id,
                  traceFlags: n$.TraceFlags.SAMPLED,
                },
              })),
          ]),
          o = new e$.Span(
            n,
            n$.ROOT_CONTEXT,
            t.name,
            e,
            n$.SpanKind.INTERNAL,
            t.parent_span_id,
            r,
            t.start_time
          );
        t.attributes && o.setAttributes(t.attributes), o.end(t.end_time);
      });
    }
    getActiveContext() {
      return n$.context.active();
    }
    runInChildSpan(t, n) {
      if (("string" == typeof t && (t = { name: t }), t.internal && !r$))
        return n();
      if (t.middleware && !this.traceMiddleware) return n();
      const e = n$.trace.getTracer("prisma"),
        r = FQ(t.context, () => this.getActiveContext()),
        o = `prisma:client:${t.name}`;
      if (!1 === t.active) {
        const i = e.startSpan(o, t, r);
        return i$(i, n(i, r));
      }
      return e.startActiveSpan(o, t, (t) => i$(t, n(t, r)));
    }
  };
function i$(t, n) {
  return null != (e = n) && "function" == typeof e.then
    ? n.then(
        (n) => (t.end(), n),
        (n) => {
          throw (t.end(), n);
        }
      )
    : (t.end(), n);
  var e;
}
var s$ = Object.defineProperty,
  u$ = Object.getOwnPropertyDescriptor,
  c$ = Object.getOwnPropertyNames,
  a$ = Object.prototype.hasOwnProperty,
  l$ = {};
((t, n) => {
  for (var e in n) s$(t, e, { get: n[e], enumerable: !0 });
})(l$, { __commonJS: () => h$ });
var f$ = ((t) =>
    ((t, n, e, r) => {
      if ((n && "object" == typeof n) || "function" == typeof n)
        for (let o of c$(n))
          a$.call(t, o) ||
            o === e ||
            s$(t, o, {
              get: () => n[o],
              enumerable: !(r = u$(n, o)) || r.enumerable,
            });
      return t;
    })(s$({}, "__esModule", { value: !0 }), t))(l$),
  d$ = Object.getOwnPropertyNames,
  h$ = (t, n) =>
    function () {
      return n || (0, t[d$(t)[0]])((n = { exports: {} }).exports, n), n.exports;
    },
  p$ = Object.defineProperty,
  S$ = Object.getOwnPropertyDescriptor,
  E$ = Object.getOwnPropertyNames,
  m$ = Object.prototype.hasOwnProperty,
  T$ = {};
((t, n) => {
  for (var e in n) p$(t, e, { get: n[e], enumerable: !0 });
})(T$, {
  GLOBAL_KEY: () => R$,
  MODULE_NAME: () => g$,
  NAME: () => O$,
  VERSION: () => A$,
});
var _$ = ((t) =>
    ((t, n, e, r) => {
      if ((n && "object" == typeof n) || "function" == typeof n)
        for (let o of E$(n))
          m$.call(t, o) ||
            o === e ||
            p$(t, o, {
              get: () => n[o],
              enumerable: !(r = S$(n, o)) || r.enumerable,
            });
      return t;
    })(p$({}, "__esModule", { value: !0 }), t))(T$),
  b$ = (0, f$.__commonJS)({
    "package.json"(t, n) {
      n.exports = {
        name: "@prisma/instrumentation",
        version: "5.13.0",
        description:
          "OpenTelemetry compliant instrumentation for Prisma Client",
        main: "dist/index.js",
        types: "dist/index.d.ts",
        license: "Apache-2.0",
        homepage: "https://www.prisma.io",
        repository: {
          type: "git",
          url: "https://github.com/prisma/prisma.git",
          directory: "packages/instrumentation",
        },
        bugs: "https://github.com/prisma/prisma/issues",
        devDependencies: {
          "@prisma/internals": "workspace:*",
          "@swc/core": "1.4.11",
          "@types/jest": "29.5.12",
          "@types/node": "18.19.31",
          jest: "29.7.0",
          "jest-junit": "16.0.0",
          typescript: "5.3.3",
        },
        dependencies: {
          "@opentelemetry/api": "1.8.0",
          "@opentelemetry/instrumentation": "0.50.0",
          "@opentelemetry/sdk-trace-base": "1.23.0",
        },
        files: ["dist"],
        keywords: ["prisma", "instrumentation", "opentelemetry", "otel"],
        scripts: {
          dev: "DEV=true tsx helpers/build.ts",
          build: "tsx helpers/build.ts",
          prepublishOnly: "pnpm run build",
          test: "jest",
        },
        sideEffects: !1,
      };
    },
  }),
  { version: v$, name: y$ } = b$(),
  R$ = "PRISMA_INSTRUMENTATION",
  A$ = v$,
  O$ = y$,
  g$ = "prisma";
var N$ = Object.defineProperty,
  C$ = Object.getOwnPropertyDescriptor,
  L$ = Object.getOwnPropertyNames,
  I$ = Object.prototype.hasOwnProperty,
  M$ = {};
((t, n) => {
  for (var e in n) N$(t, e, { get: n[e], enumerable: !0 });
})(M$, { PrismaInstrumentation: () => G$ });
var w$ = ((t) =>
    ((t, n, e, r) => {
      if ((n && "object" == typeof n) || "function" == typeof n)
        for (let o of L$(n))
          I$.call(t, o) ||
            o === e ||
            N$(t, o, {
              get: () => n[o],
              enumerable: !(r = C$(n, o)) || r.enumerable,
            });
      return t;
    })(N$({}, "__esModule", { value: !0 }), t))(M$),
  Z$ = t$,
  P$ = _$,
  V$ = dF,
  G$ = class extends V$.InstrumentationBase {
    constructor(t = {}) {
      super(P$.NAME, P$.VERSION, t);
    }
    init() {
      return [
        new V$.InstrumentationNodeModuleDefinition(P$.MODULE_NAME, [
          P$.VERSION,
        ]),
      ];
    }
    enable() {
      const t = this.Nt,
        n = {
          helper: new Z$.ActiveTracingHelper({
            traceMiddleware:
              ((e = t.middleware), (r = () => !1), null != e ? e : r()),
          }),
        };
      var e, r;
      Wt[P$.GLOBAL_KEY] = n;
    }
    disable() {
      delete Wt[P$.GLOBAL_KEY];
    }
    isEnabled() {
      return Boolean(Wt[P$.GLOBAL_KEY]);
    }
  },
  X$ = Object.defineProperty,
  U$ = Object.getOwnPropertyDescriptor,
  W$ = Object.getOwnPropertyNames,
  Y$ = Object.prototype.hasOwnProperty,
  H$ = {};
((t, n) => {
  for (var e in n) X$(t, e, { get: n[e], enumerable: !0 });
})(H$, { PrismaInstrumentation: () => j$.PrismaInstrumentation });
var D$ = ((t) =>
    ((t, n, e, r) => {
      if ((n && "object" == typeof n) || "function" == typeof n)
        for (let o of W$(n))
          Y$.call(t, o) ||
            o === e ||
            X$(t, o, {
              get: () => n[o],
              enumerable: !(r = U$(n, o)) || r.enumerable,
            });
      return t;
    })(X$({}, "__esModule", { value: !0 }), t))(H$),
  j$ = w$;
const x$ = () => ({
  name: "Prisma",
  setupOnce() {
    AK(new D$.PrismaInstrumentation({}));
  },
  setup(t) {
    t.on("spanStart", (t) => {
      const n = hW(t);
      Fn([
        n,
        "access",
        (t) => t.description,
        "optionalAccess",
        (t) => t.startsWith,
        "call",
        (t) => t("prisma:"),
      ]) && t.setAttribute(JU, "auto.db.otel.prisma"),
        "prisma:engine:db_query" === n.description &&
          t.setAttribute("db.system", "prisma");
    });
  },
});
var k$ = {},
  K$ = {},
  B$ = (function () {
    function t() {}
    return (t.prototype.emit = function (t) {}), t;
  })(),
  F$ = new ((function () {
    function t() {}
    return (
      (t.prototype.getLogger = function (t, n, e) {
        return new B$();
      }),
      t
    );
  })())(),
  J$ = "object" == typeof globalThis ? globalThis : global,
  z$ = Symbol.for("io.opentelemetry.js.api.logs"),
  Q$ = J$;
var $$ = (function () {
    function t() {}
    return (
      (t.getInstance = function () {
        return this.L || (this.L = new t()), this.L;
      }),
      (t.prototype.setGlobalLoggerProvider = function (t) {
        return Q$[z$]
          ? this.getLoggerProvider()
          : ((Q$[z$] =
              ((n = 1),
              (e = t),
              (r = F$),
              function (t) {
                return t === n ? e : r;
              })),
            t);
        var n, e, r;
      }),
      (t.prototype.getLoggerProvider = function () {
        var t, n;
        return null !==
          (n =
            null === (t = Q$[z$]) || void 0 === t ? void 0 : t.call(Q$, 1)) &&
          void 0 !== n
          ? n
          : F$;
      }),
      (t.prototype.getLogger = function (t, n, e) {
        return this.getLoggerProvider().getLogger(t, n, e);
      }),
      (t.prototype.disable = function () {
        delete Q$[z$];
      }),
      t
    );
  })(),
  q$ = $$.getInstance();
function tq(t) {
  void 0 === t && (t = []);
  for (var n = [], e = 0, r = t.length; e < r; e++) {
    var o = t[e];
    if (Array.isArray(o)) {
      var i = tq(o);
      n = n.concat(i.instrumentations);
    } else
      "function" == typeof o
        ? n.push(new o())
        : o.instrumentationName && n.push(o);
  }
  return { instrumentations: n };
}
var nq = function () {
    return (
      (nq =
        Object.assign ||
        function (t) {
          for (var n, e = 1, r = arguments.length; e < r; e++)
            for (var o in (n = arguments[e]))
              Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
          return t;
        }),
      nq.apply(this, arguments)
    );
  },
  eq = (function () {
    function t(t, n, e) {
      void 0 === e && (e = {}),
        (this.instrumentationName = t),
        (this.instrumentationVersion = n),
        (this.yt = Ty.wrap),
        (this.Rt = Ty.unwrap),
        (this.At = Ty.massWrap),
        (this.Ot = Ty.massUnwrap),
        (this.Nt = nq({ enabled: !0 }, e)),
        (this.Ct = Pr.createComponentLogger({ namespace: t })),
        (this.Lt = Qr.getTracer(t, n)),
        (this.It = Ur.getMeter(t, n)),
        (this.Mt = q$.getLogger(t, n)),
        this.wt();
    }
    return (
      Object.defineProperty(t.prototype, "meter", {
        get: function () {
          return this.It;
        },
        enumerable: !1,
        configurable: !0,
      }),
      (t.prototype.setMeterProvider = function (t) {
        (this.It = t.getMeter(
          this.instrumentationName,
          this.instrumentationVersion
        )),
          this.wt();
      }),
      Object.defineProperty(t.prototype, "logger", {
        get: function () {
          return this.Mt;
        },
        enumerable: !1,
        configurable: !0,
      }),
      (t.prototype.setLoggerProvider = function (t) {
        this.Mt = t.getLogger(
          this.instrumentationName,
          this.instrumentationVersion
        );
      }),
      (t.prototype.getModuleDefinitions = function () {
        var t,
          n = null !== (t = this.init()) && void 0 !== t ? t : [];
        return Array.isArray(n) ? n : [n];
      }),
      (t.prototype.wt = function () {}),
      (t.prototype.getConfig = function () {
        return this.Nt;
      }),
      (t.prototype.setConfig = function (t) {
        void 0 === t && (t = {}), (this.Nt = Object.assign({}, t));
      }),
      (t.prototype.setTracerProvider = function (t) {
        this.Lt = t.getTracer(
          this.instrumentationName,
          this.instrumentationVersion
        );
      }),
      Object.defineProperty(t.prototype, "tracer", {
        get: function () {
          return this.Lt;
        },
        enumerable: !1,
        configurable: !0,
      }),
      t
    );
  })(),
  rq = function (t) {
    var n = "function" == typeof Symbol && Symbol.iterator,
      e = n && t[n],
      r = 0;
    if (e) return e.call(t);
    if (t && "number" == typeof t.length)
      return {
        next: function () {
          return (
            t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t }
          );
        },
      };
    throw new TypeError(
      n ? "Object is not iterable." : "Symbol.iterator is not defined."
    );
  },
  oq = function (t, n) {
    var e = "function" == typeof Symbol && t[Symbol.iterator];
    if (!e) return t;
    var r,
      o,
      i = e.call(t),
      s = [];
    try {
      for (; (void 0 === n || n-- > 0) && !(r = i.next()).done; )
        s.push(r.value);
    } catch (t) {
      o = { error: t };
    } finally {
      try {
        r && !r.done && (e = i.return) && e.call(i);
      } finally {
        if (o) throw o.error;
      }
    }
    return s;
  },
  iq = function (t, n, e) {
    if (e || 2 === arguments.length)
      for (var r, o = 0, i = n.length; o < i; o++)
        (!r && o in n) ||
          (r || (r = Array.prototype.slice.call(n, 0, o)), (r[o] = n[o]));
    return t.concat(r || Array.prototype.slice.call(n));
  },
  sq = "/",
  uq = function () {
    (this.hooks = []), (this.children = new Map());
  },
  cq = (function () {
    function t() {
      (this.rn = new uq()), (this.sn = 0);
    }
    return (
      (t.prototype.insert = function (t) {
        var n,
          e,
          r = this.rn;
        try {
          for (
            var o = rq(t.moduleName.split(sq)), i = o.next();
            !i.done;
            i = o.next()
          ) {
            var s = i.value,
              u = r.children.get(s);
            u || ((u = new uq()), r.children.set(s, u)), (r = u);
          }
        } catch (t) {
          n = { error: t };
        } finally {
          try {
            i && !i.done && (e = o.return) && e.call(o);
          } finally {
            if (n) throw n.error;
          }
        }
        r.hooks.push({ hook: t, insertedId: this.sn++ });
      }),
      (t.prototype.search = function (t, n) {
        var e,
          r,
          o = void 0 === n ? {} : n,
          i = o.maintainInsertionOrder,
          s = o.fullOnly,
          u = this.rn,
          c = [],
          a = !0;
        try {
          for (var l = rq(t.split(sq)), f = l.next(); !f.done; f = l.next()) {
            var d = f.value,
              h = u.children.get(d);
            if (!h) {
              a = !1;
              break;
            }
            s || c.push.apply(c, iq([], oq(h.hooks), !1)), (u = h);
          }
        } catch (t) {
          e = { error: t };
        } finally {
          try {
            f && !f.done && (r = l.return) && r.call(l);
          } finally {
            if (e) throw e.error;
          }
        }
        return (
          s && a && c.push.apply(c, iq([], oq(u.hooks), !1)),
          0 === c.length
            ? []
            : 1 === c.length
              ? [c[0].hook]
              : (i &&
                  c.sort(function (t, n) {
                    return t.insertedId - n.insertedId;
                  }),
                c.map(function (t) {
                  return t.hook;
                }))
        );
      }),
      t
    );
  })(),
  aq = function (t) {
    var n = "function" == typeof Symbol && Symbol.iterator,
      e = n && t[n],
      r = 0;
    if (e) return e.call(t);
    if (t && "number" == typeof t.length)
      return {
        next: function () {
          return (
            t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t }
          );
        },
      };
    throw new TypeError(
      n ? "Object is not iterable." : "Symbol.iterator is not defined."
    );
  },
  lq = ["afterEach", "after", "beforeEach", "before", "describe", "it"].every(
    function (t) {
      return "function" == typeof global[t];
    }
  ),
  fq = (function () {
    function t() {
      (this.un = new cq()), this.cn();
    }
    return (
      (t.prototype.cn = function () {
        var t = this;
        new JR(null, { internals: !0 }, function (n, e, r) {
          var o,
            i,
            s,
            u = ((s = e), A.sep !== sq ? s.split(A.sep).join(sq) : s),
            c = t.un.search(u, {
              maintainInsertionOrder: !0,
              fullOnly: void 0 === r,
            });
          try {
            for (var a = aq(c), l = a.next(); !l.done; l = a.next()) {
              n = (0, l.value.onRequire)(n, e, r);
            }
          } catch (t) {
            o = { error: t };
          } finally {
            try {
              l && !l.done && (i = a.return) && i.call(a);
            } finally {
              if (o) throw o.error;
            }
          }
          return n;
        });
      }),
      (t.prototype.register = function (t, n) {
        var e = { moduleName: t, onRequire: n };
        return this.un.insert(e), e;
      }),
      (t.getInstance = function () {
        var n;
        return lq
          ? new t()
          : (this.L = null !== (n = this.L) && void 0 !== n ? n : new t());
      }),
      t
    );
  })();
var dq = (function () {
    var t = function (n, e) {
      return (
        (t =
          Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array &&
            function (t, n) {
              t.__proto__ = n;
            }) ||
          function (t, n) {
            for (var e in n)
              Object.prototype.hasOwnProperty.call(n, e) && (t[e] = n[e]);
          }),
        t(n, e)
      );
    };
    return function (n, e) {
      if ("function" != typeof e && null !== e)
        throw new TypeError(
          "Class extends value " + String(e) + " is not a constructor or null"
        );
      function r() {
        this.constructor = n;
      }
      t(n, e),
        (n.prototype =
          null === e
            ? Object.create(e)
            : ((r.prototype = e.prototype), new r()));
    };
  })(),
  hq = function (t) {
    var n = "function" == typeof Symbol && Symbol.iterator,
      e = n && t[n],
      r = 0;
    if (e) return e.call(t);
    if (t && "number" == typeof t.length)
      return {
        next: function () {
          return (
            t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t }
          );
        },
      };
    throw new TypeError(
      n ? "Object is not iterable." : "Symbol.iterator is not defined."
    );
  },
  pq = (function (t) {
    function n(n, r, o) {
      void 0 === o && (o = {});
      var i = t.call(this, n, r, o) || this;
      (i.ln = []),
        (i.fn = fq.getInstance()),
        (i.dn = !1),
        (i.yt = function (t, n, r) {
          if (e.types.isProxy(t)) {
            var o = Ty.wrap(Object.assign({}, t), n, r);
            return Object.defineProperty(t, n, { value: o });
          }
          return Ty.wrap(t, n, r);
        }),
        (i.Rt = function (t, n) {
          return e.types.isProxy(t)
            ? Object.defineProperty(t, n, { value: t[n] })
            : Ty.unwrap(t, n);
        }),
        (i.At = function (t, n, e) {
          t
            ? (Array.isArray(t) || (t = [t]),
              n && Array.isArray(n)
                ? t.forEach(function (t) {
                    n.forEach(function (n) {
                      i.yt(t, n, e);
                    });
                  })
                : Pr.error(
                    "must provide one or more functions to wrap on modules"
                  ))
            : Pr.error("must provide one or more modules to patch");
        }),
        (i.Ot = function (t, n) {
          t
            ? (Array.isArray(t) || (t = [t]),
              n && Array.isArray(n)
                ? t.forEach(function (t) {
                    n.forEach(function (n) {
                      i.Rt(t, n);
                    });
                  })
                : Pr.error(
                    "must provide one or more functions to wrap on modules"
                  ))
            : Pr.error("must provide one or more modules to patch");
        });
      var s = i.init();
      return (
        s && !Array.isArray(s) && (s = [s]),
        (i.hn = s || []),
        0 === i.hn.length &&
          Pr.debug(
            "No modules instrumentation has been defined for '" +
              i.instrumentationName +
              "@" +
              i.instrumentationVersion +
              "', nothing will be patched"
          ),
        i.Nt.enabled && i.enable(),
        i
      );
    }
    return (
      dq(n, t),
      (n.prototype.pn = function () {
        var t = this;
        this.hn.forEach(function (n) {
          var e = n.name;
          try {
            var r = require.resolve(e);
            require.cache[r] &&
              t.Ct.warn(
                "Module " +
                  e +
                  " has been loaded before " +
                  t.instrumentationName +
                  " so it might not work, please initialize it before requiring " +
                  e
              );
          } catch (t) {}
        });
      }),
      (n.prototype.Sn = function (t) {
        try {
          var n = o.readFileSync(A.join(t, "package.json"), {
              encoding: "utf8",
            }),
            e = JSON.parse(n).version;
          return "string" == typeof e ? e : void 0;
        } catch (n) {
          Pr.warn("Failed extracting version", t);
        }
      }),
      (n.prototype.En = function (t, n, e, r) {
        var o,
          i = this;
        if (!r)
          return "function" == typeof t.patch &&
            ((t.moduleExports = n), this.dn)
            ? (this.Ct.debug(
                "Applying instrumentation patch for nodejs core module on require hook",
                { module: t.name }
              ),
              t.patch(n))
            : n;
        var s = this.Sn(r);
        if (((t.moduleVersion = s), t.name === e))
          return Sq(t.supportedVersions, s, t.includePrerelease) &&
            "function" == typeof t.patch &&
            ((t.moduleExports = n), this.dn)
            ? (this.Ct.debug(
                "Applying instrumentation patch for module on require hook",
                { module: t.name, version: t.moduleVersion, baseDir: r }
              ),
              t.patch(n, t.moduleVersion))
            : n;
        var u = null !== (o = t.files) && void 0 !== o ? o : [],
          c = A.normalize(e);
        return u
          .filter(function (t) {
            return t.name === c;
          })
          .filter(function (n) {
            return Sq(n.supportedVersions, s, t.includePrerelease);
          })
          .reduce(function (n, e) {
            return (
              (e.moduleExports = n),
              i.dn
                ? (i.Ct.debug(
                    "Applying instrumentation patch for nodejs module file on require hook",
                    {
                      module: t.name,
                      version: t.moduleVersion,
                      fileName: e.name,
                      baseDir: r,
                    }
                  ),
                  e.patch(n, t.moduleVersion))
                : n
            );
          }, n);
      }),
      (n.prototype.enable = function () {
        var t,
          n,
          e,
          r,
          o,
          i,
          s = this;
        if (!this.dn)
          if (((this.dn = !0), this.ln.length > 0))
            try {
              for (var u = hq(this.hn), c = u.next(); !c.done; c = u.next()) {
                var a = c.value;
                "function" == typeof a.patch &&
                  a.moduleExports &&
                  (this.Ct.debug(
                    "Applying instrumentation patch for nodejs module on instrumentation enabled",
                    { module: a.name, version: a.moduleVersion }
                  ),
                  a.patch(a.moduleExports, a.moduleVersion));
                try {
                  for (
                    var l = ((e = void 0), hq(a.files)), f = l.next();
                    !f.done;
                    f = l.next()
                  ) {
                    var d = f.value;
                    d.moduleExports &&
                      (this.Ct.debug(
                        "Applying instrumentation patch for nodejs module file on instrumentation enabled",
                        {
                          module: a.name,
                          version: a.moduleVersion,
                          fileName: d.name,
                        }
                      ),
                      d.patch(d.moduleExports, a.moduleVersion));
                  }
                } catch (t) {
                  e = { error: t };
                } finally {
                  try {
                    f && !f.done && (r = l.return) && r.call(l);
                  } finally {
                    if (e) throw e.error;
                  }
                }
              }
            } catch (n) {
              t = { error: n };
            } finally {
              try {
                c && !c.done && (n = u.return) && n.call(u);
              } finally {
                if (t) throw t.error;
              }
            }
          else {
            this.pn();
            var h = function (t) {
                var n = function (n, e, r) {
                    return s.En(t, n, e, r);
                  },
                  e = A.isAbsolute(t.name)
                    ? new JR([t.name], { internals: !0 }, n)
                    : p.fn.register(t.name, n);
                p.ln.push(e);
                var r = new uk([t.name], { internals: !1 }, function (n, e, r) {
                  return s.En(t, n, e, r);
                });
                p.ln.push(r);
              },
              p = this;
            try {
              for (var S = hq(this.hn), E = S.next(); !E.done; E = S.next()) {
                h(E.value);
              }
            } catch (t) {
              o = { error: t };
            } finally {
              try {
                E && !E.done && (i = S.return) && i.call(S);
              } finally {
                if (o) throw o.error;
              }
            }
          }
      }),
      (n.prototype.disable = function () {
        var t, n, e, r;
        if (this.dn) {
          this.dn = !1;
          try {
            for (var o = hq(this.hn), i = o.next(); !i.done; i = o.next()) {
              var s = i.value;
              "function" == typeof s.unpatch &&
                s.moduleExports &&
                (this.Ct.debug(
                  "Removing instrumentation patch for nodejs module on instrumentation disabled",
                  { module: s.name, version: s.moduleVersion }
                ),
                s.unpatch(s.moduleExports, s.moduleVersion));
              try {
                for (
                  var u = ((e = void 0), hq(s.files)), c = u.next();
                  !c.done;
                  c = u.next()
                ) {
                  var a = c.value;
                  a.moduleExports &&
                    (this.Ct.debug(
                      "Removing instrumentation patch for nodejs module file on instrumentation disabled",
                      {
                        module: s.name,
                        version: s.moduleVersion,
                        fileName: a.name,
                      }
                    ),
                    a.unpatch(a.moduleExports, s.moduleVersion));
                }
              } catch (t) {
                e = { error: t };
              } finally {
                try {
                  c && !c.done && (r = u.return) && r.call(u);
                } finally {
                  if (e) throw e.error;
                }
              }
            }
          } catch (n) {
            t = { error: n };
          } finally {
            try {
              i && !i.done && (n = o.return) && n.call(o);
            } finally {
              if (t) throw t.error;
            }
          }
        }
      }),
      (n.prototype.isEnabled = function () {
        return this.dn;
      }),
      n
    );
  })(eq);
function Sq(t, n, e) {
  return void 0 === n
    ? t.includes("*")
    : t.some(function (t) {
        return Qv.satisfies(n, t, { includePrerelease: e });
      });
}
var Eq = function (t, n, e, r, o) {
    (this.name = t),
      (this.supportedVersions = n),
      (this.patch = e),
      (this.unpatch = r),
      (this.files = o || []);
  },
  mq = function (t, e, r, o) {
    (this.supportedVersions = e),
      (this.patch = r),
      (this.unpatch = o),
      (this.name = n.normalize(t));
  },
  Tq = function (t, n, e, r) {
    return new (e || (e = Promise))(function (o, i) {
      function s(t) {
        try {
          c(r.next(t));
        } catch (t) {
          i(t);
        }
      }
      function u(t) {
        try {
          c(r.throw(t));
        } catch (t) {
          i(t);
        }
      }
      function c(t) {
        var n;
        t.done
          ? o(t.value)
          : ((n = t.value),
            n instanceof e
              ? n
              : new e(function (t) {
                  t(n);
                })).then(s, u);
      }
      c((r = r.apply(t, n || [])).next());
    });
  },
  _q = function (t, n) {
    var e,
      r,
      o,
      i,
      s = {
        label: 0,
        sent: function () {
          if (1 & o[0]) throw o[1];
          return o[1];
        },
        trys: [],
        ops: [],
      };
    return (
      (i = { next: u(0), throw: u(1), return: u(2) }),
      "function" == typeof Symbol &&
        (i[Symbol.iterator] = function () {
          return this;
        }),
      i
    );
    function u(i) {
      return function (u) {
        return (function (i) {
          if (e) throw new TypeError("Generator is already executing.");
          for (; s; )
            try {
              if (
                ((e = 1),
                r &&
                  (o =
                    2 & i[0]
                      ? r.return
                      : i[0]
                        ? r.throw || ((o = r.return) && o.call(r), 0)
                        : r.next) &&
                  !(o = o.call(r, i[1])).done)
              )
                return o;
              switch (((r = 0), o && (i = [2 & i[0], o.value]), i[0])) {
                case 0:
                case 1:
                  o = i;
                  break;
                case 4:
                  return s.label++, { value: i[1], done: !1 };
                case 5:
                  s.label++, (r = i[1]), (i = [0]);
                  continue;
                case 7:
                  (i = s.ops.pop()), s.trys.pop();
                  continue;
                default:
                  if (
                    !((o = s.trys),
                    (o = o.length > 0 && o[o.length - 1]) ||
                      (6 !== i[0] && 2 !== i[0]))
                  ) {
                    s = 0;
                    continue;
                  }
                  if (3 === i[0] && (!o || (i[1] > o[0] && i[1] < o[3]))) {
                    s.label = i[1];
                    break;
                  }
                  if (6 === i[0] && s.label < o[1]) {
                    (s.label = o[1]), (o = i);
                    break;
                  }
                  if (o && s.label < o[2]) {
                    (s.label = o[2]), s.ops.push(i);
                    break;
                  }
                  o[2] && s.ops.pop(), s.trys.pop();
                  continue;
              }
              i = n.call(t, s);
            } catch (t) {
              (i = [6, t]), (r = 0);
            } finally {
              e = o = 0;
            }
          if (5 & i[0]) throw i[1];
          return { value: i[0] ? i[1] : void 0, done: !0 };
        })([i, u]);
      };
    }
  };
var bq = Object.freeze({
    __proto__: null,
    InstrumentationBase: pq,
    InstrumentationNodeModuleDefinition: Eq,
    InstrumentationNodeModuleFile: mq,
    isWrapped: function (t) {
      return (
        "function" == typeof t &&
        "function" == typeof t.__original &&
        "function" == typeof t.__unwrap &&
        !0 === t.__wrapped
      );
    },
    registerInstrumentations: function (t) {
      var n = tq(t.instrumentations).instrumentations,
        e = t.tracerProvider || Qr.getTracerProvider(),
        r = t.meterProvider || Ur.getMeterProvider(),
        o = t.loggerProvider || q$.getLoggerProvider();
      return (
        (function (t, n, e, r) {
          for (var o = 0, i = t.length; o < i; o++) {
            var s = t[o];
            n && s.setTracerProvider(n),
              e && s.setMeterProvider(e),
              r && s.setLoggerProvider && s.setLoggerProvider(r),
              s.getConfig().enabled || s.enable();
          }
        })(n, e, r, o),
        function () {
          !(function (t) {
            t.forEach(function (t) {
              return t.disable();
            });
          })(n);
        }
      );
    },
    safeExecuteInTheMiddle: function (t, n, e) {
      var r, o;
      try {
        o = t();
      } catch (t) {
        r = t;
      } finally {
        if ((n(r, o), r && !e)) throw r;
        return o;
      }
    },
    safeExecuteInTheMiddleAsync: function (t, n, e) {
      return Tq(this, void 0, void 0, function () {
        var r, o, i;
        return _q(this, function (s) {
          switch (s.label) {
            case 0:
              return s.trys.push([0, 2, 3, 4]), [4, t()];
            case 1:
              return (o = s.sent()), [3, 4];
            case 2:
              return (i = s.sent()), (r = i), [3, 4];
            case 3:
              if ((n(r, o), r && !e)) throw r;
              return [2, o];
            case 4:
              return [2];
          }
        });
      });
    },
  }),
  vq = Ht(bq),
  yq = {};
Object.defineProperty(yq, "__esModule", { value: !0 }),
  (yq.VERSION = void 0),
  (yq.VERSION = "0.38.0");
var Rq = {};
Object.defineProperty(Rq, "__esModule", { value: !0 }),
  (Rq.HapiLifecycleMethodNames =
    Rq.HapiLayerType =
    Rq.handlerPatched =
    Rq.HapiComponentName =
      void 0),
  (Rq.HapiComponentName = "@hapi/hapi"),
  (Rq.handlerPatched = Symbol("hapi-handler-patched")),
  (Rq.HapiLayerType = {
    ROUTER: "router",
    PLUGIN: "plugin",
    EXT: "server.ext",
  }),
  (Rq.HapiLifecycleMethodNames = new Set([
    "onPreAuth",
    "onCredentials",
    "onPostAuth",
    "onPreHandler",
    "onPostHandler",
    "onPreResponse",
    "onRequest",
  ]));
var Aq = {},
  Oq = {};
!(function (t) {
  Object.defineProperty(t, "__esModule", { value: !0 }),
    (t.AttributeNames = void 0),
    (function (t) {
      (t.HAPI_TYPE = "hapi.type"),
        (t.PLUGIN_NAME = "hapi.plugin.name"),
        (t.EXT_TYPE = "server.ext.type");
    })(t.AttributeNames || (t.AttributeNames = {}));
})(Oq),
  (function (t) {
    Object.defineProperty(t, "__esModule", { value: !0 }),
      (t.getPluginFromInput =
        t.getExtMetadata =
        t.getRouteMetadata =
        t.isPatchableExtMethod =
        t.isDirectExtInput =
        t.isLifecycleExtEventObj =
        t.isLifecycleExtType =
        t.getPluginName =
          void 0);
    const n = KB,
      e = Rq,
      r = Oq;
    t.getPluginName = function (t) {
      return t.name ? t.name : t.pkg.name;
    };
    t.isLifecycleExtType = (t) =>
      "string" == typeof t && e.HapiLifecycleMethodNames.has(t);
    t.isLifecycleExtEventObj = (n) => {
      var e;
      const r = null === (e = n) || void 0 === e ? void 0 : e.type;
      return void 0 !== r && (0, t.isLifecycleExtType)(r);
    };
    t.isDirectExtInput = (n) =>
      Array.isArray(n) &&
      n.length <= 3 &&
      (0, t.isLifecycleExtType)(n[0]) &&
      "function" == typeof n[1];
    t.isPatchableExtMethod = (t) => !Array.isArray(t);
    t.getRouteMetadata = (t, o) =>
      o
        ? {
            attributes: {
              [n.SemanticAttributes.HTTP_ROUTE]: t.path,
              [n.SemanticAttributes.HTTP_METHOD]: t.method,
              [r.AttributeNames.HAPI_TYPE]: e.HapiLayerType.PLUGIN,
              [r.AttributeNames.PLUGIN_NAME]: o,
            },
            name: `${o}: route - ${t.path}`,
          }
        : {
            attributes: {
              [n.SemanticAttributes.HTTP_ROUTE]: t.path,
              [n.SemanticAttributes.HTTP_METHOD]: t.method,
              [r.AttributeNames.HAPI_TYPE]: e.HapiLayerType.ROUTER,
            },
            name: `route - ${t.path}`,
          };
    t.getExtMetadata = (t, n) =>
      n
        ? {
            attributes: {
              [r.AttributeNames.EXT_TYPE]: t,
              [r.AttributeNames.HAPI_TYPE]: e.HapiLayerType.EXT,
              [r.AttributeNames.PLUGIN_NAME]: n,
            },
            name: `${n}: ext - ${t}`,
          }
        : {
            attributes: {
              [r.AttributeNames.EXT_TYPE]: t,
              [r.AttributeNames.HAPI_TYPE]: e.HapiLayerType.EXT,
            },
            name: `ext - ${t}`,
          };
    t.getPluginFromInput = (t) =>
      "plugin" in t ? ("plugin" in t.plugin ? t.plugin.plugin : t.plugin) : t;
  })(Aq),
  Object.defineProperty(K$, "__esModule", { value: !0 }),
  (K$.HapiInstrumentation = void 0);
const gq = no,
  Nq = pB,
  Cq = vq,
  Lq = yq,
  Iq = Rq,
  Mq = Aq;
class wq extends Cq.InstrumentationBase {
  constructor(t = {}) {
    super("@opentelemetry/instrumentation-hapi", Lq.VERSION, t);
  }
  init() {
    return new Cq.InstrumentationNodeModuleDefinition(
      Iq.HapiComponentName,
      [">=17 <22"],
      (t) => (
        (0, Cq.isWrapped)(t.server) || this.yt(t, "server", this.Yi.bind(this)),
        (0, Cq.isWrapped)(t.Server) || this.yt(t, "Server", this.Yi.bind(this)),
        t
      ),
      (t) => {
        this.Ot([t], ["server", "Server"]);
      }
    );
  }
  Yi(t) {
    const n = this,
      e = this;
    return function (r) {
      const o = t.apply(this, [r]);
      return (
        e.yt(o, "route", (t) => n.Hi.bind(n)(t)),
        e.yt(o, "ext", (t) => n.Di.bind(n)(t)),
        e.yt(o, "register", n.ji.bind(n)),
        o
      );
    };
  }
  ji(t) {
    const n = this;
    return function (e, r) {
      if (Array.isArray(e))
        for (const t of e) {
          const e = (0, Mq.getPluginFromInput)(t);
          n.xi(e);
        }
      else {
        const t = (0, Mq.getPluginFromInput)(e);
        n.xi(t);
      }
      return t.apply(this, [e, r]);
    };
  }
  Di(t, n) {
    const e = this;
    return function (...r) {
      if (Array.isArray(r[0])) {
        const o = r[0];
        for (let t = 0; t < o.length; t++) {
          const r = o[t];
          if ((0, Mq.isLifecycleExtType)(r.type)) {
            const i = r,
              s = e.ki(i.method, r.type, n);
            (i.method = s), (o[t] = i);
          }
        }
        return t.apply(this, r);
      }
      if ((0, Mq.isDirectExtInput)(r)) {
        const o = r,
          i = o[1],
          s = e.ki(i, o[0], n);
        return t.apply(this, [o[0], s, o[2]]);
      }
      if ((0, Mq.isLifecycleExtEventObj)(r[0])) {
        const o = r[0],
          i = e.ki(o.method, o.type, n);
        return (o.method = i), t.call(this, o);
      }
      return t.apply(this, r);
    };
  }
  Hi(t, n) {
    const e = this;
    return function (r) {
      if (Array.isArray(r))
        for (let t = 0; t < r.length; t++) {
          const o = e.Ki.call(e, r[t], n);
          r[t] = o;
        }
      else r = e.Ki.call(e, r, n);
      return t.apply(this, [r]);
    };
  }
  xi(t) {
    const n = this,
      e = (0, Mq.getPluginName)(t),
      r = t.register,
      o = this;
    t.register = function (t, i) {
      return (
        o.yt(t, "route", (t) => n.Hi.bind(n)(t, e)),
        o.yt(t, "ext", (t) => n.Di.bind(n)(t, e)),
        r(t, i)
      );
    };
  }
  ki(t, n, e) {
    const r = this;
    if (t instanceof Array) {
      for (let e = 0; e < t.length; e++) t[e] = r.ki(t[e], n);
      return t;
    }
    if ((0, Mq.isPatchableExtMethod)(t)) {
      if (!0 === t[Iq.handlerPatched]) return t;
      t[Iq.handlerPatched] = !0;
      return async function (...o) {
        if (void 0 === gq.trace.getSpan(gq.context.active()))
          return await t.apply(this, o);
        const i = (0, Mq.getExtMetadata)(n, e),
          s = r.tracer.startSpan(i.name, { attributes: i.attributes });
        try {
          return await gq.context.with(
            gq.trace.setSpan(gq.context.active(), s),
            t,
            void 0,
            ...o
          );
        } catch (t) {
          throw (
            (s.recordException(t),
            s.setStatus({ code: gq.SpanStatusCode.ERROR, message: t.message }),
            t)
          );
        } finally {
          s.end();
        }
      };
    }
    return t;
  }
  Ki(t, n) {
    var e;
    const r = this;
    if (!0 === t[Iq.handlerPatched]) return t;
    t[Iq.handlerPatched] = !0;
    const o = (e) =>
      async function (...o) {
        if (void 0 === gq.trace.getSpan(gq.context.active()))
          return await e.call(this, ...o);
        const i = (0, Nq.getRPCMetadata)(gq.context.active());
        (null == i ? void 0 : i.type) === Nq.RPCType.HTTP && (i.route = t.path);
        const s = (0, Mq.getRouteMetadata)(t, n),
          u = r.tracer.startSpan(s.name, { attributes: s.attributes });
        try {
          return await gq.context.with(
            gq.trace.setSpan(gq.context.active(), u),
            () => e.call(this, ...o)
          );
        } catch (t) {
          throw (
            (u.recordException(t),
            u.setStatus({ code: gq.SpanStatusCode.ERROR, message: t.message }),
            t)
          );
        } finally {
          u.end();
        }
      };
    if ("function" == typeof t.handler) t.handler = o(t.handler);
    else if ("function" == typeof t.options) {
      const n = t.options;
      t.options = function (t) {
        const e = n(t);
        return "function" == typeof e.handler && (e.handler = o(e.handler)), e;
      };
    } else
      "function" ==
        typeof (null === (e = t.options) || void 0 === e
          ? void 0
          : e.handler) && (t.options.handler = o(t.options.handler));
    return t;
  }
}
(K$.HapiInstrumentation = wq),
  (function (t) {
    var n =
        (Wt && Wt.__createBinding) ||
        (Object.create
          ? function (t, n, e, r) {
              void 0 === r && (r = e),
                Object.defineProperty(t, r, {
                  enumerable: !0,
                  get: function () {
                    return n[e];
                  },
                });
            }
          : function (t, n, e, r) {
              void 0 === r && (r = e), (t[r] = n[e]);
            }),
      e =
        (Wt && Wt.__exportStar) ||
        function (t, e) {
          for (var r in t)
            "default" === r ||
              Object.prototype.hasOwnProperty.call(e, r) ||
              n(e, t, r);
        };
    Object.defineProperty(t, "__esModule", { value: !0 }), e(K$, t), e(Oq, t);
  })(k$);
const Zq = () => ({
  name: "Hapi",
  setupOnce() {
    AK(new k$.HapiInstrumentation());
  },
});
function Pq(t) {
  captureException(t, {
    mechanism: {
      type: "hapi",
      handled: !1,
      data: { function: "hapiErrorPlugin" },
    },
  });
}
const Vq = {
  name: "SentryHapiErrorPlugin",
  version: IY,
  register: async function (t) {
    t.events.on("request", (t, n) => {
      if (wU() !== IU()) {
        const n = t.route;
        n &&
          n.path &&
          wU().setTransactionName(
            `${
              Fn([
                n,
                "access",
                (t) => t.method,
                "optionalAccess",
                (t) => t.toUpperCase,
                "call",
                (t) => t(),
              ]) || "GET"
            } ${n.path}`
          );
      }
      const e = vW(),
        r = e ? bW(e) : void 0;
      var o;
      t.response && (o = t.response) && void 0 !== o.isBoom
        ? Pq(t.response)
        : (function (t) {
            return t && void 0 !== t.error;
          })(n) && Pq(n.error),
        r && (r.setStatus({ code: nW, message: "internal_error" }), r.end());
    });
  },
};
var Gq = {},
  Xq = {},
  Uq = {};
!(function (t) {
  var n;
  Object.defineProperty(t, "__esModule", { value: !0 }),
    (t.KoaLayerType = void 0),
    ((n = t.KoaLayerType || (t.KoaLayerType = {})).ROUTER = "router"),
    (n.MIDDLEWARE = "middleware");
})(Uq);
var Wq = {};
Object.defineProperty(Wq, "__esModule", { value: !0 }),
  (Wq.VERSION = void 0),
  (Wq.VERSION = "0.39.0");
var Yq = {},
  Hq = {};
!(function (t) {
  Object.defineProperty(t, "__esModule", { value: !0 }),
    (t.AttributeNames = void 0),
    (function (t) {
      (t.KOA_TYPE = "koa.type"), (t.KOA_NAME = "koa.name");
    })(t.AttributeNames || (t.AttributeNames = {}));
})(Hq),
  Object.defineProperty(Yq, "__esModule", { value: !0 }),
  (Yq.isLayerIgnored = Yq.getMiddlewareMetadata = void 0);
const Dq = Uq,
  jq = Hq,
  xq = KB;
Yq.getMiddlewareMetadata = (t, n, e, r) => {
  var o;
  return e
    ? {
        attributes: {
          [jq.AttributeNames.KOA_NAME]: null == r ? void 0 : r.toString(),
          [jq.AttributeNames.KOA_TYPE]: Dq.KoaLayerType.ROUTER,
          [xq.SEMATTRS_HTTP_ROUTE]: null == r ? void 0 : r.toString(),
        },
        name: t.Bi || `router - ${r}`,
      }
    : {
        attributes: {
          [jq.AttributeNames.KOA_NAME]:
            null !== (o = n.name) && void 0 !== o ? o : "middleware",
          [jq.AttributeNames.KOA_TYPE]: Dq.KoaLayerType.MIDDLEWARE,
        },
        name: `middleware - ${n.name}`,
      };
};
Yq.isLayerIgnored = (t, n) => {
  var e;
  return !(
    !Array.isArray(null == n ? void 0 : n.ignoreLayersType) ||
    !(null === (e = null == n ? void 0 : n.ignoreLayersType) || void 0 === e
      ? void 0
      : e.includes(t))
  );
};
var kq = {};
Object.defineProperty(kq, "__esModule", { value: !0 }),
  (kq.kLayerPatched = void 0),
  (kq.kLayerPatched = Symbol("koa-layer-patched")),
  Object.defineProperty(Xq, "__esModule", { value: !0 }),
  (Xq.KoaInstrumentation = void 0);
const Kq = no,
  Bq = dF,
  Fq = Uq,
  Jq = Wq,
  zq = Yq,
  Qq = pB,
  $q = kq;
class qq extends Bq.InstrumentationBase {
  constructor(t = {}) {
    super(
      "@opentelemetry/instrumentation-koa",
      Jq.VERSION,
      Object.assign({}, t)
    );
  }
  setConfig(t = {}) {
    this.Nt = Object.assign({}, t);
  }
  getConfig() {
    return this.Nt;
  }
  init() {
    return new Bq.InstrumentationNodeModuleDefinition(
      "koa",
      ["^2.0.0"],
      (t) => {
        const n = "Module" === t[Symbol.toStringTag] ? t.default : t;
        return null == n
          ? n
          : (Kq.diag.debug("Patching Koa"),
            (0, Bq.isWrapped)(n.prototype.use) && this.Rt(n.prototype, "use"),
            this.yt(n.prototype, "use", this.Fi.bind(this)),
            t);
      },
      (t) => {
        const n = "Module" === t[Symbol.toStringTag] ? t.default : t;
        Kq.diag.debug("Unpatching Koa"),
          (0, Bq.isWrapped)(n.prototype.use) && this.Rt(n.prototype, "use");
      }
    );
  }
  Fi(t) {
    const n = this;
    return function (e) {
      let r;
      return (r = e.router ? n.Ji(e) : n.zi(e, !1)), t.apply(this, [r]);
    };
  }
  Ji(t) {
    var n;
    Kq.diag.debug("Patching @koa/router dispatch");
    const e = t.router,
      r = null !== (n = null == e ? void 0 : e.stack) && void 0 !== n ? n : [];
    for (const t of r) {
      const n = t.path,
        e = t.stack;
      for (let t = 0; t < e.length; t++) {
        const r = e[t];
        e[t] = this.zi(r, !0, n);
      }
    }
    return t;
  }
  zi(t, n, e) {
    const r = n ? Fq.KoaLayerType.ROUTER : Fq.KoaLayerType.MIDDLEWARE;
    return !0 === t[$q.kLayerPatched] ||
      (0, zq.isLayerIgnored)(r, this.getConfig())
      ? t
      : "GeneratorFunction" === t.constructor.name ||
          "AsyncGeneratorFunction" === t.constructor.name
        ? (Kq.diag.debug("ignoring generator-based Koa middleware layer"), t)
        : ((t[$q.kLayerPatched] = !0),
          Kq.diag.debug("patching Koa middleware layer"),
          async (o, i) => {
            if (void 0 === Kq.trace.getSpan(Kq.context.active()))
              return t(o, i);
            const s = (0, zq.getMiddlewareMetadata)(o, t, n, e),
              u = this.tracer.startSpan(s.name, { attributes: s.attributes }),
              c = (0, Qq.getRPCMetadata)(Kq.context.active());
            (null == c ? void 0 : c.type) === Qq.RPCType.HTTP &&
              o.Qi &&
              (c.route = o.Qi.toString()),
              this.getConfig().requestHook &&
                (0, Bq.safeExecuteInTheMiddle)(
                  () =>
                    this.getConfig().requestHook(u, {
                      context: o,
                      middlewareLayer: t,
                      layerType: r,
                    }),
                  (t) => {
                    t &&
                      Kq.diag.error(
                        "koa instrumentation: request hook failed",
                        t
                      );
                  },
                  !0
                );
            const a = Kq.trace.setSpan(Kq.context.active(), u);
            return Kq.context.with(a, async () => {
              try {
                return await t(o, i);
              } catch (t) {
                throw (u.recordException(t), t);
              } finally {
                u.end();
              }
            });
          });
  }
}
(Xq.KoaInstrumentation = qq),
  (function (t) {
    var n =
        (Wt && Wt.__createBinding) ||
        (Object.create
          ? function (t, n, e, r) {
              void 0 === r && (r = e),
                Object.defineProperty(t, r, {
                  enumerable: !0,
                  get: function () {
                    return n[e];
                  },
                });
            }
          : function (t, n, e, r) {
              void 0 === r && (r = e), (t[r] = n[e]);
            }),
      e =
        (Wt && Wt.__exportStar) ||
        function (t, e) {
          for (var r in t)
            "default" === r ||
              Object.prototype.hasOwnProperty.call(e, r) ||
              n(e, t, r);
        };
    Object.defineProperty(t, "__esModule", { value: !0 }),
      e(Xq, t),
      e(Uq, t),
      e(Hq, t);
  })(Gq);
const t0 = () => ({
  name: "Koa",
  setupOnce() {
    AK(
      new Gq.KoaInstrumentation({
        requestHook(t, n) {
          if (wU() === IU()) return;
          const e = hW(t).data,
            r = e && e[UC],
            o = n.context.request.method.toUpperCase() || "GET";
          r && wU().setTransactionName(`${o} ${r}`);
        },
      })
    );
  },
});
var n0 = {},
  e0 = {};
!(function (t) {
  var n, e;
  Object.defineProperty(t, "__esModule", { value: !0 }),
    (t.ConnectNames = t.ConnectTypes = t.AttributeNames = void 0),
    (function (t) {
      (t.CONNECT_TYPE = "connect.type"), (t.CONNECT_NAME = "connect.name");
    })(t.AttributeNames || (t.AttributeNames = {})),
    ((n = t.ConnectTypes || (t.ConnectTypes = {})).MIDDLEWARE = "middleware"),
    (n.REQUEST_HANDLER = "request_handler"),
    ((e = t.ConnectNames || (t.ConnectNames = {})).MIDDLEWARE = "middleware"),
    (e.REQUEST_HANDLER = "request handler");
})(e0);
var r0 = {},
  o0 = {};
Object.defineProperty(o0, "__esModule", { value: !0 }),
  (o0.VERSION = void 0),
  (o0.VERSION = "0.35.0");
var i0 = {},
  s0 = {};
Object.defineProperty(s0, "__esModule", { value: !0 }),
  (s0.mo = void 0),
  (s0.mo = Symbol("opentelemetry.instrumentation-connect.request-route-stack")),
  Object.defineProperty(i0, "__esModule", { value: !0 }),
  (i0.generateRoute =
    i0.replaceCurrentStackRoute =
    i0.addNewStackLayer =
      void 0);
const u0 = no,
  c0 = s0;
i0.addNewStackLayer = (t) => {
  !1 === Array.isArray(t[c0.mo]) &&
    Object.defineProperty(t, c0.mo, { enumerable: !1, value: [] }),
    t[c0.mo].push("/");
  const n = t[c0.mo].length;
  return () => {
    n === t[c0.mo].length
      ? t[c0.mo].pop()
      : u0.diag.warn("Connect: Trying to pop the stack multiple time");
  };
};
i0.replaceCurrentStackRoute = (t, n) => {
  n && t[c0.mo].splice(-1, 1, n);
};
(i0.generateRoute = (t) =>
  t[c0.mo].reduce((t, n) => t.replace(/\/+$/, "") + n)),
  (function (t) {
    Object.defineProperty(t, "__esModule", { value: !0 }),
      (t.ConnectInstrumentation = t.ANONYMOUS_NAME = void 0);
    const n = no,
      e = pB,
      r = e0,
      o = o0,
      i = dF,
      s = KB,
      u = i0;
    t.ANONYMOUS_NAME = "anonymous";
    class c extends i.InstrumentationBase {
      constructor(t = {}) {
        super(
          "@opentelemetry/instrumentation-connect",
          o.VERSION,
          Object.assign({}, t)
        );
      }
      init() {
        return [
          new i.InstrumentationNodeModuleDefinition(
            "connect",
            ["^3.0.0"],
            (t, e) => (
              n.diag.debug(`Applying patch for connect@${e}`), this.Ao(t)
            ),
            (t, e) => {
              n.diag.debug(`Removing patch for connect@${e}`);
            }
          ),
        ];
      }
      $i(t) {
        (0, i.isWrapped)(t.use) || this.yt(t, "use", this.qi.bind(this)),
          (0, i.isWrapped)(t.handle) ||
            this.yt(t, "handle", this.ts.bind(this));
      }
      Ao(t) {
        const n = this;
        return function (...e) {
          const r = t.apply(this, e);
          return n.$i(r), r;
        };
      }
      ns(t, n) {
        return function (e) {
          const r = t.apply(this, [e]);
          return n(), r;
        };
      }
      di(n, e) {
        let o, i, u;
        n
          ? ((o = r.ConnectTypes.REQUEST_HANDLER),
            (u = r.ConnectNames.REQUEST_HANDLER),
            (i = n))
          : ((o = r.ConnectTypes.MIDDLEWARE),
            (u = r.ConnectNames.MIDDLEWARE),
            (i = e.name || t.ANONYMOUS_NAME));
        const c = `${u} - ${i}`,
          a = {
            attributes: {
              [s.SemanticAttributes.HTTP_ROUTE]: n.length > 0 ? n : "/",
              [r.AttributeNames.CONNECT_TYPE]: o,
              [r.AttributeNames.CONNECT_NAME]: i,
            },
          };
        return this.tracer.startSpan(c, a);
      }
      es(r, o) {
        const i = this,
          s = 4 === o.length;
        function c() {
          if (!i.isEnabled()) return o.apply(this, arguments);
          const [c, a, l] = s ? [1, 2, 3] : [0, 1, 2],
            f = arguments[c],
            d = arguments[a],
            h = arguments[l];
          (0, u.replaceCurrentStackRoute)(f, r);
          const p = (0, e.getRPCMetadata)(n.context.active());
          r &&
            (null == p ? void 0 : p.type) === e.RPCType.HTTP &&
            (p.route = (0, u.generateRoute)(f));
          let S = "";
          S = r
            ? `request handler - ${r}`
            : `middleware - ${o.name || t.ANONYMOUS_NAME}`;
          const E = i.di(r, o);
          i.Ct.debug("start span", S);
          let m = !1;
          function T() {
            m
              ? i.Ct.debug(`span ${E.name} - already finished`)
              : ((m = !0), i.Ct.debug(`finishing span ${E.name}`), E.end()),
              d.removeListener("close", T);
          }
          return (
            d.addListener("close", T),
            (arguments[l] = i.ns(h, T)),
            o.apply(this, arguments)
          );
        }
        return (
          Object.defineProperty(c, "length", {
            value: o.length,
            writable: !1,
            configurable: !0,
          }),
          c
        );
      }
      qi(t) {
        const n = this;
        return function (...e) {
          const r = e[e.length - 1],
            o = e[e.length - 2] || "";
          return (e[e.length - 1] = n.es(o, r)), t.apply(this, e);
        };
      }
      ts(t) {
        const n = this;
        return function () {
          const [e, r] = [0, 2],
            o = arguments[e],
            i = arguments[r],
            s = (0, u.addNewStackLayer)(o);
          return (
            "function" == typeof i && (arguments[r] = n.rs(i, s)),
            t.apply(this, arguments)
          );
        };
      }
      rs(t, n) {
        return function (...e) {
          return n(), Reflect.apply(t, this, e);
        };
      }
    }
    t.ConnectInstrumentation = c;
  })(r0),
  (function (t) {
    var n =
        (Wt && Wt.__createBinding) ||
        (Object.create
          ? function (t, n, e, r) {
              void 0 === r && (r = e),
                Object.defineProperty(t, r, {
                  enumerable: !0,
                  get: function () {
                    return n[e];
                  },
                });
            }
          : function (t, n, e, r) {
              void 0 === r && (r = e), (t[r] = n[e]);
            }),
      e =
        (Wt && Wt.__exportStar) ||
        function (t, e) {
          for (var r in t)
            "default" === r ||
              Object.prototype.hasOwnProperty.call(e, r) ||
              n(e, t, r);
        };
    Object.defineProperty(t, "__esModule", { value: !0 }), e(e0, t), e(r0, t);
  })(n0);
const a0 = () => ({
  name: "Connect",
  setupOnce() {
    AK(new n0.ConnectInstrumentation({}));
  },
});
function l0(t, n, e, r) {
  captureException(t), r(t);
}
const f0 = (t = {}) => {
  const n = { sidecarUrl: t.sidecarUrl || "http://localhost:8969/stream" };
  return {
    name: "Spotlight",
    setup(t) {
      "object" == typeof process &&
        process.env &&
        "development" !== process.env.NODE_ENV &&
        it.warn(
          "[Spotlight] It seems you're not in dev mode. Do you really want to have Spotlight enabled?"
        ),
        (function (t, n) {
          const e = (function (t) {
            try {
              return new URL(`${t}`);
            } catch (n) {
              return void it.warn(`[Spotlight] Invalid sidecar URL: ${t}`);
            }
          })(n.sidecarUrl);
          if (!e) return;
          let r = 0;
          t.on("beforeEnvelope", (t) => {
            if (r > 3)
              return void it.warn(
                "[Spotlight] Disabled Sentry -> Spotlight integration due to too many failed requests"
              );
            const n = Pn(t),
              o = (function () {
                const { request: t } = C;
                if (((n = t), "__sentry_original__" in n))
                  return t.__sentry_original__;
                var n;
                return t;
              })()(
                {
                  method: "POST",
                  path: e.pathname,
                  hostname: e.hostname,
                  port: e.port,
                  headers: { "Content-Type": "application/x-sentry-envelope" },
                },
                (t) => {
                  t.on("data", () => {}),
                    t.on("end", () => {}),
                    t.setEncoding("utf8");
                }
              );
            o.on("error", () => {
              r++,
                it.warn(
                  "[Spotlight] Failed to send envelope to Spotlight Sidecar"
                );
            }),
              o.write(n),
              o.end();
          });
        })(t, n);
    },
  };
};
const d0 = Symbol("AgentBaseInternalState");
class h0 extends C.Agent {
  constructor(t) {
    super(t), (this[d0] = {});
  }
  isSecureEndpoint(t) {
    if (t) {
      if ("boolean" == typeof t.secureEndpoint) return t.secureEndpoint;
      if ("string" == typeof t.protocol) return "https:" === t.protocol;
    }
    const { stack: n } = new Error();
    return (
      "string" == typeof n &&
      n
        .split("\n")
        .some(
          (t) =>
            -1 !== t.indexOf("(https.js:") || -1 !== t.indexOf("node:https:")
        )
    );
  }
  createSocket(t, n, e) {
    const r = { ...n, secureEndpoint: this.isSecureEndpoint(n) };
    Promise.resolve()
      .then(() => this.connect(t, r))
      .then((o) => {
        if (o instanceof C.Agent) return o.addRequest(t, r);
        (this[d0].currentSocket = o), super.createSocket(t, n, e);
      }, e);
  }
  createConnection() {
    const t = this[d0].currentSocket;
    if (((this[d0].currentSocket = void 0), !t))
      throw new Error("No socket was returned in the `connect()` function");
    return t;
  }
  get defaultPort() {
    return Bn(this[d0].defaultPort, () =>
      "https:" === this.protocol ? 443 : 80
    );
  }
  set defaultPort(t) {
    this[d0] && (this[d0].defaultPort = t);
  }
  get protocol() {
    return Bn(this[d0].protocol, () =>
      this.isSecureEndpoint() ? "https:" : "http:"
    );
  }
  set protocol(t) {
    this[d0] && (this[d0].protocol = t);
  }
}
function p0(...t) {
  it.log("[https-proxy-agent:parse-proxy-response]", ...t);
}
function S0(t) {
  return new Promise((n, e) => {
    let r = 0;
    const o = [];
    function i() {
      const u = t.read();
      u
        ? (function (u) {
            o.push(u), (r += u.length);
            const c = Buffer.concat(o, r),
              a = c.indexOf("\r\n\r\n");
            if (-1 === a)
              return (
                p0("have not received end of HTTP headers yet..."), void i()
              );
            const l = c.slice(0, a).toString("ascii").split("\r\n"),
              f = l.shift();
            if (!f)
              return (
                t.destroy(),
                e(new Error("No header received from proxy CONNECT response"))
              );
            const d = f.split(" "),
              h = +d[1],
              p = d.slice(2).join(" "),
              S = {};
            for (const n of l) {
              if (!n) continue;
              const r = n.indexOf(":");
              if (-1 === r)
                return (
                  t.destroy(),
                  e(
                    new Error(
                      `Invalid header from proxy CONNECT response: "${n}"`
                    )
                  )
                );
              const o = n.slice(0, r).toLowerCase(),
                i = n.slice(r + 1).trimStart(),
                s = S[o];
              "string" == typeof s
                ? (S[o] = [s, i])
                : Array.isArray(s)
                  ? s.push(i)
                  : (S[o] = i);
            }
            p0("got proxy server response: %o %o", f, S),
              s(),
              n({
                connect: { statusCode: h, statusText: p, headers: S },
                buffered: c,
              });
          })(u)
        : t.once("readable", i);
    }
    function s() {
      t.removeListener("end", u),
        t.removeListener("error", c),
        t.removeListener("readable", i);
    }
    function u() {
      s(),
        p0("onend"),
        e(
          new Error("Proxy connection ended before receiving CONNECT response")
        );
    }
    function c(t) {
      s(), p0("onerror %o", t), e(t);
    }
    t.on("error", c), t.on("end", u), i();
  });
}
function E0(...t) {
  it.log("[https-proxy-agent]", ...t);
}
class m0 extends h0 {
  static __initStatic() {
    this.protocols = ["http", "https"];
  }
  constructor(t, n) {
    super(n),
      (this.options = {}),
      (this.proxy = "string" == typeof t ? new URL(t) : t),
      (this.proxyHeaders = Bn(
        Fn([n, "optionalAccess", (t) => t.headers]),
        () => ({})
      )),
      E0("Creating new HttpsProxyAgent instance: %o", this.proxy.href);
    const e = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, ""),
      r = this.proxy.port
        ? parseInt(this.proxy.port, 10)
        : "https:" === this.proxy.protocol
          ? 443
          : 80;
    this.connectOpts = {
      ALPNProtocols: ["http/1.1"],
      ...(n ? _0(n, "headers") : null),
      host: e,
      port: r,
    };
  }
  async connect(t, n) {
    const { proxy: e } = this;
    if (!n.host) throw new TypeError('No "host" provided');
    let r;
    if ("https:" === e.protocol) {
      E0("Creating `tls.Socket`: %o", this.connectOpts);
      const t = this.connectOpts.servername || this.connectOpts.host;
      r = w.connect({
        ...this.connectOpts,
        servername: t && M.isIP(t) ? void 0 : t,
      });
    } else
      E0("Creating `net.Socket`: %o", this.connectOpts),
        (r = M.connect(this.connectOpts));
    const o =
        "function" == typeof this.proxyHeaders
          ? this.proxyHeaders()
          : { ...this.proxyHeaders },
      i = M.isIPv6(n.host) ? `[${n.host}]` : n.host;
    let s = `CONNECT ${i}:${n.port} HTTP/1.1\r\n`;
    if (e.username || e.password) {
      const t = `${decodeURIComponent(e.username)}:${decodeURIComponent(
        e.password
      )}`;
      o["Proxy-Authorization"] = `Basic ${Buffer.from(t).toString("base64")}`;
    }
    (o.Host = `${i}:${n.port}`),
      o["Proxy-Connection"] ||
        (o["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close");
    for (const t of Object.keys(o)) s += `${t}: ${o[t]}\r\n`;
    const u = S0(r);
    r.write(`${s}\r\n`);
    const { connect: c, buffered: a } = await u;
    if (
      (t.emit("proxyConnect", c),
      this.emit("proxyConnect", c, t),
      200 === c.statusCode)
    ) {
      if ((t.once("socket", T0), n.secureEndpoint)) {
        E0("Upgrading socket connection to TLS");
        const t = n.servername || n.host;
        return w.connect({
          ..._0(n, "host", "path", "port"),
          socket: r,
          servername: M.isIP(t) ? void 0 : t,
        });
      }
      return r;
    }
    r.destroy();
    const l = new M.Socket({ writable: !1 });
    return (
      (l.readable = !0),
      t.once("socket", (t) => {
        E0("Replaying proxy buffer for failed request"),
          t.push(a),
          t.push(null);
      }),
      l
    );
  }
}
function T0(t) {
  t.resume();
}
function _0(t, ...n) {
  const e = {};
  let r;
  for (r in t) n.includes(r) || (e[r] = t[r]);
  return e;
}
m0.__initStatic();
const b0 = 32768;
function v0(t) {
  let n;
  try {
    n = new URL(t.url);
  } catch (n) {
    return (
      ot(() => {
        console.warn(
          "[@sentry/node]: Invalid dsn or tunnel option, will not send any events. The tunnel option must be a full URL when used."
        );
      }),
      CY(t, () => Promise.resolve({}))
    );
  }
  const e = "https:" === n.protocol,
    r = (function (t, n) {
      const { no_proxy: e } = process.env;
      return e &&
        e.split(",").some((n) => t.host.endsWith(n) || t.hostname.endsWith(n))
        ? void 0
        : n;
    })(
      n,
      t.proxy ||
        (e ? process.env.https_proxy : void 0) ||
        process.env.http_proxy
    ),
    o = e ? I : L,
    i = void 0 !== t.keepAlive && t.keepAlive,
    s = r
      ? new m0(r)
      : new o.Agent({ keepAlive: i, maxSockets: 30, timeout: 2e3 });
  return (function (t) {
    const n = kW();
    return n.suppressTracing
      ? n.suppressTracing(t)
      : PU((n) => (n.setSDKProcessingMetadata({ [YW]: !0 }), t()));
  })(() => {
    const n = (function (t, n, e) {
      const {
        hostname: r,
        pathname: o,
        port: i,
        protocol: s,
        search: u,
      } = new URL(t.url);
      return function (c) {
        return new Promise((a, l) => {
          let f = (function (t) {
            return new E.Readable({
              read() {
                this.push(t), this.push(null);
              },
            });
          })(c.body);
          const d = { ...t.headers };
          c.body.length > b0 &&
            ((d["content-encoding"] = "gzip"), (f = f.pipe(m.createGzip())));
          const h = n.request(
            {
              method: "POST",
              agent: e,
              headers: d,
              hostname: r,
              path: `${o}${u}`,
              port: i,
              protocol: s,
              ca: t.caCerts,
            },
            (t) => {
              t.on("data", () => {}),
                t.on("end", () => {}),
                t.setEncoding("utf8");
              const n = Bn(t.headers["retry-after"], () => null),
                e = Bn(t.headers["x-sentry-rate-limits"], () => null);
              a({
                statusCode: t.statusCode,
                headers: {
                  "retry-after": n,
                  "x-sentry-rate-limits": Array.isArray(e) ? e[0] : e,
                },
              });
            }
          );
          h.on("error", l), f.pipe(h);
        });
      };
    })(
      t,
      Bn(t.httpModule, () => o),
      s
    );
    return CY(t, n);
  });
}
function y0(t) {
  return t.replace(/^[A-Z]:/, "").replace(/\\/g, "/");
}
function R0(
  t = process.argv[1]
    ? (function (t) {
        const n = $t(t),
          e = n[0];
        let r = n[1];
        return e || r ? (r && (r = r.slice(0, r.length - 1)), e + r) : ".";
      })(process.argv[1])
    : process.cwd(),
  e = "\\" === n.sep
) {
  const r = e ? y0(t) : t;
  return (t) => {
    if (!t) return;
    const o = e ? y0(t) : t;
    let { dir: i, base: s, ext: u } = n.posix.parse(o);
    (".js" !== u && ".mjs" !== u && ".cjs" !== u) ||
      (s = s.slice(0, -1 * u.length)),
      i || (i = ".");
    const c = i.lastIndexOf("/node_modules");
    if (c > -1) return `${i.slice(c + 14).replace(/\//g, ".")}:${s}`;
    if (i.startsWith(r)) {
      let t = i.slice(r.length + 1).replace(/\//g, ".");
      return t && (t += ":"), (t += s), t;
    }
    return s;
  };
}
function A0(t) {
  return process.env.SENTRY_RELEASE
    ? process.env.SENTRY_RELEASE
    : Q.SENTRY_RELEASE && Q.SENTRY_RELEASE.id
      ? Q.SENTRY_RELEASE.id
      : process.env.GITHUB_SHA ||
        process.env.COMMIT_REF ||
        process.env.VERCEL_GIT_COMMIT_SHA ||
        process.env.VERCEL_GITHUB_COMMIT_SHA ||
        process.env.VERCEL_GITLAB_COMMIT_SHA ||
        process.env.VERCEL_BITBUCKET_COMMIT_SHA ||
        process.env.ZEIT_GITHUB_COMMIT_SHA ||
        process.env.ZEIT_GITLAB_COMMIT_SHA ||
        process.env.ZEIT_BITBUCKET_COMMIT_SHA ||
        process.env.CF_PAGES_COMMIT_SHA ||
        t;
}
const O0 = yt([90, _n(R0())]);
class g0 extends gY {
  constructor(t) {
    const n = {
      ...t,
      platform: "node",
      runtime: { name: "node", version: global.process.version },
      serverName:
        t.serverName || global.process.env.SENTRY_NAME || g.hostname(),
    };
    !(function (t, n, e = [n], r = "npm") {
      const o = t.Ze || {};
      o.sdk ||
        (o.sdk = {
          name: `sentry.javascript.${n}`,
          packages: e.map((t) => ({ name: `${r}:@sentry/${t}`, version: IY })),
          version: IY,
        }),
        (t.Ze = o);
    })(n, "node"),
      it.log(
        `Initializing Sentry: process: ${process.pid}, thread: ${
          f.isMainThread ? "main" : `worker-${f.threadId}`
        }.`
      ),
      super(n);
  }
  get tracer() {
    if (this.Lt) return this.Lt;
    const t = IY,
      n = Qr.getTracer("@sentry/node", t);
    return (this.Lt = n), n;
  }
  async flush(t) {
    const n = Fn([
      this.traceProvider,
      "optionalAccess",
      (t) => t.activeSpanProcessor,
    ]);
    return n && (await n.forceFlush()), super.flush(t);
  }
}
var N0 = {},
  C0 = {},
  L0 = {};
Object.defineProperty(L0, "__esModule", { value: !0 }),
  (L0.AbstractAsyncHooksContextManager = void 0);
const I0 = l,
  M0 = ["addListener", "on", "once", "prependListener", "prependOnceListener"];
(L0.AbstractAsyncHooksContextManager = class {
  constructor() {
    (this.ss = Symbol("OtListeners")), (this.us = !1);
  }
  bind(t, n) {
    return n instanceof I0.EventEmitter
      ? this.cs(t, n)
      : "function" == typeof n
        ? this.ls(t, n)
        : n;
  }
  ls(t, n) {
    const e = this,
      r = function (...r) {
        return e.with(t, () => n.apply(this, r));
      };
    return (
      Object.defineProperty(r, "length", {
        enumerable: !1,
        configurable: !0,
        writable: !1,
        value: n.length,
      }),
      r
    );
  }
  cs(t, n) {
    return (
      void 0 !== this.ds(n) ||
        (this.hs(n),
        M0.forEach((e) => {
          void 0 !== n[e] && (n[e] = this.ps(n, n[e], t));
        }),
        "function" == typeof n.removeListener &&
          (n.removeListener = this.Ss(n, n.removeListener)),
        "function" == typeof n.off && (n.off = this.Ss(n, n.off)),
        "function" == typeof n.removeAllListeners &&
          (n.removeAllListeners = this.Es(n, n.removeAllListeners))),
      n
    );
  }
  Ss(t, n) {
    const e = this;
    return function (r, o) {
      var i;
      const s = null === (i = e.ds(t)) || void 0 === i ? void 0 : i[r];
      if (void 0 === s) return n.call(this, r, o);
      const u = s.get(o);
      return n.call(this, r, u || o);
    };
  }
  Es(t, n) {
    const e = this;
    return function (r) {
      const o = e.ds(t);
      return (
        void 0 !== o &&
          (0 === arguments.length ? e.hs(t) : void 0 !== o[r] && delete o[r]),
        n.apply(this, arguments)
      );
    };
  }
  ps(t, n, e) {
    const r = this;
    return function (o, i) {
      if (r.us) return n.call(this, o, i);
      let s = r.ds(t);
      void 0 === s && (s = r.hs(t));
      let u = s[o];
      void 0 === u && ((u = new WeakMap()), (s[o] = u));
      const c = r.bind(e, i);
      u.set(i, c), (r.us = !0);
      try {
        return n.call(this, o, c);
      } finally {
        r.us = !1;
      }
    };
  }
  hs(t) {
    const n = Object.create(null);
    return (t[this.ss] = n), n;
  }
  ds(t) {
    return t[this.ss];
  }
}),
  Object.defineProperty(C0, "__esModule", { value: !0 }),
  (C0.AsyncHooksContextManager = void 0);
const w0 = no,
  Z0 = b,
  P0 = L0;
class V0 extends P0.AbstractAsyncHooksContextManager {
  constructor() {
    super(),
      (this.Jn = new Map()),
      (this.ue = []),
      (this.Ts = Z0.createHook({
        init: this._s.bind(this),
        before: this.bs.bind(this),
        after: this.vs.bind(this),
        destroy: this.ys.bind(this),
        promiseResolve: this.ys.bind(this),
      }));
  }
  active() {
    var t;
    return null !== (t = this.ue[this.ue.length - 1]) && void 0 !== t
      ? t
      : w0.ROOT_CONTEXT;
  }
  with(t, n, e, ...r) {
    this.Rs(t);
    try {
      return n.call(e, ...r);
    } finally {
      this.As();
    }
  }
  enable() {
    return this.Ts.enable(), this;
  }
  disable() {
    return this.Ts.disable(), this.Jn.clear(), (this.ue = []), this;
  }
  _s(t, n) {
    if ("TIMERWRAP" === n) return;
    const e = this.ue[this.ue.length - 1];
    void 0 !== e && this.Jn.set(t, e);
  }
  ys(t) {
    this.Jn.delete(t);
  }
  bs(t) {
    const n = this.Jn.get(t);
    void 0 !== n && this.Rs(n);
  }
  vs() {
    this.As();
  }
  Rs(t) {
    this.ue.push(t);
  }
  As() {
    this.ue.pop();
  }
}
C0.AsyncHooksContextManager = V0;
var G0 = {};
Object.defineProperty(G0, "__esModule", { value: !0 }),
  (G0.AsyncLocalStorageContextManager = void 0);
const X0 = no,
  U0 = b,
  W0 = L0;
class Y0 extends W0.AbstractAsyncHooksContextManager {
  constructor() {
    super(), (this.Os = new U0.AsyncLocalStorage());
  }
  active() {
    var t;
    return null !== (t = this.Os.getStore()) && void 0 !== t
      ? t
      : X0.ROOT_CONTEXT;
  }
  with(t, n, e, ...r) {
    const o = null == e ? n : n.bind(e);
    return this.Os.run(t, o, ...r);
  }
  enable() {
    return this;
  }
  disable() {
    return this.Os.disable(), this;
  }
}
(G0.AsyncLocalStorageContextManager = Y0),
  (function (t) {
    var n =
        (Wt && Wt.__createBinding) ||
        (Object.create
          ? function (t, n, e, r) {
              void 0 === r && (r = e),
                Object.defineProperty(t, r, {
                  enumerable: !0,
                  get: function () {
                    return n[e];
                  },
                });
            }
          : function (t, n, e, r) {
              void 0 === r && (r = e), (t[r] = n[e]);
            }),
      e =
        (Wt && Wt.__exportStar) ||
        function (t, e) {
          for (var r in t)
            "default" === r ||
              Object.prototype.hasOwnProperty.call(e, r) ||
              n(e, t, r);
        };
    Object.defineProperty(t, "__esModule", { value: !0 }), e(C0, t), e(G0, t);
  })(N0);
const H0 =
  ((D0 = N0.AsyncLocalStorageContextManager),
  class extends D0 {
    constructor() {
      super(), Hk("SentryContextManager");
    }
    with(t, n, e, ...r) {
      const o = Zk(t),
        i = iK([o, "optionalAccess", (t) => t.scope]) || MU(),
        s = iK([o, "optionalAccess", (t) => t.isolationScope]) || wU(),
        u = !0 === t.getValue(Lk),
        c = t.getValue(Ik),
        a = t.getValue(Mk),
        l = c || i.clone(),
        f = Pk(t, { scope: l, isolationScope: a || (u ? s.clone() : s) })
          .deleteValue(Lk)
          .deleteValue(Ik)
          .deleteValue(Mk);
      return (
        (function (t, n) {
          dt(t, wk, n);
        })(l, f),
        super.with(f, n, e, ...r)
      );
    }
  });
var D0;
function j0(t) {
  if (t.getOptions().debug) {
    const t = new Proxy(it, {
      get(t, n, e) {
        const r = "verbose" === n ? "debug" : n;
        return Reflect.get(t, r, e);
      },
    });
    Pr.setLogger(t, se.DEBUG);
  }
  !(function (t) {
    t.on("preprocessEvent", (t) => {
      const n = Wk();
      if (!n || "transaction" === t.type) return;
      const e = n.spanContext();
      t.contexts = {
        trace: Et({
          trace_id: e.traceId,
          span_id: e.spanId,
          parent_span_id: _k(n) ? n.parentSpanId : void 0,
        }),
        ...t.contexts,
      };
      const r = bW(n);
      return (
        (t.sdkProcessingMetadata = {
          dynamicSamplingContext: Uk(r),
          ...t.sdkProcessingMetadata,
        }),
        t
      );
    });
  })(t);
  const n = (function (t) {
    const n = new ax({
      sampler: new RK(t),
      resource: new ix({ [yG]: "node", [RG]: "sentry", [OG]: IY }),
      forceFlushTimeoutMillis: 500,
    });
    return (
      n.addSpanProcessor(new yK()),
      n.register({ propagator: new xk(), contextManager: new H0() }),
      n
    );
  })(t);
  t.traceProvider = n;
}
function x0() {
  return void 0 !== Lx;
}
function k0(t = {}) {
  return (function (t = {}, n) {
    const e = (function (t, n) {
      const e = (function (t) {
          if (void 0 !== t) return t;
          const n = A0();
          if (void 0 !== n) return n;
          return;
        })(t.release),
        r =
          "string" == typeof e &&
          (void 0 === t.autoSessionTracking || t.autoSessionTracking),
        o = (function (t) {
          if (void 0 !== t) return t;
          const n = process.env.SENTRY_TRACES_SAMPLE_RATE;
          if (!n) return;
          const e = parseFloat(n);
          return isFinite(e) ? e : void 0;
        })(t.tracesSampleRate),
        i = Et({
          transport: v0,
          dsn: process.env.SENTRY_DSN,
          environment: process.env.SENTRY_ENVIRONMENT,
        }),
        s = Et({ release: e, autoSessionTracking: r, tracesSampleRate: o }),
        u = { ...i, ...t, ...s };
      void 0 === t.defaultIntegrations && (t.defaultIntegrations = n(u));
      const c = {
        ...u,
        stackParser: Rt(t.stackParser || O0),
        integrations: bY({
          defaultIntegrations: t.defaultIntegrations,
          integrations: t.integrations,
        }),
      };
      return c;
    })(t, n);
    !0 === e.debug &&
      ot(() => {
        console.warn(
          "[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle."
        );
      });
    if (!x0()) {
      const [t, n] = process.versions.node.split(".").map(Number);
      if (t >= 22 || (20 === t && n >= 6) || (18 === t && n >= 19)) {
        const t =
          void 0 !==
          ("undefined" == typeof document
            ? require("url").pathToFileURL(__filename).href
            : (v && v.src) ||
              new URL("index-hjEUR1dN.js", document.baseURI).href)
            ? "undefined" == typeof document
              ? require("url").pathToFileURL(__filename).href
              : (v && v.src) ||
                new URL("index-hjEUR1dN.js", document.baseURI).href
            : void 0;
        !Q.gs &&
          t &&
          (r.register("@opentelemetry/instrumentation/hook.mjs", t),
          (Q.gs = !0));
      } else
        ot(() => {
          console.warn(
            '[Sentry] You are using Node.js in ESM mode ("import syntax"). The Sentry Node.js SDK is not compatible with ESM in Node.js versions before 18.19.0 or before 20.6.0. Please either build your application with CommonJS ("require() syntax"), or use version 7.x of the Sentry Node.js SDK.'
          );
        });
    }
    oK();
    MU().update(t.initialScope);
    const o = new g0(e);
    MU().setClient(o),
      (function (t) {
        return !1 !== t.getOptions().enabled && void 0 !== t.getTransport();
      })(o) && o.init();
    t.autoSessionTracking &&
      (function () {
        const t = GU();
        t && t.getOptions().autoSessionTracking && t.initSessionFlusher();
        hY(),
          process.on("beforeExit", () => {
            const t = wU().getSession();
            t && "ok" !== t.status && pY();
          });
      })();
    if (
      ((function () {
        const t = (process.env.SENTRY_USE_ENVIRONMENT || "").toLowerCase();
        if (!["false", "n", "no", "off", "0"].includes(t)) {
          const t = Cn(process.env.SENTRY_TRACE, process.env.SENTRY_BAGGAGE);
          MU().setPropagationContext(t);
        }
      })(),
      t.spotlight)
    ) {
      const n = o.getOptions().integrations;
      for (const t of n) o.addIntegration(t);
      o.addIntegration(
        f0({
          sidecarUrl: "string" == typeof t.spotlight ? t.spotlight : void 0,
        })
      );
    }
    t.skipOpenTelemetrySetup || j0(o);
  })(t, () => []);
}
const K0 = [
  ["january", "1"],
  ["february", "2"],
  ["march", "3"],
  ["april", "4"],
  ["may", "5"],
  ["june", "6"],
  ["july", "7"],
  ["august", "8"],
  ["september", "9"],
  ["october", "10"],
  ["november", "11"],
  ["december", "12"],
  ["jan", "1"],
  ["feb", "2"],
  ["mar", "3"],
  ["apr", "4"],
  ["may", "5"],
  ["jun", "6"],
  ["jul", "7"],
  ["aug", "8"],
  ["sep", "9"],
  ["oct", "10"],
  ["nov", "11"],
  ["dec", "12"],
  ["sunday", "0"],
  ["monday", "1"],
  ["tuesday", "2"],
  ["wednesday", "3"],
  ["thursday", "4"],
  ["friday", "5"],
  ["saturday", "6"],
  ["sun", "0"],
  ["mon", "1"],
  ["tue", "2"],
  ["wed", "3"],
  ["thu", "4"],
  ["fri", "5"],
  ["sat", "6"],
];
function B0(t) {
  return K0.reduce((t, [n, e]) => t.replace(new RegExp(n, "gi"), e), t);
}
const F0 = "Automatic instrumentation of CronJob only supports crontab string";
const J0 = {
  instrumentCron: function (t, n) {
    let e = !1;
    return new Proxy(t, {
      construct(t, r) {
        const [o, i, s, u, c, ...a] = r;
        if ("string" != typeof o) throw new Error(F0);
        if (e) throw new Error(`A job named '${n}' has already been scheduled`);
        e = !0;
        const l = B0(o);
        return new t(
          o,
          async function (t, e) {
            return lY(
              n,
              async () => {
                try {
                  await i(t, e);
                } catch (t) {
                  throw (captureException(t), t);
                }
              },
              { schedule: { type: "crontab", value: l }, timezone: c || void 0 }
            );
          },
          s,
          u,
          c,
          ...a
        );
      },
      get: (t, r) =>
        "from" === r
          ? (r) => {
              const { cronTime: o, onTick: i, timeZone: s } = r;
              if ("string" != typeof o) throw new Error(F0);
              if (e)
                throw new Error(
                  `A job named '${n}' has already been scheduled`
                );
              e = !0;
              const u = B0(o);
              return (
                (r.onTick = async (t, e) =>
                  lY(
                    n,
                    async () => {
                      try {
                        await i(t, e);
                      } catch (t) {
                        throw (captureException(t), t);
                      }
                    },
                    {
                      schedule: { type: "crontab", value: u },
                      timezone: s || void 0,
                    }
                  )),
                t.from(r)
              );
            }
          : t[r],
    });
  },
  instrumentNodeCron: function (t) {
    return new Proxy(t, {
      get: (t, n) =>
        "schedule" === n && t.schedule
          ? new Proxy(t.schedule, {
              apply(t, n, e) {
                const [r, o, i] = e;
                if (!Fn([i, "optionalAccess", (t) => t.name]))
                  throw new Error(
                    'Missing "name" for scheduled job. A name is required for Sentry check-in monitoring.'
                  );
                return t.apply(n, [
                  r,
                  async function () {
                    return lY(
                      i.name,
                      async () => {
                        try {
                          return await o();
                        } catch (t) {
                          throw (captureException(t), t);
                        }
                      },
                      {
                        schedule: { type: "crontab", value: B0(r) },
                        timezone: Fn([i, "optionalAccess", (t) => t.timezone]),
                      }
                    );
                  },
                  i,
                ]);
              },
            })
          : t[n],
    });
  },
  instrumentNodeSchedule: function (t) {
    return new Proxy(t, {
      get: (t, n) =>
        "scheduleJob" === n
          ? new Proxy(t.scheduleJob, {
              apply(t, n, e) {
                const [r, o, i] = e;
                if (
                  "string" != typeof r ||
                  "string" != typeof o ||
                  "function" != typeof i
                )
                  throw new Error(
                    "Automatic instrumentation of 'node-schedule' requires the first parameter of 'scheduleJob' to be a job name string and the second parameter to be a crontab string"
                  );
                const s = r,
                  u = o;
                return t.apply(n, [
                  s,
                  u,
                  async function () {
                    return lY(
                      s,
                      async () => {
                        await Fn([i, "optionalCall", (t) => t()]);
                      },
                      { schedule: { type: "crontab", value: B0(u) } }
                    );
                  },
                ]);
              },
            })
          : t[n],
    });
  },
};
var z0 = {},
  Q0 = {},
  $0 = {};
!(function (t) {
  Object.defineProperty(t, "__esModule", { value: !0 }),
    (t.AttributeNames = void 0),
    (function (t) {
      (t.AWS_OPERATION = "aws.operation"),
        (t.AWS_REGION = "aws.region"),
        (t.AWS_SERVICE_API = "aws.service.api"),
        (t.AWS_SERVICE_NAME = "aws.service.name"),
        (t.AWS_SERVICE_IDENTIFIER = "aws.service.identifier"),
        (t.AWS_REQUEST_ID = "aws.request.id"),
        (t.AWS_REQUEST_EXTENDED_ID = "aws.request.extended_id"),
        (t.AWS_SIGNATURE_VERSION = "aws.signature.version");
    })(t.AttributeNames || (t.AttributeNames = {}));
})($0);
var q0 = {},
  t1 = {},
  n1 = {},
  e1 = {},
  r1 = {};
Object.defineProperty(r1, "__esModule", { value: !0 });
const o1 = no,
  i1 = Symbol("opentelemetry.pubsub-propagation.start_span"),
  s1 = Symbol("opentelemetry.pubsub-propagation.end_span"),
  u1 = (t, n, e) => {
    const r = t.filter;
    Object.defineProperty(t, "filter", {
      enumerable: !1,
      value: function (...t) {
        const o = r.apply(this, t);
        return l1(o, n, e), o;
      },
    });
  };
function c1(t) {
  var n;
  return (
    "function" == typeof (null === (n = t) || void 0 === n ? void 0 : n.then)
  );
}
const a1 = (t, n, e, r) => {
    const o = t[n];
    Object.defineProperty(t, n, {
      enumerable: !1,
      value: function (...t) {
        const n = t[0];
        t[0] = function (...t) {
          var e;
          const o = t[0],
            i =
              null === (e = null == o ? void 0 : o[i1]) || void 0 === e
                ? void 0
                : e.call(o);
          if (!i) return n.apply(this, t);
          const s = o1.context.with(o1.trace.setSpan(r, i), () => {
            var e;
            let r;
            try {
              if (((r = n.apply(this, t)), c1(r))) {
                const t = () => {
                  var t;
                  return null === (t = o[s1]) || void 0 === t
                    ? void 0
                    : t.call(o);
                };
                r.then(t, t);
              }
              return r;
            } finally {
              c1(r) || null === (e = o[s1]) || void 0 === e || e.call(o);
            }
          });
          if ("object" == typeof s) {
            const t = Object.getOwnPropertyDescriptor(o, i1);
            t && Object.defineProperty(s, i1, t);
            const n = Object.getOwnPropertyDescriptor(o, s1);
            n && Object.defineProperty(s, s1, n);
          }
          return s;
        };
        const i = o.apply(this, t);
        return Array.isArray(i) && l1(i, e, r), i;
      },
    });
  },
  l1 = (t, n, e = o1.context.active()) => {
    a1(t, "forEach", n, e), a1(t, "map", n, e), u1(t, n, e);
  };
(r1.default = {
  patchMessagesArrayToStartProcessSpans: ({
    messages: t,
    tracer: n,
    parentContext: e,
    messageToSpanDetails: r,
    processHook: o,
  }) => {
    t.forEach((t) => {
      const { attributes: i, name: s, parentContext: u } = r(t);
      Object.defineProperty(t, i1, {
        enumerable: !1,
        writable: !0,
        value: () =>
          ((t, n, e, r, o, i, s) => {
            const u = [],
              c = o1.trace.getSpanContext(o);
            c && u.push({ context: c });
            const a = `${n} process`,
              l = i.startSpan(
                a,
                {
                  kind: o1.SpanKind.CONSUMER,
                  attributes: Object.assign(Object.assign({}, e), {
                    "messaging.operation": "process",
                  }),
                  links: u,
                },
                r
              );
            Object.defineProperty(t, i1, {
              enumerable: !1,
              writable: !0,
              value: () => l,
            }),
              Object.defineProperty(t, s1, {
                enumerable: !1,
                writable: !0,
                value: () => {
                  l.end(),
                    Object.defineProperty(t, s1, {
                      enumerable: !1,
                      writable: !0,
                      value: () => {},
                    });
                },
              });
            try {
              null == s || s(l, t);
            } catch (t) {
              o1.diag.error(
                "opentelemetry-pubsub-propagation: process hook error",
                t
              );
            }
            return l;
          })(t, s, i, e, u, n, o),
      });
    });
  },
  patchArrayForProcessSpans: l1,
}),
  (function (t) {
    Object.defineProperty(t, "__esModule", { value: !0 }),
      (t.pubsubPropagation = void 0);
    var n = r1;
    Object.defineProperty(t, "pubsubPropagation", {
      enumerable: !0,
      get: function () {
        return n.default;
      },
    });
  })(e1);
var f1 = {};
!(function (t) {
  Object.defineProperty(t, "__esModule", { value: !0 }),
    (t.addPropagationFieldsToAttributeNames =
      t.extractPropagationContext =
      t.injectPropagationContext =
      t.contextGetter =
      t.contextSetter =
      t.MAX_MESSAGE_ATTRIBUTES =
        void 0);
  const n = no;
  t.MAX_MESSAGE_ATTRIBUTES = 10;
  t.contextSetter = new (class {
    set(t, n, e) {
      t[n] = { DataType: "String", StringValue: e };
    }
  })();
  t.contextGetter = new (class {
    keys(t) {
      return null == t ? [] : Object.keys(t);
    }
    get(t, n) {
      var e, r;
      return (
        (null === (e = null == t ? void 0 : t[n]) || void 0 === e
          ? void 0
          : e.StringValue) ||
        (null === (r = null == t ? void 0 : t[n]) || void 0 === r
          ? void 0
          : r.Value)
      );
    }
  })();
  t.injectPropagationContext = (e) => {
    const r = null != e ? e : {};
    return (
      Object.keys(r).length + n.propagation.fields().length <=
      t.MAX_MESSAGE_ATTRIBUTES
        ? n.propagation.inject(n.context.active(), r, t.contextSetter)
        : n.diag.warn(
            "aws-sdk instrumentation: cannot set context propagation on SQS/SNS message due to maximum amount of MessageAttributes"
          ),
      r
    );
  };
  t.extractPropagationContext = (t, e) => {
    const r = n.propagation.fields();
    if (Object.keys(t.MessageAttributes || []).some((t) => r.includes(t)))
      return t.MessageAttributes;
    if (e && t.Body)
      try {
        return JSON.parse(t.Body).MessageAttributes;
      } catch (t) {
        n.diag.debug(
          "failed to parse SQS payload to extract context propagation, trace might be incomplete."
        );
      }
  };
  t.addPropagationFieldsToAttributeNames = (t = [], n) =>
    t.length ? Array.from(new Set([...t, ...n])) : n;
})(f1),
  Object.defineProperty(n1, "__esModule", { value: !0 }),
  (n1.SqsServiceExtension = void 0);
const d1 = no,
  h1 = e1,
  p1 = KB,
  S1 = f1;
n1.SqsServiceExtension = class {
  constructor() {
    (this.requestPostSpanHook = (t) => {
      var n, e;
      switch (t.commandName) {
        case "SendMessage":
          {
            const e =
              null !== (n = t.commandInput.MessageAttributes) && void 0 !== n
                ? n
                : {};
            e &&
              (t.commandInput.MessageAttributes = (0,
              S1.injectPropagationContext)(e));
          }
          break;
        case "SendMessageBatch": {
          const n =
            null === (e = t.commandInput) || void 0 === e ? void 0 : e.Entries;
          Array.isArray(n) &&
            n.forEach((t) => {
              var n;
              t.MessageAttributes = (0, S1.injectPropagationContext)(
                null !== (n = t.MessageAttributes) && void 0 !== n ? n : {}
              );
            });
        }
      }
    }),
      (this.responseHook = (t, n, e, r) => {
        var o, i;
        switch (t.request.commandName) {
          case "SendMessage":
            n.setAttribute(
              p1.SemanticAttributes.MESSAGING_MESSAGE_ID,
              null === (o = null == t ? void 0 : t.data) || void 0 === o
                ? void 0
                : o.MessageId
            );
            break;
          case "SendMessageBatch":
            break;
          case "ReceiveMessage": {
            const o =
              null === (i = null == t ? void 0 : t.data) || void 0 === i
                ? void 0
                : i.Messages;
            if (o) {
              const i = this.extractQueueUrl(t.request.commandInput),
                s = this.extractQueueNameFromUrl(i);
              h1.pubsubPropagation.patchMessagesArrayToStartProcessSpans({
                messages: o,
                parentContext: d1.trace.setSpan(d1.context.active(), n),
                tracer: e,
                messageToSpanDetails: (t) => ({
                  name: null != s ? s : "unknown",
                  parentContext: d1.propagation.extract(
                    d1.ROOT_CONTEXT,
                    (0, S1.extractPropagationContext)(
                      t,
                      r.sqsExtractContextPropagationFromPayload
                    ),
                    S1.contextGetter
                  ),
                  attributes: {
                    [p1.SemanticAttributes.MESSAGING_SYSTEM]: "aws.sqs",
                    [p1.SemanticAttributes.MESSAGING_DESTINATION]: s,
                    [p1.SemanticAttributes.MESSAGING_DESTINATION_KIND]:
                      p1.MessagingDestinationKindValues.QUEUE,
                    [p1.SemanticAttributes.MESSAGING_MESSAGE_ID]: t.MessageId,
                    [p1.SemanticAttributes.MESSAGING_URL]: i,
                    [p1.SemanticAttributes.MESSAGING_OPERATION]:
                      p1.MessagingOperationValues.PROCESS,
                  },
                }),
                processHook: (t, n) => {
                  var e;
                  return null === (e = r.sqsProcessHook) || void 0 === e
                    ? void 0
                    : e.call(r, t, { message: n });
                },
              }),
                h1.pubsubPropagation.patchArrayForProcessSpans(
                  o,
                  e,
                  d1.context.active()
                );
            }
            break;
          }
        }
      }),
      (this.extractQueueUrl = (t) => (null == t ? void 0 : t.QueueUrl)),
      (this.extractQueueNameFromUrl = (t) => {
        if (!t) return;
        const n = t.split("/");
        return 0 !== n.length ? n[n.length - 1] : void 0;
      });
  }
  requestPreSpanHook(t, n) {
    const e = this.extractQueueUrl(t.commandInput),
      r = this.extractQueueNameFromUrl(e);
    let o,
      i = d1.SpanKind.CLIENT;
    const s = {
      [p1.SemanticAttributes.MESSAGING_SYSTEM]: "aws.sqs",
      [p1.SemanticAttributes.MESSAGING_DESTINATION_KIND]:
        p1.MessagingDestinationKindValues.QUEUE,
      [p1.SemanticAttributes.MESSAGING_DESTINATION]: r,
      [p1.SemanticAttributes.MESSAGING_URL]: e,
    };
    let u = !1;
    switch (t.commandName) {
      case "ReceiveMessage":
        (u = !0),
          (i = d1.SpanKind.CONSUMER),
          (o = `${r} receive`),
          (s[p1.SemanticAttributes.MESSAGING_OPERATION] =
            p1.MessagingOperationValues.RECEIVE),
          (t.commandInput.MessageAttributeNames = (0,
          S1.addPropagationFieldsToAttributeNames)(
            t.commandInput.MessageAttributeNames,
            d1.propagation.fields()
          ));
        break;
      case "SendMessage":
      case "SendMessageBatch":
        (i = d1.SpanKind.PRODUCER), (o = `${r} send`);
    }
    return { isIncoming: u, spanAttributes: s, spanKind: i, spanName: o };
  }
};
var E1 = {};
Object.defineProperty(E1, "__esModule", { value: !0 }),
  (E1.DynamodbServiceExtension = void 0);
const m1 = no,
  T1 = KB;
E1.DynamodbServiceExtension = class {
  toArray(t) {
    return Array.isArray(t) ? t : [t];
  }
  requestPreSpanHook(t, n, e) {
    var r, o, i, s, u, c, a, l, f, d, h, p, S, E, m, T, _, b, v, y, R;
    const A = m1.SpanKind.CLIENT;
    const O = t.commandName,
      g = {
        [T1.SemanticAttributes.DB_SYSTEM]: T1.DbSystemValues.DYNAMODB,
        [T1.SemanticAttributes.DB_NAME]:
          null === (r = t.commandInput) || void 0 === r ? void 0 : r.TableName,
        [T1.SemanticAttributes.DB_OPERATION]: O,
      };
    if (n.dynamoDBStatementSerializer)
      try {
        const e = n.dynamoDBStatementSerializer(O, t.commandInput);
        "string" == typeof e && (g[T1.SemanticAttributes.DB_STATEMENT] = e);
      } catch (t) {
        e.error("failed to sanitize DynamoDB statement", t);
      }
    return (
      (null === (o = t.commandInput) || void 0 === o ? void 0 : o.TableName)
        ? (g[T1.SemanticAttributes.AWS_DYNAMODB_TABLE_NAMES] = [
            t.commandInput.TableName,
          ])
        : (null === (i = t.commandInput) || void 0 === i
            ? void 0
            : i.RequestItems) &&
          (g[T1.SemanticAttributes.AWS_DYNAMODB_TABLE_NAMES] = Object.keys(
            t.commandInput.RequestItems
          )),
      ("CreateTable" !== O && "UpdateTable" !== O) ||
        ((null === (s = t.commandInput) || void 0 === s
          ? void 0
          : s.ProvisionedThroughput) &&
          ((g[T1.SemanticAttributes.AWS_DYNAMODB_PROVISIONED_READ_CAPACITY] =
            t.commandInput.ProvisionedThroughput.ReadCapacityUnits),
          (g[T1.SemanticAttributes.AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY] =
            t.commandInput.ProvisionedThroughput.WriteCapacityUnits))),
      ("GetItem" !== O && "Scan" !== O && "Query" !== O) ||
        ((null === (u = t.commandInput) || void 0 === u
          ? void 0
          : u.ConsistentRead) &&
          (g[T1.SemanticAttributes.AWS_DYNAMODB_CONSISTENT_READ] =
            t.commandInput.ConsistentRead)),
      ("Query" !== O && "Scan" !== O) ||
        ((null === (c = t.commandInput) || void 0 === c
          ? void 0
          : c.ProjectionExpression) &&
          (g[T1.SemanticAttributes.AWS_DYNAMODB_PROJECTION] =
            t.commandInput.ProjectionExpression)),
      "CreateTable" === O &&
        ((null === (a = t.commandInput) || void 0 === a
          ? void 0
          : a.GlobalSecondaryIndexes) &&
          (g[T1.SemanticAttributes.AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES] =
            this.toArray(t.commandInput.GlobalSecondaryIndexes).map((t) =>
              JSON.stringify(t)
            )),
        (null === (l = t.commandInput) || void 0 === l
          ? void 0
          : l.LocalSecondaryIndexes) &&
          (g[T1.SemanticAttributes.AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES] =
            this.toArray(t.commandInput.LocalSecondaryIndexes).map((t) =>
              JSON.stringify(t)
            ))),
      ("ListTables" !== O && "Query" !== O && "Scan" !== O) ||
        ((null === (f = t.commandInput) || void 0 === f ? void 0 : f.Limit) &&
          (g[T1.SemanticAttributes.AWS_DYNAMODB_LIMIT] = t.commandInput.Limit)),
      "ListTables" === O &&
        (null === (d = t.commandInput) || void 0 === d
          ? void 0
          : d.ExclusiveStartTableName) &&
        (g[T1.SemanticAttributes.AWS_DYNAMODB_EXCLUSIVE_START_TABLE] =
          t.commandInput.ExclusiveStartTableName),
      "Query" === O &&
        ((null === (h = t.commandInput) || void 0 === h
          ? void 0
          : h.ScanIndexForward) &&
          (g[T1.SemanticAttributes.AWS_DYNAMODB_SCAN_FORWARD] =
            t.commandInput.ScanIndexForward),
        (null === (p = t.commandInput) || void 0 === p
          ? void 0
          : p.IndexName) &&
          (g[T1.SemanticAttributes.AWS_DYNAMODB_INDEX_NAME] =
            t.commandInput.IndexName),
        (null === (S = t.commandInput) || void 0 === S ? void 0 : S.Select) &&
          (g[T1.SemanticAttributes.AWS_DYNAMODB_SELECT] =
            t.commandInput.Select)),
      "Scan" === O &&
        ((null === (E = t.commandInput) || void 0 === E ? void 0 : E.Segment) &&
          (g[T1.SemanticAttributes.AWS_DYNAMODB_SEGMENT] =
            null === (m = t.commandInput) || void 0 === m ? void 0 : m.Segment),
        (null === (T = t.commandInput) || void 0 === T
          ? void 0
          : T.TotalSegments) &&
          (g[T1.SemanticAttributes.AWS_DYNAMODB_TOTAL_SEGMENTS] =
            null === (_ = t.commandInput) || void 0 === _
              ? void 0
              : _.TotalSegments),
        (null === (b = t.commandInput) || void 0 === b
          ? void 0
          : b.IndexName) &&
          (g[T1.SemanticAttributes.AWS_DYNAMODB_INDEX_NAME] =
            t.commandInput.IndexName),
        (null === (v = t.commandInput) || void 0 === v ? void 0 : v.Select) &&
          (g[T1.SemanticAttributes.AWS_DYNAMODB_SELECT] =
            t.commandInput.Select)),
      "UpdateTable" === O &&
        ((null === (y = t.commandInput) || void 0 === y
          ? void 0
          : y.AttributeDefinitions) &&
          (g[T1.SemanticAttributes.AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS] =
            this.toArray(t.commandInput.AttributeDefinitions).map((t) =>
              JSON.stringify(t)
            )),
        (null === (R = t.commandInput) || void 0 === R
          ? void 0
          : R.GlobalSecondaryIndexUpdates) &&
          (g[
            T1.SemanticAttributes.AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES
          ] = this.toArray(t.commandInput.GlobalSecondaryIndexUpdates).map(
            (t) => JSON.stringify(t)
          ))),
      { isIncoming: !1, spanAttributes: g, spanKind: A, spanName: undefined }
    );
  }
  responseHook(t, n, e, r) {
    var o, i, s, u, c, a, l, f, d;
    (null === (o = t.data) || void 0 === o ? void 0 : o.ConsumedCapacity) &&
      n.setAttribute(
        T1.SemanticAttributes.AWS_DYNAMODB_CONSUMED_CAPACITY,
        ((d = t.data.ConsumedCapacity), Array.isArray(d) ? d : [d]).map((t) =>
          JSON.stringify(t)
        )
      ),
      (null === (i = t.data) || void 0 === i
        ? void 0
        : i.ItemCollectionMetrics) &&
        n.setAttribute(
          T1.SemanticAttributes.AWS_DYNAMODB_ITEM_COLLECTION_METRICS,
          this.toArray(t.data.ItemCollectionMetrics).map((t) =>
            JSON.stringify(t)
          )
        ),
      (null === (s = t.data) || void 0 === s ? void 0 : s.TableNames) &&
        n.setAttribute(
          T1.SemanticAttributes.AWS_DYNAMODB_TABLE_COUNT,
          null === (u = t.data) || void 0 === u ? void 0 : u.TableNames.length
        ),
      (null === (c = t.data) || void 0 === c ? void 0 : c.Count) &&
        n.setAttribute(
          T1.SemanticAttributes.AWS_DYNAMODB_COUNT,
          null === (a = t.data) || void 0 === a ? void 0 : a.Count
        ),
      (null === (l = t.data) || void 0 === l ? void 0 : l.ScannedCount) &&
        n.setAttribute(
          T1.SemanticAttributes.AWS_DYNAMODB_SCANNED_COUNT,
          null === (f = t.data) || void 0 === f ? void 0 : f.ScannedCount
        );
  }
};
var _1 = {};
Object.defineProperty(_1, "__esModule", { value: !0 }),
  (_1.SnsServiceExtension = void 0);
const b1 = no,
  v1 = KB,
  y1 = f1;
_1.SnsServiceExtension = class {
  requestPreSpanHook(t, n) {
    let e = b1.SpanKind.CLIENT,
      r = `SNS ${t.commandName}`;
    const o = { [v1.SemanticAttributes.MESSAGING_SYSTEM]: "aws.sns" };
    if ("Publish" === t.commandName) {
      (e = b1.SpanKind.PRODUCER),
        (o[v1.SemanticAttributes.MESSAGING_DESTINATION_KIND] =
          v1.MessagingDestinationKindValues.TOPIC);
      const { TopicArn: n, TargetArn: i, PhoneNumber: s } = t.commandInput;
      (o[v1.SemanticAttributes.MESSAGING_DESTINATION] =
        this.extractDestinationName(n, i, s)),
        (o["messaging.destination.name"] = n || i || s || "unknown"),
        (r = `${
          s ? "phone_number" : o[v1.SemanticAttributes.MESSAGING_DESTINATION]
        } send`);
    }
    return { isIncoming: !1, spanAttributes: o, spanKind: e, spanName: r };
  }
  requestPostSpanHook(t) {
    var n;
    if ("Publish" === t.commandName) {
      const e =
        null !== (n = t.commandInput.MessageAttributes) && void 0 !== n
          ? n
          : {};
      e &&
        (t.commandInput.MessageAttributes = (0, y1.injectPropagationContext)(
          e
        ));
    }
  }
  responseHook(t, n, e, r) {}
  extractDestinationName(t, n, e) {
    if (!t && !n) return e || "unknown";
    {
      const e = null != t ? t : n;
      try {
        return e.substr(e.lastIndexOf(":") + 1);
      } catch (t) {
        return e;
      }
    }
  }
};
var R1 = {};
Object.defineProperty(R1, "__esModule", { value: !0 }),
  (R1.LambdaServiceExtension = void 0);
const A1 = no,
  O1 = KB,
  g1 = no;
class N1 {}
N1.Invoke = "Invoke";
R1.LambdaServiceExtension = class {
  constructor() {
    (this.requestPostSpanHook = (t) => {
      if (t.commandName === N1.Invoke)
        t.commandInput &&
          (t.commandInput.ClientContext = C1(t.commandInput.ClientContext));
    }),
      (this.extractFunctionName = (t) => (null == t ? void 0 : t.FunctionName));
  }
  requestPreSpanHook(t, n) {
    const e = this.extractFunctionName(t.commandInput);
    let r,
      o = {};
    if ("Invoke" === t.commandName)
      (o = {
        [O1.SemanticAttributes.FAAS_INVOKED_NAME]: e,
        [O1.SemanticAttributes.FAAS_INVOKED_PROVIDER]: "aws",
      }),
        t.region && (o[O1.SemanticAttributes.FAAS_INVOKED_REGION] = t.region),
        (r = `${e} ${N1.Invoke}`);
    return {
      isIncoming: !1,
      spanAttributes: o,
      spanKind: A1.SpanKind.CLIENT,
      spanName: r,
    };
  }
  responseHook(t, n, e, r) {
    if (t.request.commandName === N1.Invoke)
      n.setAttribute(O1.SemanticAttributes.FAAS_EXECUTION, t.requestId);
  }
};
const C1 = (t) => {
  try {
    const n = {};
    g1.propagation.inject(g1.context.active(), n);
    const e = t ? JSON.parse(Buffer.from(t, "base64").toString("utf8")) : {},
      r = Object.assign(Object.assign({}, e), {
        Custom: Object.assign(Object.assign({}, e.Custom), n),
      }),
      o = Buffer.from(JSON.stringify(r)).toString("base64");
    return o.length > 3583
      ? (A1.diag.warn(
          "lambda instrumentation: cannot set context propagation on lambda invoke parameters due to ClientContext length limitations."
        ),
        t)
      : o;
  } catch (n) {
    return (
      A1.diag.debug(
        "lambda instrumentation: failed to set context propagation on ClientContext",
        n
      ),
      t
    );
  }
};
Object.defineProperty(t1, "__esModule", { value: !0 }),
  (t1.ServicesExtensions = void 0);
const L1 = n1,
  I1 = E1,
  M1 = _1,
  w1 = R1;
(t1.ServicesExtensions = class {
  constructor() {
    (this.services = new Map()),
      this.services.set("SQS", new L1.SqsServiceExtension()),
      this.services.set("SNS", new M1.SnsServiceExtension()),
      this.services.set("DynamoDB", new I1.DynamodbServiceExtension()),
      this.services.set("Lambda", new w1.LambdaServiceExtension());
  }
  requestPreSpanHook(t, n, e) {
    const r = this.services.get(t.serviceName);
    return r ? r.requestPreSpanHook(t, n, e) : { isIncoming: !1 };
  }
  requestPostSpanHook(t) {
    const n = this.services.get(t.serviceName);
    if (null == n ? void 0 : n.requestPostSpanHook)
      return n.requestPostSpanHook(t);
  }
  responseHook(t, n, e, r) {
    var o;
    const i = this.services.get(t.request.serviceName);
    null === (o = null == i ? void 0 : i.responseHook) ||
      void 0 === o ||
      o.call(i, t, n, e, r);
  }
}),
  (function (t) {
    Object.defineProperty(t, "__esModule", { value: !0 }),
      (t.ServicesExtensions = void 0);
    var n = t1;
    Object.defineProperty(t, "ServicesExtensions", {
      enumerable: !0,
      get: function () {
        return n.ServicesExtensions;
      },
    });
  })(q0);
var Z1 = {};
Object.defineProperty(Z1, "__esModule", { value: !0 }),
  (Z1.VERSION = void 0),
  (Z1.VERSION = "0.40.0");
var P1 = {};
!(function (t) {
  Object.defineProperty(t, "__esModule", { value: !0 }),
    (t.bindPromise =
      t.extractAttributesFromNormalizedRequest =
      t.normalizeV3Request =
      t.normalizeV2Request =
      t.removeSuffixFromStringIfExists =
        void 0);
  const n = no,
    e = KB,
    r = $0;
  t.removeSuffixFromStringIfExists = (t, n) => {
    const e = n.length;
    return (null == t ? void 0 : t.slice(-e)) === n
      ? t.slice(0, t.length - e)
      : t;
  };
  t.normalizeV2Request = (t) => {
    var n, e, r;
    const o = null == t ? void 0 : t.service;
    return {
      serviceName:
        null ===
          (e =
            null === (n = null == o ? void 0 : o.api) || void 0 === n
              ? void 0
              : n.serviceId) || void 0 === e
          ? void 0
          : e.replace(/\s+/g, ""),
      commandName:
        ((i = null == t ? void 0 : t.operation),
        "string" == typeof i ? i.charAt(0).toUpperCase() + i.slice(1) : i),
      commandInput: t.params,
      region:
        null === (r = null == o ? void 0 : o.config) || void 0 === r
          ? void 0
          : r.region,
    };
    var i;
  };
  t.normalizeV3Request = (n, e, r, o) => ({
    serviceName: null == n ? void 0 : n.replace(/\s+/g, ""),
    commandName: (0, t.removeSuffixFromStringIfExists)(e, "Command"),
    commandInput: r,
    region: o,
  });
  t.extractAttributesFromNormalizedRequest = (t) => ({
    [e.SemanticAttributes.RPC_SYSTEM]: "aws-api",
    [e.SemanticAttributes.RPC_METHOD]: t.commandName,
    [e.SemanticAttributes.RPC_SERVICE]: t.serviceName,
    [r.AttributeNames.AWS_REGION]: t.region,
  });
  t.bindPromise = (e, r, o = 1) => {
    const i = e.then;
    return (
      (e.then = function (e, s) {
        const u = n.context.bind(r, e),
          c = n.context.bind(r, s),
          a = i.call(this, u, c);
        return o > 1 ? (0, t.bindPromise)(a, r, o - 1) : a;
      }),
      e
    );
  };
})(P1);
var V1 = {};
Object.defineProperty(V1, "__esModule", { value: !0 }), (V1.propwrap = void 0);
const G1 = Object.defineProperty,
  X1 = Object.getOwnPropertyDescriptor,
  U1 = Object.prototype.hasOwnProperty,
  W1 = Object.getOwnPropertyNames,
  Y1 = (t, n, e, r) => {
    if ((n && "object" == typeof n) || "function" == typeof n)
      for (const o of W1(n))
        U1.call(t, o) ||
          o === e ||
          G1(t, o, {
            get: () => n[o],
            enumerable: !(r = X1(n, o)) || r.enumerable,
          });
    return t;
  };
(V1.propwrap = (t, n, e) => {
  const r = n.split("."),
    o = [t];
  let i,
    s,
    u = t;
  for (let t = 0; t < r.length; t++) {
    if (((i = r[t]), (s = u[i]), !s))
      throw new TypeError(
        `cannot wrap "${n}": "<obj>.${r.slice(0, t).join(".")}" is ${typeof s}`
      );
    if (t < r.length - 1) {
      if ("object" != typeof s)
        throw new TypeError(
          `cannot wrap "${n}": "<obj>.${r
            .slice(0, t)
            .join(".")}" is not an Object`
        );
      (u = s), o.push(u);
    }
  }
  for (let t = r.length - 1; t >= 0; t--) {
    if (((i = r[t]), (u = o[t]), t === r.length - 1)) {
      s = e(u[i]);
    } else s = o[t + 1];
    const n = X1(u, i),
      c = G1({}, i, { value: s, enumerable: !n || n.enumerable });
    Y1(c, u, i), (o[t] = c);
  }
  return o[0];
}),
  Object.defineProperty(Q0, "__esModule", { value: !0 }),
  (Q0.AwsInstrumentation = void 0);
const H1 = no,
  D1 = pB,
  j1 = $0,
  x1 = q0,
  k1 = Z1,
  K1 = dF,
  B1 = P1,
  F1 = V1,
  J1 = KB,
  z1 = Symbol("opentelemetry.instrumentation.aws-sdk.client.config"),
  Q1 = Symbol("opentelemetry.instrumentation.aws-sdk.span");
class $1 extends K1.InstrumentationBase {
  constructor(t = {}) {
    super(
      "@opentelemetry/instrumentation-aws-sdk",
      k1.VERSION,
      Object.assign({}, t)
    ),
      (this.servicesExtensions = new x1.ServicesExtensions());
  }
  setConfig(t = {}) {
    this.Nt = Object.assign({}, t);
  }
  init() {
    const t = new K1.InstrumentationNodeModuleFile(
        "@aws-sdk/middleware-stack/dist/cjs/MiddlewareStack.js",
        [">=3.1.0 <3.35.0"],
        this.patchV3ConstructStack.bind(this),
        this.unpatchV3ConstructStack.bind(this)
      ),
      n = new K1.InstrumentationNodeModuleFile(
        "@aws-sdk/middleware-stack/dist-cjs/MiddlewareStack.js",
        [">=3.35.0"],
        this.patchV3ConstructStack.bind(this),
        this.unpatchV3ConstructStack.bind(this)
      ),
      e = new K1.InstrumentationNodeModuleDefinition(
        "@aws-sdk/middleware-stack",
        ["^3.1.0"],
        void 0,
        void 0,
        [t, n]
      ),
      r = this,
      o = new K1.InstrumentationNodeModuleDefinition(
        "@smithy/middleware-stack",
        [">=2.0.0"],
        (t, n) =>
          (0, F1.propwrap)(
            t,
            "constructStack",
            (t) => (
              r.Ct.debug("propwrapping aws-sdk v3 constructStack"), r.Ns(n, t)
            )
          )
      ),
      i = new K1.InstrumentationNodeModuleDefinition(
        "@aws-sdk/smithy-client",
        ["^3.1.0"],
        this.patchV3SmithyClient.bind(this),
        this.unpatchV3SmithyClient.bind(this)
      ),
      s = new K1.InstrumentationNodeModuleDefinition(
        "@smithy/smithy-client",
        [">=1.0.3"],
        this.patchV3SmithyClient.bind(this),
        this.unpatchV3SmithyClient.bind(this)
      ),
      u = new K1.InstrumentationNodeModuleFile(
        "aws-sdk/lib/core.js",
        ["^2.308.0"],
        this.patchV2.bind(this),
        this.unpatchV2.bind(this)
      );
    return [
      new K1.InstrumentationNodeModuleDefinition(
        "aws-sdk",
        ["^2.308.0"],
        void 0,
        void 0,
        [u]
      ),
      e,
      o,
      i,
      s,
    ];
  }
  patchV3ConstructStack(t, n) {
    return (
      H1.diag.debug(
        "aws-sdk instrumentation: applying patch to aws-sdk v3 constructStack"
      ),
      this.yt(t, "constructStack", this.Ns.bind(this, n)),
      t
    );
  }
  unpatchV3ConstructStack(t) {
    return (
      H1.diag.debug(
        "aws-sdk instrumentation: applying unpatch to aws-sdk v3 constructStack"
      ),
      this.Rt(t, "constructStack"),
      t
    );
  }
  patchV3SmithyClient(t) {
    return (
      H1.diag.debug(
        "aws-sdk instrumentation: applying patch to aws-sdk v3 client send"
      ),
      this.yt(t.Client.prototype, "send", this.Cs.bind(this)),
      t
    );
  }
  unpatchV3SmithyClient(t) {
    return (
      H1.diag.debug(
        "aws-sdk instrumentation: applying patch to aws-sdk v3 constructStack"
      ),
      this.Rt(t.Client.prototype, "send"),
      t
    );
  }
  patchV2(t, n) {
    return (
      H1.diag.debug(
        `aws-sdk instrumentation: applying patch to ${$1.component}`
      ),
      this.unpatchV2(t),
      this.yt(
        null == t ? void 0 : t.Request.prototype,
        "send",
        this.Ls.bind(this, n)
      ),
      this.yt(
        null == t ? void 0 : t.Request.prototype,
        "promise",
        this.Is.bind(this, n)
      ),
      t
    );
  }
  unpatchV2(t) {
    (0, K1.isWrapped)(null == t ? void 0 : t.Request.prototype.send) &&
      this.Rt(t.Request.prototype, "send"),
      (0, K1.isWrapped)(null == t ? void 0 : t.Request.prototype.promise) &&
        this.Rt(t.Request.prototype, "promise");
  }
  Ms(t, n) {
    var e, r;
    const o =
      null !== (e = n.spanName) && void 0 !== e
        ? e
        : `${t.serviceName}.${t.commandName}`;
    return this.tracer.startSpan(o, {
      kind: null !== (r = n.spanKind) && void 0 !== r ? r : H1.SpanKind.CLIENT,
      attributes: Object.assign(
        Object.assign({}, (0, B1.extractAttributesFromNormalizedRequest)(t)),
        n.spanAttributes
      ),
    });
  }
  ws(t, n, e) {
    var r, o, i, s, u;
    const c = t.operation,
      a = t.service,
      l = null == a ? void 0 : a.serviceIdentifier,
      f =
        null !== (r = n.spanName) && void 0 !== r
          ? r
          : `${e.serviceName}.${e.commandName}`;
    return this.tracer.startSpan(f, {
      kind: null !== (o = n.spanKind) && void 0 !== o ? o : H1.SpanKind.CLIENT,
      attributes: Object.assign(
        Object.assign(
          {
            [j1.AttributeNames.AWS_OPERATION]: c,
            [j1.AttributeNames.AWS_SIGNATURE_VERSION]:
              null === (i = null == a ? void 0 : a.config) || void 0 === i
                ? void 0
                : i.signatureVersion,
            [j1.AttributeNames.AWS_SERVICE_API]:
              null === (s = null == a ? void 0 : a.api) || void 0 === s
                ? void 0
                : s.className,
            [j1.AttributeNames.AWS_SERVICE_IDENTIFIER]: l,
            [j1.AttributeNames.AWS_SERVICE_NAME]:
              null === (u = null == a ? void 0 : a.api) || void 0 === u
                ? void 0
                : u.abbreviation,
          },
          (0, B1.extractAttributesFromNormalizedRequest)(e)
        ),
        n.spanAttributes
      ),
    });
  }
  Zs(t, n, e) {
    var r;
    if (null === (r = this.Nt) || void 0 === r ? void 0 : r.preRequestHook) {
      const r = { moduleVersion: e, request: n };
      (0, K1.safeExecuteInTheMiddle)(
        () => this.Nt.preRequestHook(t, r),
        (t) => {
          t &&
            H1.diag.error(
              `${$1.component} instrumentation: preRequestHook error`,
              t
            );
        },
        !0
      );
    }
  }
  Ps(t, n) {
    var e;
    const r = null === (e = this.Nt) || void 0 === e ? void 0 : e.responseHook;
    if (!r) return;
    const o = { response: n };
    (0, K1.safeExecuteInTheMiddle)(
      () => r(t, o),
      (t) => {
        t &&
          H1.diag.error(
            `${$1.component} instrumentation: responseHook error`,
            t
          );
      },
      !0
    );
  }
  Vs(t, n, e, r) {
    const o = this;
    n.on("complete", (i) => {
      H1.context.with(r, () => {
        var r;
        if (!n[Q1]) return;
        delete n[Q1];
        const s = i.requestId,
          u = { data: i.data, request: e, requestId: s };
        o.Ps(t, u),
          i.error
            ? t.recordException(i.error)
            : this.servicesExtensions.responseHook(u, t, o.tracer, o.Nt),
          t.setAttribute(j1.AttributeNames.AWS_REQUEST_ID, s);
        const c =
          null === (r = i.httpResponse) || void 0 === r ? void 0 : r.statusCode;
        c && t.setAttribute(J1.SemanticAttributes.HTTP_STATUS_CODE, c), t.end();
      });
    });
  }
  Ns(t, n) {
    const e = this;
    return function (...r) {
      const o = n.apply(this, r);
      return e.patchV3MiddlewareStack(t, o), o;
    };
  }
  Cs(t) {
    return function (n, ...e) {
      return (n[z1] = this.config), t.apply(this, [n, ...e]);
    };
  }
  patchV3MiddlewareStack(t, n) {
    (0, K1.isWrapped)(n.resolve) ||
      this.yt(n, "resolve", this.Gs.bind(this, t)),
      this.yt(n, "clone", this.Xs.bind(this, t)),
      this.yt(n, "concat", this.Xs.bind(this, t));
  }
  Xs(t, n) {
    const e = this;
    return function (...r) {
      const o = n.apply(this, r);
      return e.patchV3MiddlewareStack(t, o), o;
    };
  }
  Gs(t, n) {
    const e = this;
    return function (r, o) {
      const i = n.call(this, r, o);
      return function (n) {
        var r, s, u, c;
        const a = n[z1],
          l =
            null === (r = null == a ? void 0 : a.region) || void 0 === r
              ? void 0
              : r.call(a),
          f =
            null !== (s = null == a ? void 0 : a.serviceId) && void 0 !== s
              ? s
              : (0, B1.removeSuffixFromStringIfExists)(o.clientName, "Client"),
          d =
            null !== (u = o.commandName) && void 0 !== u
              ? u
              : null === (c = n.constructor) || void 0 === c
                ? void 0
                : c.name,
          h = (0, B1.normalizeV3Request)(f, d, n.input, void 0),
          p = e.servicesExtensions.requestPreSpanHook(h, e.Nt, e.Ct),
          S = e.Ms(h, p),
          E = H1.trace.setSpan(H1.context.active(), S),
          m = new Promise((r, o) => {
            Promise.resolve(l)
              .then((t) => {
                (h.region = t), S.setAttribute(j1.AttributeNames.AWS_REGION, t);
              })
              .catch((t) => {
                H1.diag.debug(
                  `${$1.component} instrumentation: failed to extract region from async function`,
                  t
                );
              })
              .finally(() => {
                e.Zs(S, h, t);
                const s = H1.context
                  .with(
                    E,
                    () => (
                      e.servicesExtensions.requestPostSpanHook(h),
                      e.mi(() => i.call(this, n))
                    )
                  )
                  .then((t) => {
                    var n, r, o, i, s, u;
                    const c =
                      null ===
                        (r =
                          null === (n = t.output) || void 0 === n
                            ? void 0
                            : n.$metadata) || void 0 === r
                        ? void 0
                        : r.requestId;
                    c && S.setAttribute(j1.AttributeNames.AWS_REQUEST_ID, c);
                    const a =
                      null ===
                        (i =
                          null === (o = t.output) || void 0 === o
                            ? void 0
                            : o.$metadata) || void 0 === i
                        ? void 0
                        : i.httpStatusCode;
                    a &&
                      S.setAttribute(J1.SemanticAttributes.HTTP_STATUS_CODE, a);
                    const l =
                      null ===
                        (u =
                          null === (s = t.output) || void 0 === s
                            ? void 0
                            : s.$metadata) || void 0 === u
                        ? void 0
                        : u.extendedRequestId;
                    l &&
                      S.setAttribute(
                        j1.AttributeNames.AWS_REQUEST_EXTENDED_ID,
                        l
                      );
                    const f = { data: t.output, request: h, requestId: c };
                    return (
                      e.servicesExtensions.responseHook(f, S, e.tracer, e.Nt),
                      e.Ps(S, f),
                      t
                    );
                  })
                  .catch((t) => {
                    const n = null == t ? void 0 : t.RequestId;
                    n && S.setAttribute(j1.AttributeNames.AWS_REQUEST_ID, n);
                    const e = null == t ? void 0 : t.extendedRequestId;
                    throw (
                      (e &&
                        S.setAttribute(
                          j1.AttributeNames.AWS_REQUEST_EXTENDED_ID,
                          e
                        ),
                      S.setStatus({
                        code: H1.SpanStatusCode.ERROR,
                        message: t.message,
                      }),
                      S.recordException(t),
                      t)
                    );
                  })
                  .finally(() => {
                    S.end();
                  });
                s.then((t) => {
                  r(t);
                }).catch((t) => o(t));
              });
          });
        return p.isIncoming ? (0, B1.bindPromise)(m, E, 2) : m;
      };
    };
  }
  Ls(t, n) {
    const e = this;
    return function (r) {
      if (this[Q1]) return n.call(this, r);
      const o = (0, B1.normalizeV2Request)(this),
        i = e.servicesExtensions.requestPreSpanHook(o, e.Nt, e.Ct),
        s = e.ws(this, i, o);
      this[Q1] = s;
      const u = H1.trace.setSpan(H1.context.active(), s),
        c = H1.context.bind(u, r);
      return (
        e.Zs(s, o, t),
        e.Vs(s, this, o, u),
        H1.context.with(
          u,
          () => (
            e.servicesExtensions.requestPostSpanHook(o),
            e.mi(() => n.call(this, c))
          )
        )
      );
    };
  }
  Is(t, n) {
    const e = this;
    return function (...r) {
      if (this[Q1]) return n.apply(this, r);
      const o = (0, B1.normalizeV2Request)(this),
        i = e.servicesExtensions.requestPreSpanHook(o, e.Nt, e.Ct),
        s = e.ws(this, i, o);
      this[Q1] = s;
      const u = H1.trace.setSpan(H1.context.active(), s);
      e.Zs(s, o, t), e.Vs(s, this, o, u);
      const c = H1.context.with(
        u,
        () => (
          e.servicesExtensions.requestPostSpanHook(o),
          e.mi(() => n.call(this, arguments))
        )
      );
      return i.isIncoming ? (0, B1.bindPromise)(c, u) : c;
    };
  }
  mi(t) {
    var n;
    return (
      null === (n = this.Nt) || void 0 === n
        ? void 0
        : n.suppressInternalInstrumentation
    )
      ? H1.context.with((0, D1.suppressTracing)(H1.context.active()), t)
      : t();
  }
}
(Q0.AwsInstrumentation = $1), ($1.component = "aws-sdk");
var q1 = {};
Object.defineProperty(q1, "__esModule", { value: !0 }),
  (function (t) {
    var n =
        (Wt && Wt.__createBinding) ||
        (Object.create
          ? function (t, n, e, r) {
              void 0 === r && (r = e),
                Object.defineProperty(t, r, {
                  enumerable: !0,
                  get: function () {
                    return n[e];
                  },
                });
            }
          : function (t, n, e, r) {
              void 0 === r && (r = e), (t[r] = n[e]);
            }),
      e =
        (Wt && Wt.__exportStar) ||
        function (t, e) {
          for (var r in t)
            "default" === r ||
              Object.prototype.hasOwnProperty.call(e, r) ||
              n(e, t, r);
        };
    Object.defineProperty(t, "__esModule", { value: !0 }), e(Q0, t), e(q1, t);
  })(z0);
const t2 = () => ({
  name: "Aws",
  setupOnce() {
    AK(
      new z0.AwsInstrumentation({
        preRequestHook(t) {
          t.setAttribute(JU, "auto.otel.aws");
        },
      })
    );
  },
});
var n2 = {},
  e2 = {},
  r2 = "x-amzn-trace-id",
  o2 = (function () {
    function t() {}
    return (
      (t.prototype.inject = function (t, n, e) {
        var r,
          o =
            null === (r = Qr.getSpan(t)) || void 0 === r
              ? void 0
              : r.spanContext();
        if (o && mr(o)) {
          var i = o.traceId,
            s =
              "Root=1-" +
              i.substring(0, 8) +
              "-" +
              i.substring(8) +
              ";Parent=" +
              o.spanId +
              ";Sampled=" +
              ((ke.SAMPLED & o.traceFlags) === ke.SAMPLED ? "1" : "0");
          e.set(n, r2, s);
        }
      }),
      (t.prototype.extract = function (t, n, e) {
        var r = this.getSpanContextFromHeader(n, e);
        return mr(r) ? Qr.setSpan(t, Qr.wrapSpanContext(r)) : t;
      }),
      (t.prototype.fields = function () {
        return [r2];
      }),
      (t.prototype.getSpanContextFromHeader = function (n, e) {
        var r = e.keys(n).find(function (t) {
          return t.toLowerCase() === r2;
        });
        if (!r) return or;
        var o = e.get(n, r);
        if (!o || "string" != typeof o) return or;
        for (var i, s = 0, u = rr, c = er, a = null; s < o.length; ) {
          var l = o.indexOf(";", s);
          l >= 0
            ? ((i = o.substring(s, l).trim()), (s = l + 1))
            : ((i = o.substring(s).trim()), (s = o.length));
          var f = i.indexOf("="),
            d = i.substring(f + 1);
          i.startsWith("Root")
            ? (u = t.Us(d))
            : i.startsWith("Parent")
              ? (c = t.Ws(d))
              : i.startsWith("Sampled") && (a = t.Ys(d));
        }
        if (null === a) return or;
        var h = { traceId: u, spanId: c, traceFlags: a, isRemote: !0 };
        return mr(h) ? h : or;
      }),
      (t.Us = function (t) {
        if (35 !== t.length) return rr;
        if (!t.startsWith("1")) return rr;
        if ("-" !== t.charAt(1) || "-" !== t.charAt(10)) return rr;
        var n = t.substring(2, 10) + t.substring(11, 35);
        return Sr(n) ? n : rr;
      }),
      (t.Ws = function (t) {
        return Er(t) ? t : er;
      }),
      (t.Ys = function (t) {
        return "0" === t ? ke.NONE : "1" === t ? ke.SAMPLED : null;
      }),
      t
    );
  })(),
  i2 = Ht(
    Object.freeze({
      __proto__: null,
      AWSXRAY_TRACE_ID_HEADER: r2,
      AWSXRayPropagator: o2,
    })
  ),
  s2 = {};
Object.defineProperty(s2, "__esModule", { value: !0 }),
  (s2.VERSION = void 0),
  (s2.VERSION = "0.40.0"),
  (function (t) {
    Object.defineProperty(t, "__esModule", { value: !0 }),
      (t.AwsLambdaInstrumentation = t.traceContextEnvironmentKey = void 0);
    const e = n,
      r = o,
      i = dF,
      s = no,
      u = i2,
      a = KB,
      l = s2,
      f = c,
      d = new u.AWSXRayPropagator(),
      h = { keys: (t) => Object.keys(t), get: (t, n) => t[n] };
    t.traceContextEnvironmentKey = "_X_AMZN_TRACE_ID";
    class p extends i.InstrumentationBase {
      constructor(t = {}) {
        super("@opentelemetry/instrumentation-aws-lambda", l.VERSION, t),
          (this.Nt = t),
          null == this.Nt.disableAwsContextPropagation &&
            "string" ==
              typeof f.env.OTEL_LAMBDA_DISABLE_AWS_CONTEXT_PROPAGATION &&
            "true" ===
              f.env.OTEL_LAMBDA_DISABLE_AWS_CONTEXT_PROPAGATION.toLocaleLowerCase() &&
            (this.Nt.disableAwsContextPropagation = !0);
      }
      setConfig(t = {}) {
        this.Nt = t;
      }
      init() {
        var t;
        const n = process.env.LAMBDA_TASK_ROOT,
          o =
            null !== (t = this.Nt.lambdaHandler) && void 0 !== t
              ? t
              : process.env._HANDLER;
        if (!n || !o)
          return (
            this.Ct.debug(
              "Skipping lambda instrumentation: no _HANDLER/lambdaHandler or LAMBDA_TASK_ROOT.",
              { taskRoot: n, handlerDef: o }
            ),
            []
          );
        const u = e.basename(o),
          c = o.substr(0, o.length - u.length),
          [a, l] = u.split(".", 2);
        let f = e.resolve(n, c, a);
        if (!f.endsWith(".js"))
          try {
            r.statSync(`${f}.js`), (f += ".js");
          } catch (t) {
            f += ".cjs";
          }
        return (
          s.diag.debug("Instrumenting lambda handler", {
            taskRoot: n,
            handlerDef: o,
            handler: u,
            moduleRoot: c,
            module: a,
            filename: f,
            functionName: l,
          }),
          [
            new i.InstrumentationNodeModuleDefinition(
              f,
              ["*"],
              void 0,
              void 0,
              [
                new i.InstrumentationNodeModuleFile(
                  a,
                  ["*"],
                  (t) => (
                    s.diag.debug("Applying patch for lambda handler"),
                    (0, i.isWrapped)(t[l]) && this.Rt(t, l),
                    this.yt(t, l, this.Hs()),
                    t
                  ),
                  (t) => {
                    null != t &&
                      (s.diag.debug("Removing patch for lambda handler"),
                      this.Rt(t, l));
                  }
                ),
              ]
            ),
          ]
        );
      }
      Hs() {
        return (t) => this.Ds(t);
      }
      Ds(t) {
        s.diag.debug("patch handler function");
        const n = this;
        return function (e, r, o) {
          const u = n.Nt,
            c = p.js(
              e,
              r,
              !0 === u.disableAwsContextPropagation,
              u.eventContextExtractor || p.xs
            ),
            l = r.functionName,
            f = n.tracer.startSpan(
              l,
              {
                kind: s.SpanKind.SERVER,
                attributes: {
                  [a.SemanticAttributes.FAAS_EXECUTION]: r.awsRequestId,
                  [a.SemanticResourceAttributes.FAAS_ID]: r.invokedFunctionArn,
                  [a.SemanticResourceAttributes.CLOUD_ACCOUNT_ID]: p.ks(
                    r.invokedFunctionArn
                  ),
                },
              },
              c
            );
          return (
            u.requestHook &&
              (0, i.safeExecuteInTheMiddle)(
                () => u.requestHook(f, { event: e, context: r }),
                (t) => {
                  t &&
                    s.diag.error(
                      "aws-lambda instrumentation: requestHook error",
                      t
                    );
                },
                !0
              ),
            s.context.with(s.trace.setSpan(c, f), () => {
              const s = n.Ks(o, f),
                u = (0, i.safeExecuteInTheMiddle)(
                  () => t.apply(this, [e, r, s]),
                  (t) => {
                    null != t && (n.Bs(f, t), n.Fs(f, t, () => {}));
                  }
                );
              return "function" == typeof (null == u ? void 0 : u.then)
                ? u.then(
                    (t) => (
                      n.Bs(f, null, t),
                      new Promise((e) => n.Fs(f, void 0, () => e(t)))
                    ),
                    (t) => (
                      n.Bs(f, t), new Promise((e, r) => n.Fs(f, t, () => r(t)))
                    )
                  )
                : u;
            })
          );
        };
      }
      setTracerProvider(t) {
        super.setTracerProvider(t), (this.Js = this.zs(t));
      }
      zs(t) {
        if (!t) return;
        let n = t;
        return (
          "function" == typeof n.getDelegate && (n = n.getDelegate()),
          "function" == typeof n.forceFlush ? n.forceFlush.bind(n) : void 0
        );
      }
      setMeterProvider(t) {
        super.setMeterProvider(t), (this.Qs = this.$s(t));
      }
      $s(t) {
        if (!t) return;
        const n = t;
        return "function" == typeof n.forceFlush
          ? n.forceFlush.bind(n)
          : void 0;
      }
      Ks(t, n) {
        const e = this;
        return function (r, o) {
          s.diag.debug("executing wrapped lookup callback function"),
            e.Bs(n, r, o),
            e.Fs(
              n,
              r,
              () => (
                s.diag.debug("executing original lookup callback function"),
                t.apply(this, [r, o])
              )
            );
        };
      }
      Fs(t, n, e) {
        let r;
        n && t.recordException(n),
          "string" == typeof n ? (r = n) : n && (r = n.message),
          r && t.setStatus({ code: s.SpanStatusCode.ERROR, message: r }),
          t.end();
        const o = [];
        this.Js
          ? o.push(this.Js())
          : s.diag.error(
              "Spans may not be exported for the lambda function because we are not force flushing before callback."
            ),
          this.Qs
            ? o.push(this.Qs())
            : s.diag.error(
                "Metrics may not be exported for the lambda function because we are not force flushing before callback."
              ),
          Promise.all(o).then(e, e);
      }
      Bs(t, n, e) {
        var r;
        (null === (r = this.Nt) || void 0 === r ? void 0 : r.responseHook) &&
          (0, i.safeExecuteInTheMiddle)(
            () => this.Nt.responseHook(t, { err: n, res: e }),
            (t) => {
              t &&
                s.diag.error(
                  "aws-lambda instrumentation: responseHook error",
                  t
                );
            },
            !0
          );
      }
      static ks(t) {
        const n = t.split(":");
        if (n.length >= 5) return n[4];
      }
      static xs(t) {
        const n = t.headers || {};
        return s.propagation.extract(s.context.active(), n, h);
      }
      static js(n, e, r, o) {
        var c, a;
        let l;
        if (!r) {
          const n = process.env[t.traceContextEnvironmentKey];
          if (
            (n &&
              (l = d.extract(
                s.context.active(),
                { [u.AWSXRAY_TRACE_ID_HEADER]: n },
                h
              )),
            l)
          ) {
            const t =
              null === (c = s.trace.getSpan(l)) || void 0 === c
                ? void 0
                : c.spanContext();
            if (
              t &&
              (t.traceFlags & s.TraceFlags.SAMPLED) === s.TraceFlags.SAMPLED
            )
              return l;
          }
        }
        const f = (0, i.safeExecuteInTheMiddle)(
          () => o(n, e),
          (t) => {
            t &&
              s.diag.error(
                "aws-lambda instrumentation: eventContextExtractor error",
                t
              );
          },
          !0
        );
        return (
          null === (a = s.trace.getSpan(f)) || void 0 === a
            ? void 0
            : a.spanContext()
        )
          ? f
          : l || s.ROOT_CONTEXT;
      }
    }
    t.AwsLambdaInstrumentation = p;
  })(e2);
var u2 = {};
Object.defineProperty(u2, "__esModule", { value: !0 }),
  (function (t) {
    var n =
        (Wt && Wt.__createBinding) ||
        (Object.create
          ? function (t, n, e, r) {
              void 0 === r && (r = e),
                Object.defineProperty(t, r, {
                  enumerable: !0,
                  get: function () {
                    return n[e];
                  },
                });
            }
          : function (t, n, e, r) {
              void 0 === r && (r = e), (t[r] = n[e]);
            }),
      e =
        (Wt && Wt.__exportStar) ||
        function (t, e) {
          for (var r in t)
            "default" === r ||
              Object.prototype.hasOwnProperty.call(e, r) ||
              n(e, t, r);
        };
    Object.defineProperty(t, "__esModule", { value: !0 }), e(e2, t), e(u2, t);
  })(n2);
const c2 = () => ({
  name: "AwsLambda",
  setupOnce() {
    AK(
      new n2.AwsLambdaInstrumentation({
        requestHook(t) {
          t.setAttribute(JU, "auto.otel.aws-lambda");
        },
      })
    );
  },
});
function a2(t) {
  return t.addEventProcessor((t) => (jt(t, { handled: !1 }), t)), t;
}
function l2(t) {
  let n,
    e = t[0],
    r = 1;
  for (; r < t.length; ) {
    const o = t[r],
      i = t[r + 1];
    if (
      ((r += 2), ("optionalAccess" === o || "optionalCall" === o) && null == e)
    )
      return;
    "access" === o || "optionalAccess" === o
      ? ((n = e), (e = i(e)))
      : ("call" !== o && "optionalCall" !== o) ||
        ((e = i((...t) => e.call(n, ...t))), (n = void 0));
  }
  return e;
}
const { isPromise: f2 } = e.types;
function d2(t) {
  return [
    WY(),
    XY(),
    HY(),
    jY(),
    MK(),
    NK(),
    IK(),
    sB(),
    uB(),
    DK(),
    qK(),
    PK(),
    ...(x0() ? [nB()] : []),
    t2(),
    c2(),
  ];
}
function h2(t) {
  return "function" == typeof t.getRemainingTimeInMillis
    ? t.getRemainingTimeInMillis()
    : 0;
}
function p2(n, e = {}) {
  const r = t.performance.now(),
    o = {
      flushTimeout: 2e3,
      callbackWaitsForEmptyEventLoop: !1,
      captureTimeoutWarning: !0,
      timeoutWarningLimit: 500,
      captureAllSettledReasons: !1,
      startTrace: !0,
      ...e,
    };
  let s;
  const u =
    n.length > 2
      ? (t, e) =>
          new Promise((r, o) => {
            const i = n(t, e, (t, n) => {
              null == t ? r(n) : o(t);
            });
            f2(i) && i.then(r, o);
          })
      : n;
  return async (n, e) => {
    e.callbackWaitsForEmptyEventLoop = o.callbackWaitsForEmptyEventLoop;
    const c = Math.ceil(h2(e) / 1e3),
      a = Math.floor(c / 60),
      l = c % 60,
      f = a > 0 ? `${a}m${l}s` : `${l}s`;
    if (o.captureTimeoutWarning) {
      const t = h2(e) - o.timeoutWarningLimit;
      s = setTimeout(() => {
        PU((t) => {
          t.setTag("timeout", f),
            captureMessage(
              `Possible function timeout: ${e.functionName}`,
              "warning"
            );
        });
      }, t);
    }
    async function d(i) {
      const c = MU();
      let a;
      try {
        if (
          ((function (n, e, r) {
            n.setContext("aws.lambda", {
              aws_request_id: e.awsRequestId,
              function_name: e.functionName,
              function_version: e.functionVersion,
              invoked_function_arn: e.invokedFunctionArn,
              execution_duration_in_millis: t.performance.now() - r,
              remaining_time_in_millis: h2(e),
              "sys.argv": process.argv,
            }),
              n.setContext("aws.cloudwatch.logs", {
                log_group: e.logGroupName,
                log_stream: e.logStreamName,
                url: `https://console.aws.amazon.com/cloudwatch/home?region=${
                  process.env.AWS_REGION
                }#logsV2:log-groups/log-group/${encodeURIComponent(
                  e.logGroupName
                )}/log-events/${encodeURIComponent(
                  e.logStreamName
                )}?filterPattern="${e.awsRequestId}"`,
              });
          })(c, e, r),
          (a = await u(n, e)),
          o.captureAllSettledReasons &&
            Array.isArray(a) &&
            a.every(
              (t) =>
                Object.prototype.hasOwnProperty.call(t, "status") &&
                (Object.prototype.hasOwnProperty.call(t, "value") ||
                  Object.prototype.hasOwnProperty.call(t, "reason"))
            ))
        ) {
          const t = a.reduce(
            (t, n) => (
              "rejected" === n.status && n.reason && t.push(n.reason), t
            ),
            []
          );
          t.forEach((t) => {
            captureException(t, (t) => a2(t));
          });
        }
      } catch (t) {
        throw (captureException(t, (t) => a2(t)), t);
      } finally {
        clearTimeout(s),
          l2([i, "optionalAccess", (t) => t.end, "call", (t) => t()]),
          await fY(o.flushTimeout).catch((t) => {});
      }
      return a;
    }
    if (o.startTrace) {
      const t = n;
      return eK(
        {
          sentryTrace:
            t.headers && G(t.headers["sentry-trace"])
              ? t.headers["sentry-trace"]
              : void 0,
          baggage: l2([
            t,
            "access",
            (t) => t.headers,
            "optionalAccess",
            (t) => t.baggage,
          ]),
        },
        () =>
          HW(
            {
              name: e.functionName,
              op: "function.aws.lambda",
              attributes: {
                [KU]: "component",
                [JU]: "auto.function.serverless",
              },
            },
            (t) => (
              (function (t, n) {
                t.addEventProcessor(
                  (t) => ((t.transaction = n.functionName), t)
                ),
                  t.setTag(
                    "server_name",
                    process.env._AWS_XRAY_DAEMON_ADDRESS ||
                      process.env.SENTRY_NAME ||
                      i.hostname()
                  ),
                  t.setTag("url", `awslambda:///${n.functionName}`);
              })(MU(), e),
              d(t)
            )
          )
      );
    }
    return PU(async () => d(void 0));
  };
}
(exports.DEFAULT_USER_INCLUDES = dn),
  (exports.NodeClient = g0),
  (exports.SDK_VERSION = IY),
  (exports.SEMANTIC_ATTRIBUTE_SENTRY_OP = FU),
  (exports.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN = JU),
  (exports.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE = BU),
  (exports.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE = KU),
  (exports.Scope = NU),
  (exports.addBreadcrumb = PY),
  (exports.addEventProcessor = function (t) {
    wU().addEventProcessor(t);
  }),
  (exports.addIntegration = function (t) {
    const n = GU();
    n && n.addIntegration(t);
  }),
  (exports.addOpenTelemetryInstrumentation = AK),
  (exports.addRequestDataToEvent = Sn),
  (exports.anrIntegration = fB),
  (exports.awsIntegration = t2),
  (exports.awsLambdaIntegration = c2),
  (exports.captureCheckIn = aY),
  (exports.captureConsoleIntegration = xY),
  (exports.captureEvent = eY),
  (exports.captureException = captureException),
  (exports.captureFeedback = function (t, n = {}) {
    const {
        message: e,
        name: r,
        email: o,
        url: i,
        source: s,
        associatedEventId: u,
      } = t,
      c = GU(),
      a = {
        contexts: {
          feedback: Et({
            contact_email: o,
            name: r,
            message: e,
            url: i,
            source: s,
            associated_event_id: u,
          }),
        },
        type: "feedback",
        level: "info",
      };
    return c && c.emit("beforeSendFeedback", a, n), MU().captureEvent(a, n);
  }),
  (exports.captureMessage = captureMessage),
  (exports.captureSession = function (t = !1) {
    t ? pY() : SY();
  }),
  (exports.close = async function (t) {
    const n = GU();
    return n ? n.close(t) : Promise.resolve(!1);
  }),
  (exports.commonjsGlobal = Wt),
  (exports.connectIntegration = a0),
  (exports.consoleIntegration = MK),
  (exports.contextLinesIntegration = DK),
  (exports.continueTrace = eK),
  (exports.createGetModuleFromFilename = R0),
  (exports.createTransport = CY),
  (exports.cron = J0),
  (exports.debugIntegration = kY),
  (exports.dedupeIntegration = KY),
  (exports.defaultStackParser = O0),
  (exports.endSession = pY),
  (exports.expressErrorHandler = sF),
  (exports.expressIntegration = iF),
  (exports.extraErrorDataIntegration = QY),
  (exports.extractRequestData = pn),
  (exports.fastifyIntegration = _F),
  (exports.flush = fY),
  (exports.functionToStringIntegration = XY),
  (exports.getActiveSpan = vW),
  (exports.getAugmentedNamespace = Ht),
  (exports.getAutoPerformanceIntegrations = function () {
    return [
      iF(),
      _F(),
      YF(),
      bJ(),
      MJ(),
      FJ(),
      dz(),
      sQ(),
      KQ(),
      bQ(),
      Zq(),
      t0(),
      a0(),
    ];
  }),
  (exports.getClient = GU),
  (exports.getCurrentHub = EH),
  (exports.getCurrentScope = MU),
  (exports.getDefaultIntegrations = d2),
  (exports.getGlobalScope = ZU),
  (exports.getIsolationScope = wU),
  (exports.getRootSpan = bW),
  (exports.getSentryRelease = A0),
  (exports.getSpanDescendants = _W),
  (exports.getSpanStatusFromHttpCode = eW),
  (exports.graphqlIntegration = YF),
  (exports.hapiIntegration = Zq),
  (exports.httpIntegration = NK),
  (exports.inboundFiltersIntegration = WY),
  (exports.init = function (t = {}) {
    const n = { Ze: {}, defaultIntegrations: d2(), ...t };
    (n.Ze.sdk = n.Ze.sdk || {
      name: "sentry.javascript.aws-serverless",
      integrations: ["AWSLambda"],
      packages: [{ name: "npm:@sentry/aws-serverless", version: IY }],
      version: IY,
    }),
      k0(n);
  }),
  (exports.initOpenTelemetry = j0),
  (exports.isInitialized = function () {
    return !!GU();
  }),
  (exports.koaIntegration = t0),
  (exports.lastEventId = function () {
    return wU().lastEventId();
  }),
  (exports.linkedErrorsIntegration = HY),
  (exports.localVariablesIntegration = qK),
  (exports.makeNodeTransport = v0),
  (exports.metricsDefault = pH),
  (exports.modulesIntegration = nB),
  (exports.mongoIntegration = bJ),
  (exports.mongooseIntegration = MJ),
  (exports.mysql2Integration = dz),
  (exports.mysqlIntegration = FJ),
  (exports.nativeNodeFetchIntegration = IK),
  (exports.nestIntegration = bQ),
  (exports.nodeContextIntegration = PK),
  (exports.onUncaughtExceptionIntegration = sB),
  (exports.onUnhandledRejectionIntegration = uB),
  (exports.parameterize = function (t, ...n) {
    const e = new String(String.raw(t, ...n));
    return (
      (e.__sentry_template_string__ = t
        .join("\0")
        .replace(/%/g, "%%")
        .replace(/\0/g, "%s")),
      (e.__sentry_template_values__ = n),
      e
    );
  }),
  (exports.postgresIntegration = KQ),
  (exports.prismaIntegration = x$),
  (exports.redisIntegration = sQ),
  (exports.requestDataIntegration = jY),
  (exports.require$$1 = KB),
  (exports.rewriteFramesIntegration = $Y),
  (exports.sessionTimingIntegration = qY),
  (exports.setContext = rY),
  (exports.setCurrentClient = function (t) {
    MU().setClient(t),
      (function (t) {
        const n = bU(_U());
        n.hub &&
          "function" == typeof n.hub.getStackTop &&
          (n.hub.getStackTop().client = t);
      })(t);
  }),
  (exports.setExtra = iY),
  (exports.setExtras = oY),
  (exports.setHttpStatus = function (t, n) {
    t.setAttribute("http.response.status_code", n);
    const e = eW(n);
    "unknown_error" !== e.message && t.setStatus(e);
  }),
  (exports.setMeasurement = function (t, n, e) {
    const r = vW(),
      o = r && bW(r);
    o && o.addEvent(t, { [QU]: n, [zU]: e });
  }),
  (exports.setTag = uY),
  (exports.setTags = sY),
  (exports.setUser = cY),
  (exports.setupConnectErrorHandler = (t) => {
    t.use(l0),
      !oF(t.use) &&
        dY() &&
        ot(() => {
          console.warn(
            "[Sentry] Connect is not instrumented. This is likely because you required/imported connect before calling `Sentry.init()`."
          );
        });
  }),
  (exports.setupExpressErrorHandler = function (t) {
    t.use(sF()),
      !oF(t.use) &&
        dY() &&
        ot(() => {
          console.warn(
            "[Sentry] Express is not instrumented. This is likely because you required/imported express before calling `Sentry.init()`."
          );
        });
  }),
  (exports.setupHapiErrorHandler = async function (t) {
    await t.register(Vq),
      !oF(t.register) &&
        dY() &&
        ot(() => {
          console.warn(
            "[Sentry] Hapi is not instrumented. This is likely because you required/imported hapi before calling `Sentry.init()`."
          );
        });
  }),
  (exports.setupKoaErrorHandler = (t) => {
    t.use(async (t, n) => {
      try {
        await n();
      } catch (t) {
        captureException(t);
      }
    }),
      !oF(t.use) &&
        dY() &&
        ot(() => {
          console.warn(
            "[Sentry] Koa is not instrumented. This is likely because you required/imported koa before calling `Sentry.init()`."
          );
        });
  }),
  (exports.setupNestErrorHandler = function (t, n) {
    t.useGlobalInterceptors({
      intercept(t, n) {
        if (wU() === IU())
          return (
            it.warn(
              "Isolation scope is still the default isolation scope, skipping setting transactionName."
            ),
            n.handle()
          );
        if ("http" === t.getType()) {
          const n = t.switchToHttp().getRequest();
          n.route &&
            wU().setTransactionName(
              `${
                Fn([
                  n,
                  "access",
                  (t) => t.method,
                  "optionalAccess",
                  (t) => t.toUpperCase,
                  "call",
                  (t) => t(),
                ]) || "GET"
              } ${n.route.path}`
            );
        }
        return n.handle();
      },
    });
    const e = new Proxy(n, {
      get(t, n, e) {
        if ("catch" === n) {
          const r = Reflect.get(t, n, e);
          return (n, e) => (captureException(n), r.apply(t, [n, e]));
        }
        return Reflect.get(t, n, e);
      },
    });
    t.useGlobalFilters(e);
  }),
  (exports.spanToBaggageHeader = function (t) {
    return An(uW(t));
  }),
  (exports.spanToJSON = hW),
  (exports.spanToTraceHeader = function (t) {
    const { traceId: n, spanId: e } = t.spanContext();
    return Ln(n, e, pW(t));
  }),
  (exports.spotlightIntegration = f0),
  (exports.startInactiveSpan = function (t) {
    const n = kW();
    if (n.startInactiveSpan) return n.startInactiveSpan(t);
    const e = xW(t),
      r = t.scope || MU(),
      o = BW(r);
    return t.onlyIfParent && !o
      ? new MW()
      : jW({
          parentSpan: o,
          spanContext: e,
          forceTransaction: t.forceTransaction,
          scope: r,
        });
  }),
  (exports.startSession = hY),
  (exports.startSpan = function (t, n) {
    const e = kW();
    if (e.startSpan) return e.startSpan(t, n);
    const r = xW(t);
    return PU(t.scope, (e) => {
      const o = BW(e),
        i =
          t.onlyIfParent && !o
            ? new MW()
            : jW({
                parentSpan: o,
                spanContext: r,
                forceTransaction: t.forceTransaction,
                scope: e,
              });
      return (
        AU(e, i),
        wW(
          () => n(i),
          () => {
            const { status: t } = hW(i);
            !i.isRecording() ||
              (t && "ok" !== t) ||
              i.setStatus({ code: nW, message: "internal_error" });
          },
          () => i.end()
        )
      );
    });
  }),
  (exports.startSpanManual = HW),
  (exports.trpcMiddleware = function (t = {}) {
    return function (n) {
      const { path: e, type: r, next: o, rawInput: i } = n,
        s = GU(),
        u = s && s.getOptions(),
        c = { procedure_type: r };
      function a(t) {
        "object" == typeof t &&
          null !== t &&
          "ok" in t &&
          !t.ok &&
          "error" in t &&
          captureException(t.error, SH);
      }
      return (
        (void 0 !== t.attachRpcInput
          ? t.attachRpcInput
          : u && u.sendDefaultPii) && (c.input = Ft(i)),
        rY("trpc", c),
        HW(
          {
            name: `trpc/${e}`,
            op: "rpc.server",
            attributes: { [KU]: "route", [JU]: "auto.rpc.trpc" },
          },
          (t) => {
            let n;
            try {
              n = o();
            } catch (n) {
              throw (captureException(n, SH), t.end(), n);
            }
            return W(n)
              ? n.then(
                  (n) => (a(n), t.end(), n),
                  (n) => {
                    throw (captureException(n, SH), t.end(), n);
                  }
                )
              : (a(n), t.end(), n);
          }
        )
      );
    };
  }),
  (exports.tryPatchHandler = function (t, e) {
    const r = n.basename(e),
      i = r.match(/^([^.]*)\.(.*)$/);
    if (!i) return;
    const [, s, u] = i;
    let c, a, l;
    try {
      const i = e.substring(0, e.indexOf(r));
      c = (function (t, e, r) {
        const i = n.resolve(t, e, r);
        return o.existsSync(i) || o.existsSync(`${i}.js`)
          ? require(i)
          : require(require.resolve(r, { paths: [t, e] }));
      })(t, i, s);
    } catch (t) {
      return;
    }
    u.split(".").forEach((t) => {
      (a = c), (c = c && c[t]), (l = t);
    }),
      c && "function" == typeof c && (a[l] = p2(c));
  }),
  (exports.withActiveSpan = function (t, n) {
    const e = kW();
    return e.withActiveSpan
      ? e.withActiveSpan(t, n)
      : PU((e) => (AU(e, t || void 0), n(e)));
  }),
  (exports.withIsolationScope = VU),
  (exports.withMonitor = lY),
  (exports.withScope = PU),
  (exports.wrapHandler = p2),
  (exports.zodErrorsIntegration = rH);
